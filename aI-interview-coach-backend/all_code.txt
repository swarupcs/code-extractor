

==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\agents\base-agent.ts
==============================

/**
 * Base Agent Class
 * All agents inherit from this class
 */

import {
  IAgent,
  AgentType,
  BaseAgentInput,
  BaseAgentOutput,
  LLMMessage,
} from '../types';
import { ILLMProvider } from '../services/llm/base-provider';
import { MemoryManager } from '../memory/memory-manager';

export abstract class BaseAgent implements IAgent {
  abstract type: AgentType;
  abstract name: string;
  abstract description: string;

  constructor(
    protected llmProvider: ILLMProvider,
    protected memoryManager: MemoryManager
  ) {}

  /**
   * Main processing method - must be implemented by each agent
   */
  abstract process(input: BaseAgentInput): Promise<BaseAgentOutput>;

  /**
   * Check if this agent can handle the input
   * Default implementation - can be overridden
   */
  async canHandle(input: BaseAgentInput): Promise<boolean> {
    // Default: use keyword matching
    const keywords = this.getKeywords();
    const queryLower = input.query.toLowerCase();
    
    return keywords.some((keyword) => queryLower.includes(keyword));
  }

  /**
   * Get keywords this agent responds to
   * Override in child classes
   */
  protected getKeywords(): string[] {
    return [];
  }

  /**
   * Build system prompt for this agent
   */
  protected abstract buildSystemPrompt(): string;

  /**
   * Get conversation context from memory
   */
  protected async getConversationContext(
    sessionId: string,
    maxTurns: number = 5
  ): Promise<LLMMessage[]> {
    const turns = await this.memoryManager.getConversationContext(
      sessionId,
      maxTurns
    );

    return turns.map((turn) => ({
      role: turn.role,
      content: turn.content,
    }));
  }

  /**
   * Save conversation turn to memory
   */
  protected async saveToMemory(
    sessionId: string,
    role: 'user' | 'assistant',
    content: string
  ): Promise<void> {
    await this.memoryManager.addTurn(sessionId, {
      role,
      content,
      timestamp: new Date(),
      agentType: this.type,
    });
  }

  /**
   * Generate response using LLM
   */
  protected async generateResponse(
    systemPrompt: string,
    userMessage: string,
    conversationHistory?: LLMMessage[],
    temperature: number = 0.7
  ): Promise<string> {
    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
    ];

    if (conversationHistory && conversationHistory.length > 0) {
      messages.push(...conversationHistory);
    }

    messages.push({ role: 'user', content: userMessage });

    const response = await this.llmProvider.generateCompletion({
      messages,
      temperature,
      maxTokens: 2000,
    });

    return response.content;
  }

  /**
   * Extract structured data from LLM response
   */
  protected async generateStructuredResponse<T>(
    systemPrompt: string,
    userMessage: string,
    schema: Record<string, unknown>,
    temperature: number = 0.3
  ): Promise<T> {
    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userMessage },
    ];

    return await this.llmProvider.generateStructuredOutput<T>(
      {
        messages,
        temperature,
        maxTokens: 2000,
      },
      schema
    );
  }

  /**
   * Calculate confidence score based on response quality
   * Override in child classes for custom logic
   */
  protected calculateConfidence(response: string, input: BaseAgentInput): number {
    // Simple heuristic: longer, more detailed responses = higher confidence
    const wordCount = response.split(/\s+/).length;
    const hasStructure = /\n-|\n\d+\.|\n\*/.test(response);
    
    let confidence = 0.6; // Base confidence

    if (wordCount > 100) confidence += 0.1;
    if (wordCount > 200) confidence += 0.1;
    if (hasStructure) confidence += 0.1;
    if (response.includes('example') || response.includes('specifically')) confidence += 0.1;

    return Math.min(confidence, 1.0);
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\agents\behavioral-learning-agents.ts
==============================

/**
 * HR Behavioral Agent
 * Handles behavioral interview questions using STAR method
 */

import { BaseAgent } from './base-agent';
import { AgentType, BaseAgentInput, BaseAgentOutput } from '../types';

export class HRBehavioralAgent extends BaseAgent {
  type = AgentType.HR_BEHAVIORAL;
  name = 'HR Behavioral Agent';
  description = 'Conducts behavioral interviews using STAR method';

  protected getKeywords(): string[] {
    return [
      'behavioral',
      'tell me about a time',
      'describe a situation',
      'star method',
      'teamwork',
      'conflict',
      'leadership',
      'challenge',
      'failure',
      'success',
      'motivation',
      'weakness',
      'strength',
    ];
  }

  protected buildSystemPrompt(): string {
    return `You are an expert HR interviewer specializing in behavioral interviews.

Your responsibilities:
1. Ask behavioral questions using the STAR method
2. Evaluate answers for completeness (Situation, Task, Action, Result)
3. Probe for specific details and outcomes
4. Assess soft skills: communication, teamwork, leadership, problem-solving
5. Provide constructive feedback

When asking questions:
- Use "Tell me about a time..." format
- Focus on real experiences, not hypotheticals
- Ask follow-up questions for clarity

When evaluating answers:
- Check for complete STAR structure
- Look for specific examples with measurable results
- Assess authenticity and reflection
- Identify areas for improvement

Be supportive and help candidates tell their best stories.`;
  }

  async process(input: BaseAgentInput): Promise<BaseAgentOutput> {
    await this.saveToMemory(input.sessionId, 'user', input.query);

    const systemPrompt = this.buildSystemPrompt();
    const conversationHistory = await this.getConversationContext(input.sessionId);

    const response = await this.generateResponse(
      systemPrompt,
      input.query,
      conversationHistory,
      0.7
    );

    await this.saveToMemory(input.sessionId, 'assistant', response);

    // Evaluate if the response is a STAR-structured answer
    const isSTARAnswer = await this.isSTARAnswer(input.query);

    const suggestedFollowUps = isSTARAnswer
      ? [
          'Can you elaborate on the result?',
          'What would you do differently?',
          'Ask me another behavioral question',
        ]
      : [
          'Can you give me an example using STAR method?',
          'What is the STAR method?',
          'Give me a behavioral question to practice',
        ];

    return {
      response,
      confidence: 0.85,
      metadata: { isSTARAnswer },
      suggestedFollowUps,
    };
  }

  /**
   * Check if the query contains a STAR-formatted answer
   */
  private async isSTARAnswer(query: string): Promise<boolean> {
    const indicators = [
      'situation',
      'task',
      'action',
      'result',
      'when I',
      'at my previous',
      'during my time',
    ];

    const queryLower = query.toLowerCase();
    return indicators.some((indicator) => queryLower.includes(indicator));
  }
}

/**
 * Learning Support Agent
 * Tracks progress and suggests personalized improvements
 */
export class LearningSupportAgent extends BaseAgent {
  type = AgentType.LEARNING_SUPPORT;
  name = 'Learning Support Agent';
  description = 'Provides personalized learning recommendations';

  protected getKeywords(): string[] {
    return [
      'progress',
      'improvement',
      'learning',
      'weak',
      'struggling',
      'practice',
      'roadmap',
      'study plan',
      'resources',
      'tips',
    ];
  }

  protected buildSystemPrompt(): string {
    return `You are a learning coach helping candidates improve their interview skills.

Your responsibilities:
1. Analyze performance across all interview types
2. Identify weak areas and skill gaps
3. Create personalized improvement plans
4. Suggest relevant resources and practice problems
5. Track progress and celebrate milestones

When providing recommendations:
- Be specific and actionable
- Prioritize high-impact improvements
- Suggest concrete resources (courses, books, practice sites)
- Set realistic timelines and milestones
- Encourage consistent practice

Be motivating, supportive, and data-driven.`;
  }

  async process(input: BaseAgentInput): Promise<BaseAgentOutput> {
    await this.saveToMemory(input.sessionId, 'user', input.query);

    // Get user's progress and weak areas
    const userSummary = await this.memoryManager.getUserSummary(input.userId);

    // Build context with user's data
    const userContext = `
User's Learning Profile:
- Total interviews: ${userSummary.progress.totalInterviews}
- Current level: ${userSummary.progress.currentLevel}
- Goal level: ${userSummary.progress.goalLevel}
- Weak areas: ${userSummary.weakAreas.map((wa) => `${wa.topic} (${wa.failureCount} times)`).join(', ')}
- Recent topics: ${userSummary.recentTopics.join(', ')}
`;

    const systemPrompt = this.buildSystemPrompt() + '\n\n' + userContext;
    const conversationHistory = await this.getConversationContext(input.sessionId);

    const response = await this.generateResponse(
      systemPrompt,
      input.query,
      conversationHistory,
      0.7
    );

    await this.saveToMemory(input.sessionId, 'assistant', response);

    return {
      response,
      confidence: 0.9,
      metadata: { userSummary },
      suggestedFollowUps: [
        'What should I focus on next?',
        'Give me practice problems for my weak areas',
        'Show me my progress',
      ],
    };
  }

  /**
   * Generate a personalized learning plan
   */
  async generateLearningPlan(userId: string): Promise<string> {
    const userSummary = await this.memoryManager.getUserSummary(userId);

    const prompt = `Create a personalized 4-week learning plan based on this profile:

${JSON.stringify(userSummary, null, 2)}

Include:
1. Weekly focus areas
2. Daily practice goals
3. Specific resources
4. Progress milestones

Make it actionable and motivating.`;

    return await this.generateResponse(
      this.buildSystemPrompt(),
      prompt,
      [],
      0.6
    );
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\agents\dsa-agent.ts
==============================

/**
 * DSA Interview Agent - FIXED VERSION
 * Handles data structures and algorithms interview questions
 *
 * KEY FIXES:
 * 1. Improved implementation detection
 * 2. Better evaluation prompts that don't incorrectly mark complete code as incomplete
 * 3. More accurate scoring for valid solutions
 * 4. Fixed TypeScript type errors
 */

import { BaseAgent } from './base-agent';
import { AgentType, BaseAgentInput, BaseAgentOutput } from '../types';
import { ILLMProvider } from '../services/llm/base-provider';
import { MemoryManager } from '../memory/memory-manager';
import { IVectorDatabase } from '../services/vector-db/base-vector-db';

interface DSAQuestion {
  question: string;
  difficulty: 'easy' | 'medium' | 'hard';
  topics: string[];
  hints: string[];
}

interface DSAEvaluation {
  score: number; // 0-100
  strengths: string[];
  weaknesses: string[];
  suggestions: string[];
  correctness: 'correct' | 'partially_correct' | 'incorrect';
  hasImplementation: boolean;
}

export class DSAInterviewAgent extends BaseAgent {
  type = AgentType.DSA_INTERVIEW;
  name = 'DSA Interview Agent';
  description = 'Conducts data structures and algorithms interviews';

  constructor(
    llmProvider: ILLMProvider,
    memoryManager: MemoryManager,
    private vectorDb?: IVectorDatabase,
  ) {
    super(llmProvider, memoryManager);
  }

  protected getKeywords(): string[] {
    return [
      'algorithm',
      'data structure',
      'leetcode',
      'coding',
      'array',
      'linked list',
      'tree',
      'graph',
      'dynamic programming',
      'recursion',
      'sorting',
      'searching',
      'hash',
      'stack',
      'queue',
      'binary search',
      'dfs',
      'bfs',
      'time complexity',
      'space complexity',
      'big o',
    ];
  }

  protected buildSystemPrompt(): string {
    return `You are an expert DSA (Data Structures & Algorithms) interviewer with deep knowledge of computer science fundamentals.

Your responsibilities:
1. Ask appropriate DSA questions based on difficulty level
2. Evaluate coding solutions for correctness, efficiency, and code quality
3. Provide detailed feedback on time/space complexity
4. Suggest optimizations and alternative approaches
5. Track weak areas for improvement

When asking questions:
- Start with problem statement
- Clarify constraints and edge cases
- Provide hints if requested
- Adjust difficulty based on performance

When evaluating answers:
- Check correctness of logic
- Analyze time and space complexity
- Review code quality and style
- Identify edge cases handled/missed
- Suggest optimizations

Be encouraging but honest. Focus on learning and improvement.`;
  }

  async process(input: BaseAgentInput): Promise<BaseAgentOutput> {
    // Save user query to memory
    await this.saveToMemory(input.sessionId, 'user', input.query);

    // Determine if this is a question request or answer submission
    const isAnswerSubmission = this.isAnswerSubmission(input.query);

    let response: string;
    let metadata: Record<string, unknown> = {};
    let suggestedFollowUps: string[] = [];

    if (isAnswerSubmission) {
      // Evaluate the submitted code/solution
      response = await this.evaluateAnswer(input);
      metadata = { type: 'evaluation' };
      suggestedFollowUps = [
        'Can you optimize this solution?',
        'What about edge cases?',
        'Give me another problem',
      ];
    } else {
      // Generate a DSA question or explanation
      response = await this.handleQuery(input);
      metadata = { type: 'question_or_explanation' };
      suggestedFollowUps = [
        'Can you give me a hint?',
        'What is the optimal approach?',
        'Show me a solution',
      ];
    }

    // Save agent response to memory
    await this.saveToMemory(input.sessionId, 'assistant', response);

    const confidence = this.calculateConfidence(response, input);

    return {
      response,
      confidence,
      metadata,
      suggestedFollowUps,
      requiresRAG: false,
    };
  }

  /**
   * Check if the query is an answer submission with actual implementation
   * IMPROVED: Better detection of valid code
   */
  private isAnswerSubmission(query: string): boolean {
    // Check for code patterns with actual implementation
    const codePatterns = [
      /function\s+\w+\s*\([^)]*\)\s*\{[\s\S]+\}/, // JavaScript function with body
      /const\s+\w+\s*=\s*\([^)]*\)\s*=>\s*\{[\s\S]+\}/, // Arrow function with body
      /def\s+\w+\s*\([^)]*\)\s*:[\s\S]+\n\s+\w+/, // Python function with body
      /class\s+Solution[\s\S]+{[\s\S]+}/, // Class with implementation
      /public\s+\w+\s+\w+\s*\([^)]*\)\s*\{[\s\S]+\}/, // Java method with body
    ];

    const hasCodePattern = codePatterns.some((pattern) => pattern.test(query));

    // Check for implementation indicators (not just signatures)
    const implementationKeywords = [
      /return\s+\w+/, // Actual return statement with value
      /for\s*\(/, // For loop
      /while\s*\(/, // While loop
      /if\s*\(/, // If statement
      /let\s+\w+\s*=/, // Variable declaration with assignment
      /const\s+\w+\s*=/, // Const declaration with assignment
    ];

    const hasImplementation = implementationKeywords.some((pattern) =>
      pattern.test(query),
    );

    // Check if it's not just a signature (has actual logic)
    const lines = query.split('\n').filter((line) => {
      const trimmed = line.trim();
      return (
        trimmed.length > 0 &&
        !trimmed.startsWith('//') &&
        !trimmed.startsWith('/*') &&
        !trimmed.startsWith('*')
      );
    });

    const hasMultipleLogicalLines = lines.length > 2;

    // Must have code pattern, implementation keywords, and multiple lines
    return hasCodePattern && hasImplementation && hasMultipleLogicalLines;
  }

  /**
   * Extract code from the submission
   */
  private extractCode(query: string): string {
    // Remove markdown code blocks if present
    const codeBlockMatch = query.match(
      /```(?:javascript|python|java|cpp)?\n([\s\S]*?)```/,
    );
    if (codeBlockMatch) {
      return codeBlockMatch[1].trim();
    }
    return query.trim();
  }

  /**
   * Handle general DSA queries (questions, explanations)
   */
  private async handleQuery(input: BaseAgentInput): Promise<string> {
    const systemPrompt = this.buildSystemPrompt();

    // Get user's weak areas to personalize questions
    const weakAreas = await this.memoryManager.getWeakAreas(input.userId);
    const weakAreaContext =
      weakAreas.length > 0
        ? `\n\nUser's weak areas: ${weakAreas.map((wa) => wa.topic).join(', ')}`
        : '';

    // Get conversation context
    const conversationHistory = await this.getConversationContext(
      input.sessionId,
    );

    // Try RAG if vector db is available
    let ragContext = '';
    if (this.vectorDb) {
      try {
        const results = await this.vectorDb.search(input.query, 3, {
          category: 'dsa',
        });

        if (results.length > 0) {
          ragContext =
            '\n\nRelevant DSA problems and concepts:\n' +
            results.map((r, i) => `${i + 1}. ${r.document.content}`).join('\n');
        }
      } catch (error) {
        console.warn('RAG search failed:', error);
      }
    }

    const enhancedPrompt = systemPrompt + weakAreaContext + ragContext;

    return await this.generateResponse(
      enhancedPrompt,
      input.query,
      conversationHistory,
      0.7,
    );
  }

  /**
   * Evaluate a submitted code solution
   * FIXED: Improved evaluation that properly recognizes complete implementations
   */
  private async evaluateAnswer(input: BaseAgentInput): Promise<string> {
    const code = this.extractCode(input.query);

    // First, check if there's actual implementation
    const hasImplementationCheck = await this.checkImplementation(code);

    if (!hasImplementationCheck.hasImplementation) {
      return `‚ùå **No Implementation Detected**

The code you submitted appears to be just a function signature or incomplete implementation.

**What I see:**
${hasImplementationCheck.analysis}

**What I need:**
- A complete function implementation with logic
- Actual return statements with computed values
- Loop structures or conditional logic
- Variable assignments and operations

**Example of what to submit:**
\`\`\`javascript
function twoSum(nums, target) {
  const map = new Map();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    map.set(nums[i], i);
  }
  
  return [];
}
\`\`\`

Please submit your complete solution with implementation details.`;
    }

    // Now evaluate the actual implementation
    // FIXED: Better prompt that doesn't incorrectly mark complete code as incomplete
    const evaluationPrompt = `You are evaluating a DSA coding solution. This code HAS BEEN VERIFIED to contain actual implementation logic.

Analyze the code for:

1. **Correctness**: Does it solve the problem correctly? Are there logical errors?
2. **Time Complexity**: Provide Big O analysis
3. **Space Complexity**: Provide Big O analysis  
4. **Code Quality**: Readability, style, variable names
5. **Edge Cases**: What edge cases are handled? What's missing?
6. **Optimizations**: Are there better approaches?

**IMPORTANT**: This is a COMPLETE implementation with logic, loops, and return statements. Do NOT say it's incomplete or just a signature. Evaluate it as a full solution.

**Code submitted:**
\`\`\`javascript
${code}
\`\`\`

**Evaluation Format:**

## Score: [X/100]

Provide a score between 60-100 for working solutions. Only give below 60 if there are serious correctness issues.

## ‚úÖ Strengths
- [List what was done well - acknowledge the implementation is complete]

## ‚ö†Ô∏è Weaknesses (if any)
- [List issues and problems, or write "None - solution is correct" if it's a good solution]

## üí° Suggestions for Improvement
- [Specific actionable suggestions, or "Great work!" if minimal improvements needed]

## üîç Complexity Analysis
- **Time Complexity**: O(?)
- **Space Complexity**: O(?)
- **Explanation**: [Brief explanation]

## üéØ Edge Cases
- **Handled**: [Cases that are handled]
- **Missing**: [Cases that should be handled, or "All major edge cases covered"]

## üöÄ Optimization Opportunities
- [Better approaches or optimizations, or "Solution is optimal" if applicable]

Be constructive, encouraging, and educational. Recognize good implementations appropriately.`;

    const conversationHistory = await this.getConversationContext(
      input.sessionId,
    );

    const evaluation = await this.generateResponse(
      evaluationPrompt,
      input.query,
      conversationHistory,
      0.3, // Lower temperature for consistent evaluation
    );

    // Extract weak areas from evaluation and record them
    await this.recordWeakAreasFromEvaluation(input.userId, evaluation);

    return evaluation;
  }

  /**
   * Check if code has actual implementation
   * IMPROVED: Better heuristics for detecting complete code
   */
  private async checkImplementation(code: string): Promise<{
    hasImplementation: boolean;
    analysis: string;
  }> {
    // Enhanced heuristic checks
    const hasReturnWithValue = /return\s+[^;}\n]+/.test(code);
    const hasLoop = /for\s*\(|while\s*\(/.test(code);
    const hasConditional = /if\s*\(/.test(code);
    const hasAssignment = /[let|const|var]\s+\w+\s*=/.test(code);
    const hasMethodCall = /\.\w+\(/.test(code); // e.g., Math.max(), arr.push()

    const linesWithLogic = code.split('\n').filter((line) => {
      const trimmed = line.trim();
      return (
        trimmed &&
        !trimmed.startsWith('//') &&
        !trimmed.startsWith('/*') &&
        trimmed !== '{' &&
        trimmed !== '}' &&
        trimmed !== 'function' &&
        !trimmed.match(/^function\s+\w+\s*\(/)
      );
    }).length;

    // More lenient detection: needs SOME implementation indicators
    const hasImplementation =
      linesWithLogic > 2 &&
      (hasReturnWithValue || hasLoop || hasConditional || hasMethodCall) &&
      hasAssignment;

    let analysis: string;
    if (hasImplementation) {
      analysis =
        'Found implementation logic including loops, conditionals, assignments, and/or method calls.';
    } else {
      const missing: string[] = []; // FIXED: Explicitly type as string[]
      if (!hasReturnWithValue) missing.push('return statements with values');
      if (!hasLoop && !hasConditional)
        missing.push('control flow (loops/conditionals)');
      if (!hasAssignment) missing.push('variable assignments');
      if (linesWithLogic <= 2) missing.push('sufficient lines of logic');

      analysis = `Only found function signature without meaningful implementation. Missing: ${missing.join(', ')}.`;
    }

    return {
      hasImplementation,
      analysis,
    };
  }

  /**
   * Extract and record weak areas from evaluation
   */
  private async recordWeakAreasFromEvaluation(
    userId: string,
    evaluation: string,
  ): Promise<void> {
    // Simple heuristic: look for common weak area indicators
    const weakAreaPatterns = [
      { pattern: /time complexity/i, topic: 'Time Complexity Analysis' },
      { pattern: /space complexity/i, topic: 'Space Complexity Analysis' },
      { pattern: /edge case/i, topic: 'Edge Case Handling' },
      { pattern: /optimization/i, topic: 'Code Optimization' },
      { pattern: /\bbug\b/i, topic: 'Debugging' },
      { pattern: /incorrect/i, topic: 'Correctness' },
      { pattern: /logic error/i, topic: 'Algorithm Logic' },
    ];

    for (const { pattern, topic } of weakAreaPatterns) {
      if (pattern.test(evaluation)) {
        await this.memoryManager.recordWeakArea(userId, topic, 'DSA', [
          'Review the evaluation feedback',
          'Practice similar problems',
        ]);
      }
    }
  }

  /**
   * Generate a DSA question based on difficulty
   */
  async generateQuestion(
    difficulty: 'easy' | 'medium' | 'hard',
    topic?: string,
  ): Promise<DSAQuestion> {
    const prompt = `Generate a ${difficulty} level DSA coding problem${topic ? ` on ${topic}` : ''}.

Include:
1. Clear problem statement
2. Input/output examples
3. Constraints
4. Expected complexity`;

    const schema = {
      question: 'string',
      difficulty: 'string',
      topics: 'array of strings',
      hints: 'array of strings',
    };

    return await this.generateStructuredResponse<DSAQuestion>(
      'You are a DSA question generator.',
      prompt,
      schema,
    );
  }

  /**
   * Calculate custom confidence for DSA responses
   */
  protected calculateConfidence(
    response: string,
    input: BaseAgentInput,
  ): number {
    let confidence = super.calculateConfidence(response, input);

    // Boost confidence if response includes complexity analysis
    if (response.includes('O(') || response.includes('time complexity')) {
      confidence = Math.min(confidence + 0.1, 1.0);
    }

    // Boost confidence if code is present
    if (response.includes('```') || response.match(/def\s+\w+/)) {
      confidence = Math.min(confidence + 0.1, 1.0);
    }

    return confidence;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\agents\resume-agent.ts
==============================

/**
 * Resume Review Agent
 * Analyzes and provides feedback on resumes
 */

import { BaseAgent } from './base-agent';
import { AgentType, BaseAgentInput, BaseAgentOutput } from '../types';
import { ILLMProvider } from '../services/llm/base-provider';
import { MemoryManager } from '../memory/memory-manager';

interface ResumeAnalysis {
  overallScore: number;
  strengths: string[];
  weaknesses: string[];
  suggestions: string[];
  formattingIssues: string[];
  contentGaps: string[];
  atsCompatibility: number;
}

export class ResumeReviewAgent extends BaseAgent {
  type = AgentType.RESUME_REVIEW;
  name = 'Resume Review Agent';
  description = 'Analyzes and provides feedback on resumes';

  protected getKeywords(): string[] {
    return [
      'resume',
      'cv',
      'curriculum vitae',
      'review my resume',
      'check my cv',
      'improve resume',
      'ats',
      'applicant tracking',
    ];
  }

  protected buildSystemPrompt(): string {
    return `You are an expert resume reviewer with extensive experience in tech recruiting and ATS (Applicant Tracking Systems).

Your responsibilities:
1. Analyze resume content, structure, and formatting
2. Evaluate ATS compatibility
3. Identify missing or weak sections
4. Suggest improvements for impact and clarity
5. Tailor feedback to target role and companies

Evaluation criteria:
- Content: Impact statements, quantifiable achievements, relevant skills
- Structure: Clear sections, logical flow, appropriate length
- Formatting: Clean layout, consistent style, ATS-friendly
- Keywords: Industry-relevant terms, role-specific skills
- Experience: Progression, relevance, depth

Provide actionable, specific feedback that helps candidates stand out.`;
  }

  async process(input: BaseAgentInput): Promise<BaseAgentOutput> {
    await this.saveToMemory(input.sessionId, 'user', input.query);

    // Extract resume text and target info from context
    const resumeText = input.context?.resumeText as string;
    const targetRole = input.context?.targetRole as string;
    const targetCompanies = input.context?.targetCompanies as string[];

    if (!resumeText) {
      const response = 'Please provide your resume text for review. You can paste it directly or upload a file.';
      await this.saveToMemory(input.sessionId, 'assistant', response);
      
      return {
        response,
        confidence: 1.0,
        suggestedFollowUps: [
          'What should I include in my resume?',
          'How do I make my resume ATS-friendly?',
        ],
      };
    }

    // Perform detailed analysis
    const analysis = await this.analyzeResume(resumeText, targetRole, targetCompanies);

    // Generate human-readable response
    const response = this.formatAnalysis(analysis);

    await this.saveToMemory(input.sessionId, 'assistant', response);

    return {
      response,
      confidence: 0.9,
      metadata: { analysis },
      suggestedFollowUps: [
        'Can you help me rewrite a specific section?',
        'What keywords should I add?',
        'How can I improve my impact statements?',
      ],
    };
  }

  /**
   * Perform comprehensive resume analysis
   */
  private async analyzeResume(
    resumeText: string,
    targetRole?: string,
    targetCompanies?: string[]
  ): Promise<ResumeAnalysis> {
    const targetContext = targetRole
      ? `Target role: ${targetRole}${targetCompanies ? `, Target companies: ${targetCompanies.join(', ')}` : ''}`
      : '';

    const analysisPrompt = `Analyze this resume comprehensively:

${resumeText}

${targetContext}

Provide detailed analysis including:
1. Overall score (0-100)
2. Key strengths (3-5 points)
3. Main weaknesses (3-5 points)
4. Specific improvement suggestions
5. Formatting/structure issues
6. Content gaps (missing sections or details)
7. ATS compatibility score (0-100)

Be specific and actionable.`;

    const schema = {
      overallScore: 'number (0-100)',
      strengths: 'array of strings',
      weaknesses: 'array of strings',
      suggestions: 'array of strings',
      formattingIssues: 'array of strings',
      contentGaps: 'array of strings',
      atsCompatibility: 'number (0-100)',
    };

    return await this.generateStructuredResponse<ResumeAnalysis>(
      this.buildSystemPrompt(),
      analysisPrompt,
      schema,
      0.3
    );
  }

  /**
   * Format analysis into readable response
   */
  private formatAnalysis(analysis: ResumeAnalysis): string {
    let response = `# Resume Analysis\n\n`;
    response += `**Overall Score: ${analysis.overallScore}/100**\n`;
    response += `**ATS Compatibility: ${analysis.atsCompatibility}/100**\n\n`;

    response += `## ‚úÖ Strengths\n`;
    analysis.strengths.forEach((s, i) => {
      response += `${i + 1}. ${s}\n`;
    });

    response += `\n## ‚ö†Ô∏è Areas for Improvement\n`;
    analysis.weaknesses.forEach((w, i) => {
      response += `${i + 1}. ${w}\n`;
    });

    response += `\n## üí° Specific Suggestions\n`;
    analysis.suggestions.forEach((s, i) => {
      response += `${i + 1}. ${s}\n`;
    });

    if (analysis.formattingIssues.length > 0) {
      response += `\n## üìê Formatting Issues\n`;
      analysis.formattingIssues.forEach((f, i) => {
        response += `${i + 1}. ${f}\n`;
      });
    }

    if (analysis.contentGaps.length > 0) {
      response += `\n## üìù Content Gaps\n`;
      analysis.contentGaps.forEach((c, i) => {
        response += `${i + 1}. ${c}\n`;
      });
    }

    return response;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\agents\system-design-agent.ts
==============================

/**
 * System Design Agent
 * Handles system design interview questions with CRAG/Self-RAG verification
 */

import { BaseAgent } from './base-agent';
import {
  AgentType,
  BaseAgentInput,
  BaseAgentOutput,
  CRAGDecision,
  CRAGEvaluation,
  VerificationResult,
} from '../types';
import { ILLMProvider } from '../services/llm/base-provider';
import { MemoryManager } from '../memory/memory-manager';
import { IVectorDatabase } from '../services/vector-db/base-vector-db';

export class SystemDesignAgent extends BaseAgent {
  type = AgentType.SYSTEM_DESIGN;
  name = 'System Design Agent';
  description = 'Conducts system design interviews with verification';

  constructor(
    llmProvider: ILLMProvider,
    memoryManager: MemoryManager,
    private vectorDb?: IVectorDatabase
  ) {
    super(llmProvider, memoryManager);
  }

  protected getKeywords(): string[] {
    return [
      'system design',
      'architecture',
      'scalability',
      'design',
      'distributed',
      'microservice',
      'database',
      'caching',
      'load balancer',
      'api',
      'rest',
      'graphql',
      'kafka',
      'redis',
      'mongodb',
      'postgresql',
      'aws',
      'azure',
      'scaling',
      'high availability',
      'fault tolerance',
      'cap theorem',
      'consistency',
      'partition',
    ];
  }

  protected buildSystemPrompt(): string {
    return `You are an expert system design interviewer with extensive experience in large-scale distributed systems.

Your responsibilities:
1. Guide candidates through system design problems
2. Ask clarifying questions about requirements
3. Evaluate design decisions and trade-offs
4. Verify answers against best practices and real-world examples
5. Identify potential bottlenecks and failure points

When conducting interviews:
- Start with requirements gathering (functional & non-functional)
- Discuss capacity estimation and constraints
- Evaluate component design and data models
- Review API design and protocols
- Analyze scalability, reliability, and performance
- Discuss trade-offs and alternatives

When evaluating designs:
- Check if requirements are met
- Verify scalability approaches
- Assess data consistency strategies
- Review failure handling
- Validate technology choices

Be thorough, ask probing questions, and verify claims against industry standards.`;
  }

  async process(input: BaseAgentInput): Promise<BaseAgentOutput> {
    await this.saveToMemory(input.sessionId, 'user', input.query);

    // Step 1: Generate initial response
    const initialResponse = await this.generateInitialResponse(input);

    // Step 2: If vector DB is available, apply CRAG (Corrective RAG)
    let finalResponse = initialResponse;
    let verificationResult: VerificationResult | null = null;
    let requiresRAG = false;

    if (this.vectorDb) {
      const cragResult = await this.applyCRAG(input.query, initialResponse);
      
      if (cragResult.shouldRequery) {
        // Re-generate with better context
        finalResponse = await this.regenerateWithCorrection(
          input,
          cragResult
        );
        requiresRAG = true;
      }

      // Step 3: Apply Self-RAG for final verification
      verificationResult = await this.applySelfRAG(input.query, finalResponse);
    }

    await this.saveToMemory(input.sessionId, 'assistant', finalResponse);

    // Build metadata with verification info
    const metadata: Record<string, unknown> = {
      type: 'system_design',
      verified: verificationResult?.verified ?? false,
      cragApplied: requiresRAG,
    };

    if (verificationResult && !verificationResult.verified) {
      metadata.verificationWarning = 'Response may contain unverified information';
      metadata.supportingDocs = verificationResult.supportingDocs.length;
      metadata.contradictingDocs = verificationResult.contradictingDocs.length;
    }

    const confidence = this.calculateSystemDesignConfidence(
      finalResponse,
      input,
      verificationResult
    );

    return {
      response: finalResponse,
      confidence,
      metadata,
      suggestedFollowUps: [
        'How would you handle scaling to 1M users?',
        'What are the failure points?',
        'How would you ensure data consistency?',
      ],
      requiresRAG,
    };
  }

  /**
   * Generate initial response
   */
  private async generateInitialResponse(input: BaseAgentInput): Promise<string> {
    const systemPrompt = this.buildSystemPrompt();
    const conversationHistory = await this.getConversationContext(input.sessionId);

    return await this.generateResponse(
      systemPrompt,
      input.query,
      conversationHistory,
      0.7
    );
  }

  /**
   * Apply CRAG (Corrective RAG)
   * Evaluates if retrieved documents support the generated answer
   */
  private async applyCRAG(
    query: string,
    generatedAnswer: string
  ): Promise<CRAGEvaluation> {
    if (!this.vectorDb) {
      return {
        decision: CRAGDecision.AMBIGUOUS,
        confidence: 0.5,
        reasoning: 'No vector database available',
        shouldRequery: false,
      };
    }

    try {
      // Retrieve relevant documents
      const results = await this.vectorDb.search(query, 5, {
        category: 'system_design',
      });

      if (results.length === 0) {
        return {
          decision: CRAGDecision.AMBIGUOUS,
          confidence: 0.5,
          reasoning: 'No relevant documents found',
          shouldRequery: false,
        };
      }

      // Use LLM to evaluate if retrieved docs support the answer
      const evaluationPrompt = `Evaluate if the following generated answer is supported by the retrieved documents.

Generated Answer:
${generatedAnswer}

Retrieved Documents:
${results.map((r, i) => `Document ${i + 1}:\n${r.document.content}`).join('\n\n')}

Determine:
1. Does the answer align with the documents? (CORRECT/INCORRECT/AMBIGUOUS)
2. Confidence level (0-1)
3. Should we re-query for better context? (true/false)
4. If re-querying, what query would be better?

Respond in JSON format.`;

      const schema = {
        decision: 'string (CORRECT, INCORRECT, or AMBIGUOUS)',
        confidence: 'number (0-1)',
        reasoning: 'string',
        shouldRequery: 'boolean',
        alternativeQuery: 'string (optional)',
      };

      const evaluation = await this.generateStructuredResponse<CRAGEvaluation>(
        'You are a fact-checker evaluating system design answers against documentation.',
        evaluationPrompt,
        schema,
        0.3
      );

      return evaluation;
    } catch (error) {
      console.error('CRAG evaluation failed:', error);
      return {
        decision: CRAGDecision.AMBIGUOUS,
        confidence: 0.5,
        reasoning: 'Evaluation failed',
        shouldRequery: false,
      };
    }
  }

  /**
   * Regenerate response with corrected context
   */
  private async regenerateWithCorrection(
    input: BaseAgentInput,
    cragResult: CRAGEvaluation
  ): Promise<string> {
    if (!this.vectorDb) {
      return await this.generateInitialResponse(input);
    }

    // Use alternative query if provided, otherwise use original
    const searchQuery = cragResult.alternativeQuery || input.query;
    
    const results = await this.vectorDb.search(searchQuery, 5, {
      category: 'system_design',
    });

    const ragContext = results.length > 0
      ? '\n\nRelevant system design documentation:\n' +
        results.map((r, i) => `${i + 1}. ${r.document.content}`).join('\n\n')
      : '';

    const enhancedPrompt = this.buildSystemPrompt() + 
      '\n\nIMPORTANT: Base your answer on the following verified documentation:' +
      ragContext;

    const conversationHistory = await this.getConversationContext(input.sessionId);

    return await this.generateResponse(
      enhancedPrompt,
      input.query,
      conversationHistory,
      0.6 // Slightly lower temperature for accuracy
    );
  }

  /**
   * Apply Self-RAG for verification
   * Checks if the final answer is factually grounded
   */
  private async applySelfRAG(
    query: string,
    generatedAnswer: string
  ): Promise<VerificationResult> {
    if (!this.vectorDb) {
      return {
        verified: false,
        confidence: 0.5,
        supportingDocs: [],
        contradictingDocs: [],
        needsRefinement: false,
      };
    }

    try {
      // Extract key claims from the answer
      const claims = await this.extractClaims(generatedAnswer);

      const supportingDocs: any[] = [];
      const contradictingDocs: any[] = [];

      // Verify each claim
      for (const claim of claims) {
        const results = await this.vectorDb.search(claim, 3, {
          category: 'system_design',
        });

        for (const result of results) {
          const supports = await this.checkIfSupports(
            claim,
            result.document.content
          );

          if (supports) {
            supportingDocs.push(result.document);
          } else if (result.relevance > 0.7) {
            // High relevance but doesn't support - might contradict
            contradictingDocs.push(result.document);
          }
        }
      }

      const verified = supportingDocs.length > contradictingDocs.length;
      const confidence = supportingDocs.length / (supportingDocs.length + contradictingDocs.length + 1);
      const needsRefinement = contradictingDocs.length > 0;

      return {
        verified,
        confidence,
        supportingDocs,
        contradictingDocs,
        needsRefinement,
        refinementSuggestion: needsRefinement
          ? 'Some claims may not be fully supported. Consider reviewing contradicting sources.'
          : undefined,
      };
    } catch (error) {
      console.error('Self-RAG verification failed:', error);
      return {
        verified: false,
        confidence: 0.5,
        supportingDocs: [],
        contradictingDocs: [],
        needsRefinement: false,
      };
    }
  }

  /**
   * Extract key claims from the generated answer
   */
  private async extractClaims(answer: string): Promise<string[]> {
    const prompt = `Extract the key factual claims from this system design answer. 
List only concrete, verifiable statements (not opinions or general advice).

Answer:
${answer}

Return as a JSON array of claim strings.`;

    try {
      const result = await this.generateStructuredResponse<{ claims: string[] }>(
        'You extract factual claims from text.',
        prompt,
        { claims: 'array of strings' },
        0.3
      );

      return result.claims;
    } catch {
      // Fallback: split by sentences
      return answer
        .split(/[.!?]+/)
        .map((s) => s.trim())
        .filter((s) => s.length > 20)
        .slice(0, 5);
    }
  }

  /**
   * Check if a document supports a claim
   */
  private async checkIfSupports(claim: string, document: string): Promise<boolean> {
    const prompt = `Does the following document support this claim?

Claim: ${claim}

Document: ${document}

Answer only 'yes' or 'no'.`;

    try {
      const response = await this.generateResponse(
        'You verify if documents support claims.',
        prompt,
        [],
        0.1
      );

      return response.toLowerCase().includes('yes');
    } catch {
      return false;
    }
  }

  /**
   * Calculate confidence with verification results
   */
  private calculateSystemDesignConfidence(
    response: string,
    input: BaseAgentInput,
    verification: VerificationResult | null
  ): number {
    let confidence = super.calculateConfidence(response, input);

    // Adjust based on verification
    if (verification) {
      if (verification.verified) {
        confidence = Math.min(confidence + 0.2, 1.0);
      } else if (verification.contradictingDocs.length > 0) {
        confidence = Math.max(confidence - 0.2, 0.3);
      }
    }

    // Boost if response includes diagrams or specific numbers
    if (response.includes('```') || /\d+\s*(users|requests|MB|GB)/i.test(response)) {
      confidence = Math.min(confidence + 0.1, 1.0);
    }

    return confidence;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\app.ts
==============================

// src/app.ts - UPDATE to integrate new features
import express, { Application, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import passport from './config/passport'; 
import session from 'express-session';
import { createRoutes } from './routes/api-routes';
import { createAuthRoutes } from './routes/auth.routes';
import { createAnalyticsRoutes } from './routes/analytics.routes';
import { QueryController } from './controllers/query-controller';
import { InterviewController } from './controllers/interview-controller';
import {
  ResumeController,
  ProgressController,
} from './controllers/resume-progress-controllers';
import { AgentRouter } from './router/agent-router';
import { MemoryManager } from './memory/memory-manager';
import { InterviewSessionManager } from './services/interview-session-manager';
import { ILLMProvider } from './services/llm/base-provider';
import { IVectorDatabase } from './services/vector-db/base-vector-db';
import { RouterStrategy } from './types';
import { DSAInterviewAgent } from './agents/dsa-agent';
import { SystemDesignAgent } from './agents/system-design-agent';
import { ResumeReviewAgent } from './agents/resume-agent';
import {
  HRBehavioralAgent,
  LearningSupportAgent,
} from './agents/behavioral-learning-agents';
import { globalRateLimiter } from './middleware/rate-limit.middleware';
import { PrismaMemoryStore } from './memory/prisma-memory-store';
import { createLearningPathRoutes } from './routes/learning-path.routes';
import { createGamificationRoutes } from './routes/gamification.routes';
import { createFileUploadRoutes } from './routes/file-upload.routes';
import { createCompanyRoutes } from './routes/company.routes';
import { createTopicRoutes } from './routes/topic.routes';
import { createAIQuestionGeneratorRoutes } from './routes/ai-question-generator.routes';
import { createAdminUserRoutes } from './routes/admin/admin-user.routes';
import { activityLogger } from './middleware/activity-logger.middleware';
import path from 'path';

export interface AppConfig {
  llmProvider: ILLMProvider;
  vectorDb?: IVectorDatabase;
  routingStrategy?: RouterStrategy;
}

export function createApp(config: AppConfig): Application {
  const app = express();

  // ============================================================================
  // Security Middleware
  // ============================================================================

  app.use(helmet());
  app.use(express.json({ limit: '10mb' }));
  app.use(express.urlencoded({ extended: true, limit: '10mb' }));

  // Session middleware (required for Passport)
  app.use(
    session({
      secret: process.env.SESSION_SECRET || 'your-session-secret',
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
      },
    }),
  );

  // Initialize Passport
  app.use(passport.initialize());
  app.use(passport.session());

  // CORS configuration
  app.use(
    cors({
      origin: process.env.CORS_ORIGIN || '*',
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
      allowedHeaders: ['Content-Type', 'Authorization'],
    }),
  );

  // Global rate limiting
  app.use(globalRateLimiter);

  // Request logging
  app.use((req: Request, res: Response, next: NextFunction) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
    next();
  });

  // ============================================================================
  // Serve uploaded files (for local storage mode)
  // ============================================================================

  if (process.env.USE_LOCAL_STORAGE === 'true') {
    app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));
  }

  const llmProvider = config.llmProvider;

  // ============================================================================
  // Initialize Core Services with Prisma
  // ============================================================================

  const prismaStore = new PrismaMemoryStore();
  const memoryManager = new MemoryManager(prismaStore);
  const agentRouter = new AgentRouter(
    config.llmProvider,
    config.routingStrategy || RouterStrategy.HYBRID,
  );

  // ============================================================================
  // Register Agents
  // ============================================================================

  const dsaAgent = new DSAInterviewAgent(
    config.llmProvider,
    memoryManager,
    config.vectorDb,
  );
  agentRouter.registerAgent(dsaAgent);

  const systemDesignAgent = new SystemDesignAgent(
    config.llmProvider,
    memoryManager,
    config.vectorDb,
  );
  agentRouter.registerAgent(systemDesignAgent);

  const resumeAgent = new ResumeReviewAgent(config.llmProvider, memoryManager);
  agentRouter.registerAgent(resumeAgent);

  const behavioralAgent = new HRBehavioralAgent(
    config.llmProvider,
    memoryManager,
  );
  agentRouter.registerAgent(behavioralAgent);

  const learningAgent = new LearningSupportAgent(
    config.llmProvider,
    memoryManager,
  );
  agentRouter.registerAgent(learningAgent);

  console.log(`Registered ${agentRouter.getAgents().length} agents`);

  // ============================================================================
  // Initialize Controllers
  // ============================================================================

  const queryController = new QueryController(agentRouter, memoryManager);
  const sessionManager = new InterviewSessionManager(
    config.llmProvider,
    memoryManager,
    config.vectorDb,
  );
  // Interview routes (protected) - UPDATED
  const resumeController = new ResumeController(agentRouter, memoryManager);
  const progressController = new ProgressController();

  // ============================================================================
  // Routes
  // ============================================================================

  // Auth routes (public)
  app.use('/api/auth', createAuthRoutes());

  // User routes (protected)
  app.use('/api/user', createUserRoutes());

  // Analytics routes (protected)
  app.use('/api/analytics', createAnalyticsRoutes());

  // Learning Path routes (protected) - NEW
  app.use('/api/learning-path', createLearningPathRoutes());

  // Gamification routes (protected) - NEW
  app.use('/api/gamification', createGamificationRoutes());

  // File Upload routes (protected)
  app.use('/api/files', createFileUploadRoutes());

  // Company routes - NEW
  app.use('/api/companies', createCompanyRoutes());

  // Topic routes - NEW
  app.use('/api/topics', createTopicRoutes());

  app.use('/api/ai-questions', createAIQuestionGeneratorRoutes(llmProvider));
  // Admin routes - NEW
  app.use('/api/admin', createAdminUserRoutes());

  // Interview routes (protected)
  const interviewController = new InterviewController(enhancedSessionManager);
  app.use('/api/interview', createInterviewRoutes(interviewController));

  // Existing API routes
  const apiRoutes = createRoutes(
    queryController,
    interviewController,
    resumeController,
    progressController,
  );
  app.use('/api', apiRoutes);

  // Root route
  app.get('/', (req: Request, res: Response) => {
    res.json({
      name: 'AI Interview Coach API',
      version: '2.0.0',
      status: 'running',
      features: [
        'Authentication & Authorization',
        'User Progress Tracking',
        'Analytics Dashboard',
        'Interview Sessions',
        'Resume Review',
      ],
      endpoints: {
        auth: {
          register: 'POST /api/auth/register',
          login: 'POST /api/auth/login',
          refresh: 'POST /api/auth/refresh',
          logout: 'POST /api/auth/logout',
          verifyEmail: 'GET /api/auth/verify-email',
          forgotPassword: 'POST /api/auth/forgot-password',
          resetPassword: 'POST /api/auth/reset-password',
          me: 'GET /api/auth/me',
        },
        analytics: {
          dashboard: 'GET /api/analytics/dashboard',
          stats: 'GET /api/analytics/stats',
          topicPerformance: 'GET /api/analytics/performance/topics',
          trends: 'GET /api/analytics/performance/trends',
          comparative: 'GET /api/analytics/comparative',
          skillGaps: 'GET /api/analytics/skill-gaps',
        },
        interview: {
          start: 'POST /api/interview/start',
          answer: 'POST /api/interview/answer',
          status: 'GET /api/interview/:sessionId',
        },
      },
    });
  });

  // ============================================================================
  // Error Handling
  // ============================================================================

  app.use((req: Request, res: Response) => {
    res.status(404).json({
      success: false,
      error: {
        code: 'NOT_FOUND',
        message: `Route ${req.method} ${req.path} not found`,
      },
    });
  });

  app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error('Global error handler:', err);

    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'An unexpected error occurred',
        details:
          process.env.NODE_ENV === 'development' ? err.message : undefined,
      },
    });
  });

  // ============================================================================
  // Cleanup on Shutdown
  // ============================================================================

  process.on('SIGTERM', async () => {
    console.log('SIGTERM received, cleaning up...');
    await memoryManager.cleanup(30);
    if (config.vectorDb) {
      await config.vectorDb.close();
    }
    process.exit(0);
  });

  return app;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\cli-driver.ts
==============================

/**
 * Interactive CLI Driver for AI Interview Coach API
 * Provides a terminal UI to test all API endpoints
 */

import readline from 'readline';
import fs from 'fs';
import path from 'path';
import axios, { AxiosError } from 'axios';
import { v4 as uuidv4 } from 'uuid';
// @ts-ignore
import pdfParse from 'pdf-parse';

// Configuration
const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:8080/api';
const RESUME_FOLDER = path.join(__dirname, '..', 'test-data', 'resumes');

// Ensure resume folder exists
if (!fs.existsSync(RESUME_FOLDER)) {
  fs.mkdirSync(RESUME_FOLDER, { recursive: true });
}

// Types
interface SessionState {
  userId: string;
  currentSessionId?: string;
  interviewSessionId?: string;
}

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

// Session state
const state: SessionState = {
  userId: uuidv4(),
};

// Create readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Helper functions
function print(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function printHeader(title: string) {
  console.log('\n' + '='.repeat(60));
  print(title, 'bright');
  console.log('='.repeat(60) + '\n');
}

function printError(error: unknown) {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError;
    print(`\n‚ùå Error: ${axiosError.message}`, 'red');
    if (axiosError.response?.data) {
      print(JSON.stringify(axiosError.response.data, null, 2), 'red');
    }
  } else if (error instanceof Error) {
    print(`\n‚ùå Error: ${error.message}`, 'red');
  } else {
    print(`\n‚ùå Unknown error occurred`, 'red');
  }
}

function printSuccess(message: string, data?: any) {
  print(`\n‚úÖ ${message}`, 'green');
  if (data) {
    print(JSON.stringify(data, null, 2), 'cyan');
  }
}

function question(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    rl.question(`${colors.yellow}${prompt}${colors.reset}`, (answer) => {
      resolve(answer.trim());
    });
  });
}

// API Functions
async function healthCheck() {
  printHeader('Health Check');
  try {
    const response = await axios.get(`${API_BASE_URL}/health`);
    printSuccess('API is healthy!', response.data);
  } catch (error) {
    printError(error);
  }
}

async function processQuery() {
  printHeader('Process Query');

  const query = await question('Enter your query: ');
  if (!query) {
    print('Query cannot be empty', 'red');
    return;
  }

  const useRAG = await question('Use RAG? (y/n, default: n): ');

  try {
    const sessionId = state.currentSessionId || uuidv4();
    state.currentSessionId = sessionId;

    print('\n‚è≥ Processing query...', 'yellow');

    const response = await axios.post(`${API_BASE_URL}/query`, {
      query,
      userId: state.userId,
      sessionId,
      useRAG: useRAG.toLowerCase() === 'y',
    });

    printSuccess('Query processed!');
    print(`\nüìù Response from ${response.data.data.agentType}:`, 'cyan');
    print(response.data.data.response, 'bright');
    print(
      `\nüéØ Confidence: ${(response.data.data.confidence * 100).toFixed(1)}%`,
      'cyan',
    );

    if (response.data.data.suggestedFollowUps?.length > 0) {
      print('\nüí° Suggested follow-ups:', 'magenta');
      response.data.data.suggestedFollowUps.forEach(
        (followUp: string, i: number) => {
          print(`   ${i + 1}. ${followUp}`, 'dim');
        },
      );
    }
  } catch (error) {
    printError(error);
  }
}

async function getConversationHistory() {
  printHeader('Get Conversation History');

  if (!state.currentSessionId) {
    print('No active session. Start a query first.', 'yellow');
    return;
  }

  try {
    const response = await axios.get(
      `${API_BASE_URL}/query/history/${state.currentSessionId}`,
    );

    printSuccess('Conversation history retrieved!');

    const history = response.data.data;
    if (history.length === 0) {
      print('No conversation history yet.', 'yellow');
      return;
    }

    print('\nüìú Conversation History:', 'cyan');
    history.forEach((turn: any, i: number) => {
      const roleColor = turn.role === 'user' ? 'green' : 'blue';
      print(`\n[${i + 1}] ${turn.role.toUpperCase()}:`, roleColor);
      print(turn.content, 'dim');
    });
  } catch (error) {
    printError(error);
  }
}

async function startInterview() {
  printHeader('Start Mock Interview');

  print('Interview Types:', 'cyan');
  print('1. DSA (Data Structures & Algorithms)', 'dim');
  print('2. System Design', 'dim');
  print('3. Behavioral', 'dim');
  print('4. Mixed', 'dim');

  const typeChoice = await question('\nSelect type (1-4): ');
  const typeMap: Record<string, string> = {
    '1': 'dsa',
    '2': 'system_design',
    '3': 'behavioral',
    '4': 'mixed',
  };

  const type = typeMap[typeChoice];
  if (!type) {
    print('Invalid choice', 'red');
    return;
  }

  print('\nDifficulty Levels:', 'cyan');
  print('1. Easy', 'dim');
  print('2. Medium', 'dim');
  print('3. Hard', 'dim');

  const diffChoice = await question('\nSelect difficulty (1-3, default: 2): ');
  const diffMap: Record<string, string> = {
    '1': 'easy',
    '2': 'medium',
    '3': 'hard',
  };
  const difficulty = diffMap[diffChoice] || 'medium';

  const durationInput = await question(
    'Duration in minutes (default: 30, min: 15): ',
  );
  const duration = Math.max(parseInt(durationInput) || 30, 15); // Minimum 15 minutes

  const focusAreasInput = await question(
    'Focus areas (comma-separated, optional): ',
  );
  const focusAreas = focusAreasInput
    ? focusAreasInput
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean)
    : undefined;

  try {
    print('\n‚è≥ Starting interview session...', 'yellow');

    const response = await axios.post(`${API_BASE_URL}/interview/start`, {
      userId: state.userId,
      type,
      difficulty,
      duration,
      focusAreas,
    });

    // Check if we got valid data
    if (!response.data.data.currentQuestion) {
      print('‚ùå Failed to generate questions. Please try again.', 'red');
      return;
    }

    state.interviewSessionId = response.data.data.sessionId;

    printSuccess('Interview session started!');
    print(`\nüìã Session ID: ${state.interviewSessionId}`, 'cyan');
    print(`üìä Total Questions: ${response.data.data.totalQuestions}`, 'cyan');
    print(
      `\n‚ùì Question ${response.data.data.currentQuestionIndex}:`,
      'bright',
    );
    print(response.data.data.currentQuestion.question, 'cyan');

    if (response.data.data.currentQuestion.hints?.length > 0) {
      print(
        `\nüí° Hints available: ${response.data.data.currentQuestion.hints.length}`,
        'dim',
      );
    }
  } catch (error) {
    printError(error);
  }
}

function readMultilineInput(prompt: string): Promise<string> {
  return new Promise((resolve) => {
    console.log(prompt);
    console.log(
      'Paste your code and press Ctrl+D (or Ctrl+Z on Windows) when done:',
    );
    console.log('');

    const stdin = process.stdin;
    const chunks: string[] = [];

    // Set raw mode to capture all input
    stdin.setRawMode(false);
    stdin.resume();
    stdin.setEncoding('utf8');

    const onData = (chunk: string) => {
      chunks.push(chunk);
    };

    const onEnd = () => {
      stdin.removeListener('data', onData);
      stdin.removeListener('end', onEnd);
      stdin.pause();

      const fullInput = chunks.join('').trim();
      resolve(fullInput);
    };

    stdin.on('data', onData);
    stdin.on('end', onEnd);
  });
}


/**
 * FIX for cli-driver.ts - Multi-line Input Handling
 * 
 * The current CLI only reads a single line when you press Enter.
 * This fix allows multi-line code input.
 */

// REPLACE the submitAnswer function in cli-driver.ts with this:

async function submitAnswer() {
  printHeader('Submit Answer');

  if (!state.interviewSessionId) {
    print('No active interview session. Start an interview first.', 'yellow');
    return;
  }

  print('Choose input method:', 'cyan');
  print('1. Read from file (recommended for multi-line code)', 'dim');
  print('2. Paste multi-line code (press Ctrl+D when done)', 'dim');
  print('3. Type single line (for simple answers)', 'dim');

  const method = await question('\nSelect method (1/2/3): ');

  let answer = '';

  if (method === '1') {
    // Read from file
    const fs = require('fs');
    const path = require('path');
    const filename = await question('Enter filename (default: answer.txt): ');
    const filepath = path.join(process.cwd(), filename || 'answer.txt');

    try {
      answer = fs.readFileSync(filepath, 'utf-8').trim();
      print('\n‚úÖ Loaded code from file:', 'green');
      print('‚îÄ'.repeat(60), 'dim');
      print(answer, 'bright');
      print('‚îÄ'.repeat(60), 'dim');
    } catch (error) {
      print(`\n‚ùå Could not read file: ${filepath}`, 'red');
      print('Make sure the file exists and try again.', 'yellow');
      return;
    }
  } else if (method === '2') {
    // Multi-line paste with Ctrl+D
    rl.pause(); // Pause readline

    try {
      answer = await readMultilineInput('üìù Paste your code:');

      print('\n‚úÖ Code received:', 'green');
      print('‚îÄ'.repeat(60), 'dim');
      print(answer, 'bright');
      print('‚îÄ'.repeat(60), 'dim');
    } finally {
      rl.resume(); // Resume readline
    }
  } else {
    // Single line (legacy mode)
    answer = await question('Enter your answer: ');
  }

  if (!answer || answer.trim().length === 0) {
    print('Answer cannot be empty', 'red');
    return;
  }

  const confirm = await question('\nSubmit this answer? (y/n): ');
  if (confirm.toLowerCase() !== 'y') {
    print('Submission cancelled', 'yellow');
    return;
  }

  const timeSpentInput = await question('Time spent (seconds, optional): ');
  const timeSpent = timeSpentInput ? parseInt(timeSpentInput) : undefined;

  try {
    print('\n‚è≥ Evaluating answer...', 'yellow');

    const response = await axios.post(`${API_BASE_URL}/interview/answer`, {
      sessionId: state.interviewSessionId,
      userId: state.userId,
      answer: answer.trim(),
      timeSpent,
    });

    printSuccess('Answer submitted!');
    print(`\nüìä Score: ${response.data.data.score}/100`, 'cyan');
    print(`\nüìù Feedback:`, 'bright');
    print(response.data.data.feedback, 'cyan');

    if (response.data.data.sessionCompleted) {
      print('\nüéâ Interview session completed!', 'green');
      state.interviewSessionId = undefined;
    } else if (response.data.data.nextQuestion) {
      print(`\n‚ùì Next Question:`, 'bright');
      print(response.data.data.nextQuestion.question, 'cyan');

      if (response.data.data.nextQuestion.hints?.length > 0) {
        print(
          `\nüí° Hints available: ${response.data.data.nextQuestion.hints.length}`,
          'dim',
        );
      }
    }
  } catch (error) {
    printError(error);
  }
}


async function requestHint() {
  printHeader('Request Hint');

  if (!state.interviewSessionId) {
    print('No active interview session. Start an interview first.', 'yellow');
    return;
  }

  try {
    const response = await axios.get(
      `${API_BASE_URL}/interview/${state.interviewSessionId}/hint`,
    );

    printSuccess('Hint received!');
    print(`\nüí° ${response.data.data.hint}`, 'cyan');
  } catch (error) {
    printError(error);
  }
}

async function getInterviewStatus() {
  printHeader('Get Interview Status');

  if (!state.interviewSessionId) {
    print('No active interview session. Start an interview first.', 'yellow');
    return;
  }

  try {
    const response = await axios.get(
      `${API_BASE_URL}/interview/${state.interviewSessionId}`,
    );

    printSuccess('Interview status retrieved!');

    const data = response.data.data;
    print(`\nüìã Session ID: ${data.sessionId}`, 'cyan');
    print(`üìä Status: ${data.status}`, 'cyan');
    print(`üìù Type: ${data.type}`, 'cyan');
    print(
      `‚ùì Question: ${data.currentQuestionIndex}/${data.totalQuestions}`,
      'cyan',
    );

    if (data.score !== undefined) {
      print(`üéØ Score: ${data.score.toFixed(1)}/100`, 'cyan');
    }
  } catch (error) {
    printError(error);
  }
}

async function extractPdfText(filePath: string): Promise<string> {
  // Correct way to import CommonJS module in TypeScript
  const pdfParse = (await import('pdf-parse')).default;
  const dataBuffer = fs.readFileSync(filePath);
  const data = await pdfParse(dataBuffer);
  return data.text;
}
async function reviewResume() {
  printHeader('Review Resume');

  // Check for PDF files in resume folder
  const files = fs.readdirSync(RESUME_FOLDER).filter((f) => f.endsWith('.pdf'));

  if (files.length === 0) {
    print(`No resume PDFs found in: ${RESUME_FOLDER}`, 'yellow');
    print('\nüìÅ Please place your resume PDF in this folder:', 'cyan');
    print(`   ${RESUME_FOLDER}`, 'bright');
    print('\nExample: resume.pdf, my_resume.pdf, etc.', 'dim');
    return;
  }

  print('Available resume PDFs:', 'cyan');
  files.forEach((file, i) => {
    print(`${i + 1}. ${file}`, 'dim');
  });

  const fileChoice = await question(
    '\nSelect file (number) or press Enter for first: ',
  );
  const selectedIndex = fileChoice ? parseInt(fileChoice) - 1 : 0;

  if (selectedIndex < 0 || selectedIndex >= files.length) {
    print('Invalid choice', 'red');
    return;
  }

  const selectedFile = files[selectedIndex];
  const filePath = path.join(RESUME_FOLDER, selectedFile);

  print(`\nüìÑ Selected: ${selectedFile}`, 'cyan');

  const targetRole = await question('Target role (optional): ');
  const targetCompaniesInput = await question(
    'Target companies (comma-separated, optional): ',
  );
  const targetCompanies = targetCompaniesInput
    ? targetCompaniesInput
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean)
    : undefined;

  try {
    print('\n‚è≥ Extracting text from PDF...', 'yellow');
    const resumeText = await extractPdfText(filePath);

    print('‚è≥ Analyzing resume...', 'yellow');

    const response = await axios.post(`${API_BASE_URL}/resume/review`, {
      userId: state.userId,
      resumeText,
      targetRole: targetRole || undefined,
      targetCompanies,
    });

    printSuccess('Resume reviewed!');
    print(`\n${response.data.data.review}`, 'cyan');

    if (response.data.data.analysis) {
      print(
        `\nüéØ Overall Score: ${response.data.data.analysis.overallScore}/100`,
        'green',
      );
      print(
        `üìä ATS Compatibility: ${response.data.data.analysis.atsCompatibility}/100`,
        'green',
      );
    }
  } catch (error) {
    printError(error);
  }
}

async function getUserProgress() {
  printHeader('Get User Progress');

  try {
    const response = await axios.get(
      `${API_BASE_URL}/progress/${state.userId}`,
    );

    printSuccess('Progress retrieved!');

    const data = response.data.data;

    print(`\nüìä Learning Progress:`, 'bright');
    print(
      `   Total Interviews: ${data.learningProgress.totalInterviews}`,
      'cyan',
    );
    print(`   Current Level: ${data.learningProgress.currentLevel}`, 'cyan');
    print(`   Goal Level: ${data.learningProgress.goalLevel}`, 'cyan');

    if (data.weakAreas.length > 0) {
      print(`\n‚ö†Ô∏è  Weak Areas:`, 'yellow');
      data.weakAreas.forEach((area: any) => {
        print(
          `   ‚Ä¢ ${area.topic} (${area.category}) - Failed ${area.failureCount} times`,
          'dim',
        );
      });
    } else {
      print('\n‚úÖ No weak areas identified yet!', 'green');
    }

    if (data.recentTopics.length > 0) {
      print(`\nüìö Recent Topics:`, 'cyan');
      data.recentTopics.forEach((topic: string) => {
        print(`   ‚Ä¢ ${topic}`, 'dim');
      });
    }
  } catch (error) {
    printError(error);
  }
}

async function getWeakAreas() {
  printHeader('Get Weak Areas');

  const limitInput = await question(
    'Number of weak areas to show (default: 5): ',
  );
  const limit = parseInt(limitInput) || 5;

  try {
    const response = await axios.get(
      `${API_BASE_URL}/progress/${state.userId}/weak-areas?limit=${limit}`,
    );

    printSuccess('Weak areas retrieved!');

    const weakAreas = response.data.data.weakAreas;

    if (weakAreas.length === 0) {
      print('\n‚úÖ No weak areas identified yet!', 'green');
      return;
    }

    print(`\n‚ö†Ô∏è  Top ${weakAreas.length} Weak Areas:`, 'yellow');
    weakAreas.forEach((area: any, i: number) => {
      print(`\n${i + 1}. ${area.topic} (${area.category})`, 'bright');
      print(`   Failed ${area.failureCount} times`, 'dim');
      print(
        `   Last encountered: ${new Date(area.lastEncountered).toLocaleDateString()}`,
        'dim',
      );

      if (area.improvementSuggestions.length > 0) {
        print('   Suggestions:', 'cyan');
        area.improvementSuggestions
          .slice(0, 3)
          .forEach((suggestion: string) => {
            print(`   ‚Ä¢ ${suggestion}`, 'dim');
          });
      }
    });
  } catch (error) {
    printError(error);
  }
}

async function pauseInterview() {
  if (!state.interviewSessionId) {
    print('No active interview session.', 'yellow');
    return;
  }

  try {
    await axios.post(
      `${API_BASE_URL}/interview/${state.interviewSessionId}/pause`,
    );
    printSuccess('Interview paused!');
  } catch (error) {
    printError(error);
  }
}

async function resumeInterview() {
  if (!state.interviewSessionId) {
    print('No active interview session.', 'yellow');
    return;
  }

  try {
    await axios.post(
      `${API_BASE_URL}/interview/${state.interviewSessionId}/resume`,
    );
    printSuccess('Interview resumed!');
  } catch (error) {
    printError(error);
  }
}

// Main menu
async function showMenu() {
  printHeader('AI Interview Coach - API Testing CLI');

  print('Current User ID: ' + state.userId, 'dim');
  if (state.currentSessionId) {
    print('Query Session ID: ' + state.currentSessionId, 'dim');
  }
  if (state.interviewSessionId) {
    print('Interview Session ID: ' + state.interviewSessionId, 'dim');
  }

  console.log('\n' + '‚îÄ'.repeat(60));
  print('1.  Health Check', 'cyan');
  print('2.  Process Query (General)', 'cyan');
  print('3.  Get Conversation History', 'cyan');
  console.log('‚îÄ'.repeat(60));
  print('4.  Start Mock Interview', 'green');
  print('5.  Submit Answer', 'green');
  print('6.  Request Hint', 'green');
  print('7.  Get Interview Status', 'green');
  print('8.  Pause Interview', 'green');
  print('9.  Resume Interview', 'green');
  console.log('‚îÄ'.repeat(60));
  print('10. Review Resume (PDF)', 'magenta');
  console.log('‚îÄ'.repeat(60));
  print('11. Get User Progress', 'yellow');
  print('12. Get Weak Areas', 'yellow');
  console.log('‚îÄ'.repeat(60));
  print('13. Change User ID', 'blue');
  print('14. Reset Session', 'blue');
  console.log('‚îÄ'.repeat(60));
  print('0.  Exit', 'red');
  console.log('‚îÄ'.repeat(60) + '\n');
}

async function changeUserId() {
  const newUserId = await question(
    'Enter new User ID (or press Enter for random): ',
  );
  state.userId = newUserId || uuidv4();
  state.currentSessionId = undefined;
  state.interviewSessionId = undefined;
  printSuccess(`User ID changed to: ${state.userId}`);
}

async function resetSession() {
  state.currentSessionId = undefined;
  state.interviewSessionId = undefined;
  printSuccess('Session reset!');
}

// Main loop
async function main() {
  print('\nüéØ Welcome to AI Interview Coach API CLI', 'bright');
  print(`üìÅ Resume folder: ${RESUME_FOLDER}`, 'dim');
  print(`üåê API Base URL: ${API_BASE_URL}\n`, 'dim');

  while (true) {
    await showMenu();
    const choice = await question('Select an option: ');

    switch (choice) {
      case '1':
        await healthCheck();
        break;
      case '2':
        await processQuery();
        break;
      case '3':
        await getConversationHistory();
        break;
      case '4':
        await startInterview();
        break;
      case '5':
        await submitAnswer();
        break;
      case '6':
        await requestHint();
        break;
      case '7':
        await getInterviewStatus();
        break;
      case '8':
        await pauseInterview();
        break;
      case '9':
        await resumeInterview();
        break;
      case '10':
        await reviewResume();
        break;
      case '11':
        await getUserProgress();
        break;
      case '12':
        await getWeakAreas();
        break;
      case '13':
        await changeUserId();
        break;
      case '14':
        await resetSession();
        break;
      case '0':
        print('\nüëã Goodbye!', 'green');
        rl.close();
        process.exit(0);
      default:
        print('\n‚ùå Invalid option. Please try again.', 'red');
    }

    await question('\nPress Enter to continue...');
  }
}

// Start the CLI
main().catch((error) => {
  printError(error);
  rl.close();
  process.exit(1);
});


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\config\database.ts
==============================

// src/config/database.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

export default prisma;

==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\config\passport.ts
==============================

// src/config/passport.ts
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';
import { UserRepository } from '../repositories/user.repository';
import { OAuthProfile } from '../types/auth.types';

const userRepo = new UserRepository();

// Google OAuth Strategy
passport.use(
  new GoogleStrategy(
    {
      clientID: process.env.GOOGLE_CLIENT_ID || '',
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
      callbackURL: `${process.env.BACKEND_URL}/api/auth/google/callback`,
      scope: ['profile', 'email'],
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        const oauthProfile: OAuthProfile = {
          provider: 'google',
          id: profile.id,
          email: profile.emails?.[0]?.value || '',
          name: profile.displayName,
          picture: profile.photos?.[0]?.value,
        };

        done(null, oauthProfile);
      } catch (error) {
        done(error as Error, undefined);
      }
    },
  ),
);

// GitHub OAuth Strategy
passport.use(
  new GitHubStrategy(
    {
      clientID: process.env.GITHUB_CLIENT_ID || '',
      clientSecret: process.env.GITHUB_CLIENT_SECRET || '',
      callbackURL: `${process.env.BACKEND_URL}/api/auth/github/callback`,
      scope: ['user:email'],
    },
    async (
      accessToken: string,
      refreshToken: string,
      profile: any,
      done: any,
    ) => {
      try {
        const oauthProfile: OAuthProfile = {
          provider: 'github',
          id: profile.id,
          email: profile.emails?.[0]?.value || '',
          name: profile.displayName || profile.username,
          picture: profile.photos?.[0]?.value,
        };

        done(null, oauthProfile);
      } catch (error) {
        done(error as Error, undefined);
      }
    },
  ),
);

// Serialize user for session (not used with JWT, but required by Passport)
passport.serializeUser((user: any, done) => {
  done(null, user);
});

passport.deserializeUser((user: any, done) => {
  done(null, user);
});

export default passport;


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\config\redis.ts
==============================

// src/config/redis.ts
import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD,
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

redis.on('connect', () => {
  console.log('‚úÖ Redis connected');
});

redis.on('error', (err) => {
  console.error('‚ùå Redis error:', err);
});

export default redis;


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\admin\admin-user.controller.ts
==============================

// src/controllers/admin/admin-user.controller.ts
import { Request, Response } from 'express';
import { AdminUserService } from '../../services/admin/admin-user.service';
import { APIResponse } from '../../types';
import { UserRole } from '@prisma/client';

export class AdminUserController {
  private adminUserService: AdminUserService;

  constructor() {
    this.adminUserService = new AdminUserService();
  }

  /**
   * Get users with filters and pagination
   */
  async getUsers(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const {
        search,
        role,
        status,
        emailVerified,
        dateFrom,
        dateTo,
        isSuspicious,
        page,
        limit,
        sortBy,
        sortOrder,
      } = req.query;

      const result = await this.adminUserService.getUsers({
        search: search as string,
        role: role as UserRole,
        status: status as any,
        emailVerified: emailVerified === 'true',
        dateFrom: dateFrom ? new Date(dateFrom as string) : undefined,
        dateTo: dateTo ? new Date(dateTo as string) : undefined,
        isSuspicious: isSuspicious === 'true',
        page: page ? parseInt(page as string) : undefined,
        limit: limit ? parseInt(limit as string) : undefined,
        sortBy: sortBy as any,
        sortOrder: sortOrder as any,
      });

      res.json({
        success: true,
        data: result,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get users error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch users',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user details
   */
  async getUserDetails(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;

      const details = await this.adminUserService.getUserDetails(userId);

      res.json({
        success: true,
        data: details,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get user details error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message:
            error instanceof Error
              ? error.message
              : 'Failed to fetch user details',
        },
      } as APIResponse);
    }
  }

  /**
   * Ban user
   */
  async banUser(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { reason, isPermanent } = req.body;

      if (!reason) {
        res.status(400).json({
          success: false,
          error: { code: 'INVALID_REQUEST', message: 'Reason is required' },
        } as APIResponse);
        return;
      }

      const user = await this.adminUserService.banUser(
        userId,
        req.user.userId,
        reason,
        isPermanent !== false,
      );

      res.json({
        success: true,
        data: { user, message: 'User banned successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Ban user error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'BAN_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to ban user',
        },
      } as APIResponse);
    }
  }

  /**
   * Unban user
   */
  async unbanUser(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;

      const user = await this.adminUserService.unbanUser(
        userId,
        req.user.userId,
      );

      res.json({
        success: true,
        data: { user, message: 'User unbanned successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Unban user error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UNBAN_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to unban user',
        },
      } as APIResponse);
    }
  }

  /**
   * Suspend user
   */
  async suspendUser(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { reason, durationHours } = req.body;

      if (!reason || !durationHours) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Reason and duration are required',
          },
        } as APIResponse);
        return;
      }

      const user = await this.adminUserService.suspendUser(
        userId,
        req.user.userId,
        reason,
        parseInt(durationHours),
      );

      res.json({
        success: true,
        data: { user, message: 'User suspended successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Suspend user error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'SUSPEND_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to suspend user',
        },
      } as APIResponse);
    }
  }

  /**
   * Unsuspend user
   */
  async unsuspendUser(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;

      const user = await this.adminUserService.unsuspendUser(
        userId,
        req.user.userId,
      );

      res.json({
        success: true,
        data: { user, message: 'User unsuspended successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Unsuspend user error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UNSUSPEND_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to unsuspend user',
        },
      } as APIResponse);
    }
  }

  /**
   * Change user role
   */
  async changeUserRole(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { role } = req.body;

      if (!role || !['FREE', 'PREMIUM', 'ADMIN'].includes(role)) {
        res.status(400).json({
          success: false,
          error: { code: 'INVALID_ROLE', message: 'Invalid role' },
        } as APIResponse);
        return;
      }

      const user = await this.adminUserService.changeUserRole(
        userId,
        req.user.userId,
        role as UserRole,
      );

      res.json({
        success: true,
        data: { user, message: 'User role changed successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Change role error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'ROLE_CHANGE_ERROR',
          message:
            error instanceof Error
              ? error.message
              : 'Failed to change user role',
        },
      } as APIResponse);
    }
  }

  /**
   * Reset user password
   */
  async resetUserPassword(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { newPassword } = req.body;

      if (!newPassword || newPassword.length < 8) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_PASSWORD',
            message: 'Password must be at least 8 characters',
          },
        } as APIResponse);
        return;
      }

      await this.adminUserService.resetUserPassword(
        userId,
        req.user.userId,
        newPassword,
      );

      res.json({
        success: true,
        data: {
          message:
            'Password reset successfully. User must login with new password.',
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Reset password error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PASSWORD_RESET_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to reset password',
        },
      } as APIResponse);
    }
  }

  /**
   * Delete user
   */
  async deleteUser(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { reason } = req.body;

      if (!reason) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Deletion reason is required',
          },
        } as APIResponse);
        return;
      }

      const result = await this.adminUserService.deleteUser(
        userId,
        req.user.userId,
        reason,
      );

      res.json({
        success: true,
        data: result,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Delete user error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DELETE_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to delete user',
        },
      } as APIResponse);
    }
  }

  /**
   * Update admin notes
   */
  async updateAdminNotes(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { notes } = req.body;

      const user = await this.adminUserService.updateAdminNotes(
        userId,
        req.user.userId,
        notes || '',
      );

      res.json({
        success: true,
        data: { user, message: 'Admin notes updated successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update notes error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update notes',
        },
      } as APIResponse);
    }
  }

  /**
   * Mark user as suspicious
   */
  async markSuspicious(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { isSuspicious } = req.body;

      const user = await this.adminUserService.markSuspicious(
        userId,
        req.user.userId,
        isSuspicious === true,
      );

      res.json({
        success: true,
        data: { user },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Mark suspicious error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update user status',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user activity
   */
  async getUserActivity(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;
      const { limit } = req.query;

      const activities = await this.adminUserService.getUserActivity(
        userId,
        limit ? parseInt(limit as string) : undefined,
      );

      res.json({
        success: true,
        data: { activities },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get activity error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch user activity',
        },
      } as APIResponse);
    }
  }

  /**
   * Export user data
   */
  async exportUserData(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userId } = req.params;

      const data = await this.adminUserService.exportUserData(userId);

      res.json({
        success: true,
        data: { userData: data },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Export data error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'EXPORT_ERROR',
          message: 'Failed to export user data',
        },
      } as APIResponse);
    }
  }

  /**
   * Bulk ban users
   */
  async bulkBanUsers(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { userIds, reason } = req.body;

      if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'userIds array is required',
          },
        } as APIResponse);
        return;
      }

      if (!reason) {
        res.status(400).json({
          success: false,
          error: { code: 'INVALID_REQUEST', message: 'Reason is required' },
        } as APIResponse);
        return;
      }

      const result = await this.adminUserService.bulkBanUsers(
        userIds,
        req.user.userId,
        reason,
      );

      res.json({
        success: true,
        data: result,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Bulk ban error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'BULK_BAN_ERROR',
          message: 'Failed to perform bulk ban',
        },
      } as APIResponse);
    }
  }

  /**
   * Get admin actions (audit log)
   */
  async getAdminActions(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { adminId, targetUserId, action, dateFrom, dateTo, page, limit } =
        req.query;

      const result = await this.adminUserService.getAdminActions({
        adminId: adminId as string,
        targetUserId: targetUserId as string,
        action: action as any,
        dateFrom: dateFrom ? new Date(dateFrom as string) : undefined,
        dateTo: dateTo ? new Date(dateTo as string) : undefined,
        page: page ? parseInt(page as string) : undefined,
        limit: limit ? parseInt(limit as string) : undefined,
      });

      res.json({
        success: true,
        data: result,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get admin actions error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch admin actions',
        },
      } as APIResponse);
    }
  }

  /**
   * Get dashboard statistics
   */
  async getDashboardStats(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const stats = await this.adminUserService.getDashboardStats();

      res.json({
        success: true,
        data: stats,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get dashboard stats error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATS_ERROR',
          message: 'Failed to fetch dashboard statistics',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\ai-question-generator.controller.ts
==============================

// src/controllers/ai-question-generator.controller.ts
import { Request, Response } from 'express';
import { AIQuestionGeneratorService } from '../services/ai-question-generator.service';
import { ILLMProvider } from '../services/llm/base-provider';
import { APIResponse } from '../types';
import { GenerationType, Difficulty, QuestionCategory } from '@prisma/client';

export class AIQuestionGeneratorController {
  private generatorService: AIQuestionGeneratorService;

  constructor(llmProvider: ILLMProvider) {
    this.generatorService = new AIQuestionGeneratorService(llmProvider);
  }

  /**
   * Generate questions
   */
  async generateQuestions(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const {
        generationType,
        baseQuestionId,
        topicId,
        companyId,
        difficulty,
        category,
        count,
        parameters,
      } = req.body;

      if (!generationType) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'generationType is required',
          },
        } as APIResponse);
        return;
      }

      const questionIds = await this.generatorService.generateQuestions(
        req.user.userId,
        {
          generationType: generationType as GenerationType,
          baseQuestionId,
          topicId,
          companyId,
          difficulty: difficulty as Difficulty,
          category: category as QuestionCategory,
          count: count || 1,
          parameters,
        },
      );

      // Fetch generated questions
      const questions = await Promise.all(
        questionIds.map((id) => this.generatorService.getGeneratedQuestion(id)),
      );

      res.json({
        success: true,
        data: {
          count: questions.length,
          questions,
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Generate questions error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'GENERATION_ERROR',
          message:
            error instanceof Error
              ? error.message
              : 'Failed to generate questions',
        },
      } as APIResponse);
    }
  }

  /**
   * Generate similar questions (batch)
   */
  async generateSimilar(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { questionId } = req.params;
      const { count } = req.body;

      const questionIds = await this.generatorService.generateBatch(
        req.user.userId,
        questionId,
        count || 5,
      );

      const questions = await Promise.all(
        questionIds.map((id) => this.generatorService.getGeneratedQuestion(id)),
      );

      res.json({
        success: true,
        data: { questions },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Generate similar error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'GENERATION_ERROR',
          message: 'Failed to generate similar questions',
        },
      } as APIResponse);
    }
  }

  /**
   * Get generated question
   */
  async getQuestion(req: Request, res: Response): Promise<void> {
    try {
      const { questionId } = req.params;

      const question =
        await this.generatorService.getGeneratedQuestion(questionId);

      if (!question) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Question not found' },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: { question },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get question error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch question',
        },
      } as APIResponse);
    }
  }

  /**
   * Get questions pending review (admin only)
   */
  async getPendingReview(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const limit = parseInt(req.query.limit as string) || 10;

      const questions = await this.generatorService.getPendingReview(limit);

      res.json({
        success: true,
        data: { questions },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get pending review error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch pending questions',
        },
      } as APIResponse);
    }
  }

  /**
   * Approve generated question (admin only)
   */
  async approveQuestion(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const { questionId } = req.params;

      const question = await this.generatorService.approveQuestion(
        questionId,
        req.user.userId,
      );

      res.json({
        success: true,
        data: { question },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Approve question error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'APPROVE_ERROR',
          message: 'Failed to approve question',
        },
      } as APIResponse);
    }
  }

  /**
   * Record question usage
   */
  async recordUsage(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { questionId } = req.params;
      const { sessionId, wasSuccessful, timeSpent, userRating, userFeedback } =
        req.body;

      await this.generatorService.recordUsage(questionId, req.user.userId, {
        sessionId,
        wasSuccessful,
        timeSpent,
        userRating,
        userFeedback,
      });

      res.json({
        success: true,
        data: { message: 'Usage recorded successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Record usage error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RECORD_ERROR',
          message: 'Failed to record usage',
        },
      } as APIResponse);
    }
  }

  /**
   * Get generation statistics (admin only)
   */
  async getStatistics(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user || req.user.role !== 'ADMIN') {
        res.status(403).json({
          success: false,
          error: { code: 'FORBIDDEN', message: 'Admin access required' },
        } as APIResponse);
        return;
      }

      const stats = await this.generatorService.getGenerationStats();

      res.json({
        success: true,
        data: stats,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get statistics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATS_ERROR',
          message: 'Failed to fetch statistics',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\analytics.controller.ts
==============================

// src/controllers/analytics.controller.ts
import { Request, Response } from 'express';
import { AnalyticsRepository } from '../repositories/analytics.repository';
import { APIResponse } from '../types';

export class AnalyticsController {
  private analyticsRepo: AnalyticsRepository;

  constructor() {
    this.analyticsRepo = new AnalyticsRepository();
  }

  async getDashboard(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const userId = req.user.userId;

      // Fetch all dashboard data in parallel
      const [
        stats,
        topicPerformance,
        trends,
        weakAreas,
        userProgress,
        comparative,
      ] = await Promise.all([
        this.analyticsRepo.getInterviewStats(userId),
        this.analyticsRepo.getTopicPerformance(userId),
        this.analyticsRepo.getPerformanceTrends(userId, 30),
        this.analyticsRepo.getWeakAreas(userId, 5),
        this.analyticsRepo.getUserProgress(userId),
        this.analyticsRepo.getComparativeAnalytics(userId),
      ]);

      res.json({
        success: true,
        data: {
          statistics: stats,
          topicPerformance,
          performanceTrends: trends,
          weakAreas,
          userProgress,
          comparative,
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Dashboard fetch error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DASHBOARD_ERROR',
          message: 'Failed to fetch dashboard data',
        },
      } as APIResponse);
    }
  }

  async getInterviewStats(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const stats = await this.analyticsRepo.getInterviewStats(req.user.userId);

      res.json({
        success: true,
        data: stats,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Interview stats error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATS_ERROR',
          message: 'Failed to fetch interview statistics',
        },
      } as APIResponse);
    }
  }

  async getTopicPerformance(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const performance = await this.analyticsRepo.getTopicPerformance(
        req.user.userId,
      );

      res.json({
        success: true,
        data: { topics: performance },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Topic performance error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PERFORMANCE_ERROR',
          message: 'Failed to fetch topic performance',
        },
      } as APIResponse);
    }
  }

  async getPerformanceTrends(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const days = parseInt(req.query.days as string) || 30;
      const trends = await this.analyticsRepo.getPerformanceTrends(
        req.user.userId,
        days,
      );

      res.json({
        success: true,
        data: { trends },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Performance trends error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'TRENDS_ERROR',
          message: 'Failed to fetch performance trends',
        },
      } as APIResponse);
    }
  }

  async getComparativeAnalytics(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const comparative = await this.analyticsRepo.getComparativeAnalytics(
        req.user.userId,
      );

      res.json({
        success: true,
        data: comparative,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Comparative analytics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'COMPARATIVE_ERROR',
          message: 'Failed to fetch comparative analytics',
        },
      } as APIResponse);
    }
  }

  async getSkillGaps(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const userId = req.user.userId;

      const [weakAreas, topicPerformance, userProgress] = await Promise.all([
        this.analyticsRepo.getWeakAreas(userId, 10),
        this.analyticsRepo.getTopicPerformance(userId),
        this.analyticsRepo.getUserProgress(userId),
      ]);

      // Identify skill gaps based on performance
      const skillGaps = topicPerformance
        .filter((topic) => topic.averageScore < 60 || topic.successRate < 50)
        .map((topic) => ({
          skill: topic.topic,
          category: topic.category,
          currentLevel: this.determineLevel(topic.averageScore),
          targetLevel: 'ADVANCED',
          gap: 100 - topic.averageScore,
          priority: this.calculatePriority(topic),
        }))
        .sort((a, b) => b.priority - a.priority);

      res.json({
        success: true,
        data: {
          skillGaps,
          weakAreas,
          currentLevel: userProgress?.currentLevel || 'BEGINNER',
          goalLevel: userProgress?.goalLevel || 'ADVANCED',
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Skill gaps error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'SKILL_GAPS_ERROR',
          message: 'Failed to identify skill gaps',
        },
      } as APIResponse);
    }
  }

  private determineLevel(score: number): string {
    if (score >= 85) return 'EXPERT';
    if (score >= 70) return 'ADVANCED';
    if (score >= 50) return 'INTERMEDIATE';
    return 'BEGINNER';
  }

  private calculatePriority(topic: any): number {
    // Higher priority for topics with low scores and high question count
    const scoreFactor = (100 - topic.averageScore) / 100;
    const volumeFactor = Math.min(topic.totalQuestions / 20, 1);
    const successFactor = (100 - topic.successRate) / 100;

    return (scoreFactor * 0.5 + volumeFactor * 0.2 + successFactor * 0.3) * 100;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\auth.controller.ts
==============================

// src/controllers/auth.controller.ts - ADD OAuth methods
import { Request, Response } from 'express';
import { AuthService } from '../services/auth/auth.service';
import { OAuthProfile } from '../types/auth.types';
import { APIResponse } from '../types';

export class AuthController {
  private authService: AuthService;

  constructor() {
    this.authService = new AuthService();
  }

  // ... existing methods ...

  /**
   * Handle OAuth callback (Google/GitHub)
   */
  async oauthCallback(req: Request, res: Response): Promise<void> {
    try {
      const profile = req.user as OAuthProfile;

      if (!profile) {
        res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);
        return;
      }

      const ipAddress = req.ip || req.socket.remoteAddress || 'unknown';
      const userAgent = req.headers['user-agent'] || 'unknown';

      const result = await this.authService.loginWithOAuth(
        profile,
        ipAddress,
        userAgent,
      );

      // Redirect to frontend with tokens
      const redirectUrl = new URL(`${process.env.FRONTEND_URL}/auth/callback`);
      redirectUrl.searchParams.set('accessToken', result.tokens.accessToken);
      redirectUrl.searchParams.set('refreshToken', result.tokens.refreshToken);
      redirectUrl.searchParams.set('isNewUser', result.isNewUser.toString());

      res.redirect(redirectUrl.toString());
    } catch (error) {
      console.error('OAuth callback error:', error);
      res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_failed`);
    }
  }

  /**
   * Link OAuth account to existing user
   */
  async linkOAuthAccount(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { provider, code } = req.body;

      if (!provider || !code) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Provider and code are required',
          },
        } as APIResponse);
        return;
      }

      // Handle OAuth linking logic here
      // This would verify the code and link the account

      res.json({
        success: true,
        data: { message: 'OAuth account linked successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Link OAuth error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'LINK_ERROR',
          message: 'Failed to link OAuth account',
        },
      } as APIResponse);
    }
  }

  /**
   * Unlink OAuth account
   */
  async unlinkOAuthAccount(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const userRepo = new (
        await import('../repositories/user.repository')
      ).UserRepository();
      const user = await userRepo.findById(req.user.userId);

      if (!user) {
        res.status(404).json({
          success: false,
          error: { code: 'USER_NOT_FOUND', message: 'User not found' },
        } as APIResponse);
        return;
      }

      // Don't allow unlinking if it's the only login method
      if (!user.passwordHash && user.oauthProvider) {
        res.status(400).json({
          success: false,
          error: {
            code: 'CANNOT_UNLINK',
            message: 'Cannot unlink OAuth - set a password first',
          },
        } as APIResponse);
        return;
      }

      await userRepo.update(user.id, {
        oauthProvider: null,
        oauthId: null,
      });

      res.json({
        success: true,
        data: { message: 'OAuth account unlinked successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Unlink OAuth error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UNLINK_ERROR',
          message: 'Failed to unlink OAuth account',
        },
      } as APIResponse);
    }
  }

  /**
   * Set password for OAuth-only users
   */
  async setPassword(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { newPassword } = req.body;

      if (!newPassword) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'New password is required',
          },
        } as APIResponse);
        return;
      }

      const PasswordUtil = (await import('../utils/password.util'))
        .PasswordUtil;

      // Validate password
      const validation = PasswordUtil.validate(newPassword);
      if (!validation.valid) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_PASSWORD',
            message: validation.errors.join(', '),
          },
        } as APIResponse);
        return;
      }

      const passwordHash = await PasswordUtil.hash(newPassword);
      const userRepo = new (
        await import('../repositories/user.repository')
      ).UserRepository();

      await userRepo.update(req.user.userId, { passwordHash });

      res.json({
        success: true,
        data: { message: 'Password set successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Set password error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'SET_PASSWORD_ERROR',
          message: 'Failed to set password',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\company.controller.ts
==============================

// src/controllers/company.controller.ts
import { Request, Response } from 'express';
import { CompanyService } from '../services/company.service';
import { APIResponse } from '../types';
import { CompanyDifficulty, Difficulty } from '@prisma/client';

export class CompanyController {
  private companyService: CompanyService;

  constructor() {
    this.companyService = new CompanyService();
  }

  /**
   * Get all companies
   */
  async getAllCompanies(req: Request, res: Response): Promise<void> {
    try {
      const { industry, size, difficulty, isPremium } = req.query;

      const companies = await this.companyService.getAllCompanies({
        industry: industry as string,
        size: size as string,
        difficulty: difficulty as CompanyDifficulty,
        isPremium: isPremium === 'true',
      });

      res.json({
        success: true,
        data: { companies },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get companies error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch companies',
        },
      } as APIResponse);
    }
  }

  /**
   * Get company details
   */
  async getCompany(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;

      const company = await this.companyService.getCompanyBySlug(slug);

      if (!company) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Company not found',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: { company },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get company error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch company',
        },
      } as APIResponse);
    }
  }

  /**
   * Get company questions
   */
  async getCompanyQuestions(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;
      const { difficulty, category, round, limit } = req.query;

      const company = await this.companyService.getCompanyBySlug(slug);
      if (!company) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Company not found' },
        } as APIResponse);
        return;
      }

      const questions = await this.companyService.getCompanyQuestions(
        company.id,
        {
          difficulty: difficulty as Difficulty,
          category: category as string,
          round: round as string,
          limit: limit ? parseInt(limit as string) : undefined,
        },
      );

      res.json({
        success: true,
        data: { questions },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get company questions error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch company questions',
        },
      } as APIResponse);
    }
  }

  /**
   * Get company statistics
   */
  async getCompanyStatistics(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;

      const company = await this.companyService.getCompanyBySlug(slug);
      if (!company) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Company not found' },
        } as APIResponse);
        return;
      }

      const statistics = await this.companyService.getCompanyStatistics(
        company.id,
      );

      res.json({
        success: true,
        data: statistics,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get company statistics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATS_ERROR',
          message: 'Failed to fetch company statistics',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user's company progress
   */
  async getUserCompanyProgress(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { slug } = req.params;

      const company = await this.companyService.getCompanyBySlug(slug);
      if (!company) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Company not found' },
        } as APIResponse);
        return;
      }

      const progress = await this.companyService.getUserCompanyProgress(
        req.user.userId,
        company.id,
      );

      res.json({
        success: true,
        data: { progress },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get user company progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PROGRESS_ERROR',
          message: 'Failed to fetch progress',
        },
      } as APIResponse);
    }
  }

  /**
   * Start company-specific practice
   */
  async startCompanyPractice(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { slug } = req.params;
      const { questionCount, difficulty, duration } = req.body;

      const company = await this.companyService.getCompanyBySlug(slug);
      if (!company) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Company not found' },
        } as APIResponse);
        return;
      }

      const session = await this.companyService.startCompanyPractice(
        req.user.userId,
        company.id,
        {
          questionCount: questionCount || 10,
          difficulty: difficulty as Difficulty,
          duration,
        },
      );

      res.json({
        success: true,
        data: { session },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Start company practice error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'START_ERROR',
          message: 'Failed to start practice session',
        },
      } as APIResponse);
    }
  }

  /**
   * Add interview experience
   */
  async addInterviewExperience(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { slug } = req.params;
      const {
        position,
        experienceLevel,
        rounds,
        outcome,
        difficulty,
        preparation,
        tips,
        isAnonymous,
      } = req.body;

      const company = await this.companyService.getCompanyBySlug(slug);
      if (!company) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Company not found' },
        } as APIResponse);
        return;
      }

      const experience = await this.companyService.addInterviewExperience(
        company.id,
        req.user.userId,
        {
          position,
          experienceLevel,
          rounds,
          outcome,
          difficulty: difficulty as CompanyDifficulty,
          preparation,
          tips,
          isAnonymous,
        },
      );

      res.json({
        success: true,
        data: { experience },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Add interview experience error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'ADD_ERROR',
          message: 'Failed to add interview experience',
        },
      } as APIResponse);
    }
  }

  /**
   * Get recommended companies
   */
  async getRecommendedCompanies(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const companies = await this.companyService.getRecommendedCompanies(
        req.user.userId,
      );

      res.json({
        success: true,
        data: { companies },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get recommended companies error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RECOMMENDATION_ERROR',
          message: 'Failed to get recommendations',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\file-upload.controller.ts
==============================

// src/controllers/file-upload.controller.ts
import { Request, Response } from 'express';
import { FileUploadService } from '../services/file-upload.service';
import { APIResponse } from '../types';
import { FileCategory } from '@prisma/client';

export class FileUploadController {
  private fileUploadService: FileUploadService;

  constructor() {
    this.fileUploadService = new FileUploadService();
  }

  /**
   * Upload file
   */
  async uploadFile(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      if (!req.file) {
        res.status(400).json({
          success: false,
          error: { code: 'NO_FILE', message: 'No file uploaded' },
        } as APIResponse);
        return;
      }

      const { category } = req.body;
      if (!category || !Object.values(FileCategory).includes(category)) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_CATEGORY',
            message: 'Invalid file category',
          },
        } as APIResponse);
        return;
      }

      const result = await this.fileUploadService.uploadFile(
        req.file as any,
        req.user.userId,
        category as FileCategory,
      );

      res.json({
        success: true,
        data: result,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('File upload error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPLOAD_ERROR',
          message:
            error instanceof Error ? error.message : 'File upload failed',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user files
   */
  async getUserFiles(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const category = req.query.category as FileCategory | undefined;

      const files = await this.fileUploadService.getUserFiles(
        req.user.userId,
        category,
      );

      res.json({
        success: true,
        data: { files },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get files error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch files',
        },
      } as APIResponse);
    }
  }

  /**
   * Delete file
   */
  async deleteFile(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { fileId } = req.params;

      await this.fileUploadService.deleteFile(fileId, req.user.userId);

      res.json({
        success: true,
        data: { message: 'File deleted successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Delete file error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DELETE_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to delete file',
        },
      } as APIResponse);
    }
  }

  /**
   * Get signed URL
   */
  async getSignedUrl(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { fileId } = req.params;

      const url = await this.fileUploadService.getSignedUrl(
        fileId,
        req.user.userId,
      );

      res.json({
        success: true,
        data: { url },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get signed URL error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'URL_ERROR',
          message: 'Failed to generate signed URL',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\gamification.controller.ts
==============================

// src/controllers/gamification.controller.ts
import { Request, Response } from 'express';
import { GamificationService } from '../services/gamification.service';
import { APIResponse } from '../types';

export class GamificationController {
  private gamificationService: GamificationService;

  constructor() {
    this.gamificationService = new GamificationService();
  }

  /**
   * Get user achievements
   */
  async getAchievements(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const achievements = await this.gamificationService.getUserAchievements(
        req.user.userId,
      );

      res.json({
        success: true,
        data: { achievements },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get achievements error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch achievements',
        },
      } as APIResponse);
    }
  }

  /**
   * Get leaderboard
   */
  async getLeaderboard(req: Request, res: Response): Promise<void> {
    try {
      const limit = parseInt(req.query.limit as string) || 10;
      const leaderboard = await this.gamificationService.getLeaderboard(limit);

      res.json({
        success: true,
        data: { leaderboard },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get leaderboard error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch leaderboard',
        },
      } as APIResponse);
    }
  }

  /**
   * Update daily goal
   */
  async updateDailyGoal(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { minutesStudied, questionsAnswered } = req.body;

      const goal = await this.gamificationService.updateDailyGoal(
        req.user.userId,
        minutesStudied || 0,
        questionsAnswered || 0,
      );

      // Check for new achievements
      const newAchievements = await this.gamificationService.checkAchievements(
        req.user.userId,
      );

      res.json({
        success: true,
        data: {
          dailyGoal: goal,
          newAchievements,
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update daily goal error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update daily goal',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\interview-controller.ts
==============================

/**
 * Interview Controller
 * Handles mock interview session endpoints
 */

import { Request, Response } from 'express';
import { InterviewSessionManager } from '../services/interview-session-manager';
import { APIResponse, StartInterviewRequest, AnswerRequest } from '../types';
import { getStringParam } from '../utils/helpers';
import { TimerService } from '../services/timer.service';
import { InterviewReplayService } from '../services/interview-replay.service';
import { QuestionRatingService } from '../services/question-rating.service';

export class InterviewController {
  private sessionManager: EnhancedInterviewSessionManager;
  private timerService: TimerService;
  private replayService: InterviewReplayService;
  private ratingService: QuestionRatingService;

  constructor(sessionManager: EnhancedInterviewSessionManager) {
    this.sessionManager = sessionManager;
    this.timerService = new TimerService();
    this.replayService = new InterviewReplayService();
    this.ratingService = new QuestionRatingService();
  }

  /**
   * Start a new interview session
   */
  /**
   * Start a new interview session
   */
  async startInterview(req: Request, res: Response): Promise<void> {
    try {
      const requestData = req.body as StartInterviewRequest;

      // Validate request
      if (!requestData.userId || !requestData.type) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'userId and type are required',
          },
        } as APIResponse);
        return;
      }

      const session = await this.sessionManager.startSession(
        requestData.userId,
        requestData.type,
        requestData.difficulty || 'medium',
        requestData.duration,
        requestData.focusAreas,
      );

      // Get first question
      const firstQuestion = this.sessionManager.getCurrentQuestion(session.id);

      // Add validation for empty questions
      if (!firstQuestion) {
        res.status(500).json({
          success: false,
          error: {
            code: 'GENERATION_ERROR',
            message:
              'Failed to generate interview questions. Please try again.',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: {
          sessionId: session.id,
          type: session.type,
          status: session.status,
          totalQuestions: session.questions.length,
          currentQuestion: firstQuestion,
          currentQuestionIndex: session.currentQuestionIndex + 1,
        },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Start interview error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'START_ERROR',
          message: 'Failed to start interview session',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Submit answer to current question
   */
  async submitAnswer(req: Request, res: Response): Promise<void> {
    try {
      const requestData = req.body as AnswerRequest;

      console.log('Request data:', requestData?.answer);

      // Validate request
      if (
        !requestData.sessionId ||
        !requestData.userId ||
        !requestData.answer
      ) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'sessionId, userId, and answer are required',
          },
        } as APIResponse);
        return;
      }

      const result = await this.sessionManager.submitAnswer(
        requestData.sessionId,
        requestData.answer,
        requestData.timeSpent,
      );

      res.json({
        success: true,
        data: {
          feedback: result.feedback,
          score: result.score,
          nextQuestion: result.nextQuestion,
          sessionCompleted: result.sessionCompleted,
        },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Submit answer error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'SUBMIT_ERROR',
          message: 'Failed to submit answer',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Request a hint for current question
   */
  async requestHint(req: Request, res: Response): Promise<void> {
    try {
      const sessionId = getStringParam(req.params.sessionId);

      if (!sessionId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'sessionId is required',
          },
        } as APIResponse);
        return;
      }

      const hint = this.sessionManager.requestHint(sessionId);

      if (!hint) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NO_HINTS',
            message: 'No more hints available',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: { hint },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Request hint error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'HINT_ERROR',
          message: 'Failed to get hint',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Get interview session status
   */
  async getSessionStatus(req: Request, res: Response): Promise<void> {
    try {
      const sessionId = getStringParam(req.params.sessionId);

      if (!sessionId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'sessionId is required',
          },
        } as APIResponse);
        return;
      }

      const session = this.sessionManager.getSession(sessionId);

      if (!session) {
        res.status(404).json({
          success: false,
          error: {
            code: 'SESSION_NOT_FOUND',
            message: 'Interview session not found',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: {
          sessionId: session.id,
          status: session.status,
          type: session.type,
          currentQuestionIndex: session.currentQuestionIndex + 1,
          totalQuestions: session.questions.length,
          score: session.score,
          startTime: session.startTime,
          endTime: session.endTime,
        },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Get session status error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATUS_ERROR',
          message: 'Failed to get session status',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Pause interview session
   */
  async pauseSession(req: Request, res: Response): Promise<void> {
    try {
      const sessionId = getStringParam(req.params.sessionId);

      if (!sessionId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'sessionId is required',
          },
        } as APIResponse);
        return;
      }

      this.sessionManager.pauseSession(sessionId);

      res.json({
        success: true,
        data: { message: 'Session paused successfully' },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Pause session error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PAUSE_ERROR',
          message: 'Failed to pause session',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Resume interview session
   */
  async resumeSession(req: Request, res: Response): Promise<void> {
    try {
      const sessionId = getStringParam(req.params.sessionId);

      if (!sessionId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'sessionId is required',
          },
        } as APIResponse);
        return;
      }

      this.sessionManager.resumeSession(sessionId);

      res.json({
        success: true,
        data: { message: 'Session resumed successfully' },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Resume session error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RESUME_ERROR',
          message: 'Failed to resume session',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Get timer status
   */
  async getTimerStatus(req: Request, res: Response): Promise<void> {
    try {
      const { sessionId } = req.params;

      const timeRemaining = await this.timerService.getTimeRemaining(sessionId);
      const isExpired = await this.timerService.isTimeExpired(sessionId);

      res.json({
        success: true,
        data: {
          timeRemaining,
          isExpired,
          formattedTime: this.formatTime(timeRemaining),
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get timer status error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'TIMER_ERROR',
          message: 'Failed to get timer status',
        },
      } as APIResponse);
    }
  }

  /**
   * Pause interview timer
   */
  async pauseTimer(req: Request, res: Response): Promise<void> {
    try {
      const { sessionId } = req.params;

      await this.timerService.pauseTimer(sessionId);

      res.json({
        success: true,
        data: { message: 'Timer paused successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Pause timer error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PAUSE_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to pause timer',
        },
      } as APIResponse);
    }
  }

  /**
   * Resume interview timer
   */
  async resumeTimer(req: Request, res: Response): Promise<void> {
    try {
      const { sessionId } = req.params;

      await this.timerService.resumeTimer(sessionId);

      res.json({
        success: true,
        data: { message: 'Timer resumed successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Resume timer error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RESUME_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to resume timer',
        },
      } as APIResponse);
    }
  }

  /**
   * Get interview replay
   */
  async getReplay(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { sessionId } = req.params;

      const replay = await this.replayService.startReplay(
        sessionId,
        req.user.userId,
      );

      res.json({
        success: true,
        data: replay,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get replay error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'REPLAY_ERROR',
          message:
            error instanceof Error ? error.message : 'Failed to get replay',
        },
      } as APIResponse);
    }
  }

  /**
   * Update replay progress
   */
  async updateReplayProgress(req: Request, res: Response): Promise<void> {
    try {
      const { replayId } = req.params;
      const { currentStep } = req.body;

      await this.replayService.updateReplayProgress(replayId, currentStep);

      res.json({
        success: true,
        data: { message: 'Replay progress updated' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update replay progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update replay progress',
        },
      } as APIResponse);
    }
  }

  /**
   * Get replay history
   */
  async getReplayHistory(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const history = await this.replayService.getReplayHistory(
        req.user.userId,
      );

      res.json({
        success: true,
        data: { history },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get replay history error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'HISTORY_ERROR',
          message: 'Failed to get replay history',
        },
      } as APIResponse);
    }
  }

  /**
   * Compare interview attempts
   */
  async compareAttempts(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { sessionId1, sessionId2 } = req.query;

      if (!sessionId1 || !sessionId2) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Both sessionId1 and sessionId2 are required',
          },
        } as APIResponse);
        return;
      }

      const comparison = await this.replayService.compareAttempts(
        sessionId1 as string,
        sessionId2 as string,
        req.user.userId,
      );

      res.json({
        success: true,
        data: comparison,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Compare attempts error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'COMPARE_ERROR',
          message: 'Failed to compare attempts',
        },
      } as APIResponse);
    }
  }

  /**
   * Rate question difficulty
   */
  async rateQuestion(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { questionId } = req.params;
      const { rating, comment } = req.body;

      if (!rating || rating < 1 || rating > 5) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_RATING',
            message: 'Rating must be between 1 and 5',
          },
        } as APIResponse);
        return;
      }

      const result = await this.ratingService.rateQuestion(
        questionId,
        req.user.userId,
        rating,
        comment,
      );

      res.json({
        success: true,
        data: { rating: result },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Rate question error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RATING_ERROR',
          message: 'Failed to rate question',
        },
      } as APIResponse);
    }
  }

  /**
   * Get question ratings
   */
  async getQuestionRatings(req: Request, res: Response): Promise<void> {
    try {
      const { questionId } = req.params;

      const ratings = await this.ratingService.getQuestionRatings(questionId);

      res.json({
        success: true,
        data: ratings,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get question ratings error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to get question ratings',
        },
      } as APIResponse);
    }
  }

  private formatTime(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\learning-path.controller.ts
==============================

// src/controllers/learning-path.controller.ts
import { Request, Response } from 'express';
import { LearningPathService } from '../services/learning-path.service';
import { RecommendationService } from '../services/recommendation.service';
import { SpacedRepetitionService } from '../services/spaced-repetition.service';
import { APIResponse } from '../types';
import { DeveloperRole, SkillLevel } from '@prisma/client';

export class LearningPathController {
  private learningPathService: LearningPathService;
  private recommendationService: RecommendationService;
  private spacedRepetitionService: SpacedRepetitionService;

  constructor() {
    this.learningPathService = new LearningPathService();
    this.recommendationService = new RecommendationService();
    this.spacedRepetitionService = new SpacedRepetitionService();
  }

  /**
   * Generate learning path
   */
  async generatePath(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { targetRole, currentLevel, targetDate, weeklyHours } = req.body;

      if (!targetRole || !currentLevel) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'targetRole and currentLevel are required',
          },
        } as APIResponse);
        return;
      }

      const learningPath = await this.learningPathService.generateLearningPath({
        userId: req.user.userId,
        targetRole: targetRole as DeveloperRole,
        currentLevel: currentLevel as SkillLevel,
        targetDate: targetDate ? new Date(targetDate) : undefined,
        weeklyHours,
      });

      res.json({
        success: true,
        data: { learningPath },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Generate learning path error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'GENERATION_ERROR',
          message: 'Failed to generate learning path',
        },
      } as APIResponse);
    }
  }

  /**
   * Get learning path
   */
  async getPath(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const learningPath = await this.learningPathService.getLearningPath(
        req.user.userId,
      );

      if (!learningPath) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'No learning path found. Generate one first.',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: { learningPath },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get learning path error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch learning path',
        },
      } as APIResponse);
    }
  }

  /**
   * Complete topic
   */
  async completeTopic(req: Request, res: Response): Promise<void> {
    try {
      const { topicId } = req.params;

      const topic = await this.learningPathService.completeTopic(topicId);

      res.json({
        success: true,
        data: { topic },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Complete topic error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to complete topic',
        },
      } as APIResponse);
    }
  }

  /**
   * Update topic progress
   */
  async updateTopicProgress(req: Request, res: Response): Promise<void> {
    try {
      const { topicId } = req.params;
      const { questionsSolved, averageScore } = req.body;

      const topic = await this.learningPathService.updateTopicProgress(
        topicId,
        questionsSolved,
        averageScore,
      );

      res.json({
        success: true,
        data: { topic },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update topic progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update topic progress',
        },
      } as APIResponse);
    }
  }

  /**
   * Get recommendations
   */
  async getRecommendations(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const recommendations =
        await this.recommendationService.getRecommendations(req.user.userId);

      res.json({
        success: true,
        data: { recommendations },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get recommendations error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch recommendations',
        },
      } as APIResponse);
    }
  }

  /**
   * Generate fresh recommendations
   */
  async generateRecommendations(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const recommendations =
        await this.recommendationService.generateRecommendations(
          req.user.userId,
        );

      res.json({
        success: true,
        data: { recommendations },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Generate recommendations error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'GENERATION_ERROR',
          message: 'Failed to generate recommendations',
        },
      } as APIResponse);
    }
  }

  /**
   * Complete recommendation
   */
  async completeRecommendation(req: Request, res: Response): Promise<void> {
    try {
      const { recommendationId } = req.params;

      const recommendation =
        await this.recommendationService.completeRecommendation(
          recommendationId,
        );

      res.json({
        success: true,
        data: { recommendation },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Complete recommendation error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to complete recommendation',
        },
      } as APIResponse);
    }
  }

  /**
   * Get spaced repetition reviews
   */
  async getDueReviews(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const limit = parseInt(req.query.limit as string) || 10;
      const reviews = await this.spacedRepetitionService.getDueReviews(
        req.user.userId,
        limit,
      );

      const stats = await this.spacedRepetitionService.getStats(
        req.user.userId,
      );
      const schedule = await this.spacedRepetitionService.getReviewSchedule(
        req.user.userId,
      );

      res.json({
        success: true,
        data: {
          reviews,
          stats,
          schedule,
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get due reviews error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch reviews',
        },
      } as APIResponse);
    }
  }

  /**
   * Record review
   */
  async recordReview(req: Request, res: Response): Promise<void> {
    try {
      const { itemId } = req.params;
      const { quality } = req.body;

      if (quality === undefined || quality < 0 || quality > 5) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Quality must be between 0 and 5',
          },
        } as APIResponse);
        return;
      }

      const item = await this.spacedRepetitionService.recordReview(
        itemId,
        quality,
      );

      res.json({
        success: true,
        data: { item },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Record review error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to record review',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\progress.controller.ts
==============================

// src/controllers/progress.controller.ts - UPDATE with new methods
import { Request, Response } from 'express';
import { AnalyticsRepository } from '../repositories/analytics.repository';
import { APIResponse } from '../types';
import { parseIntQuery } from '../utils/helpers';

export class ProgressController {
  private analyticsRepo: AnalyticsRepository;

  constructor() {
    this.analyticsRepo = new AnalyticsRepository();
  }

  async getProgress(req: Request, res: Response): Promise<void> {
    try {
      // Use authenticated user ID if available, otherwise fall back to param
      const userId = req.user?.userId || req.params.userId;

      if (!userId) {
        res.status(400).json({
          success: false,
          error: { code: 'INVALID_REQUEST', message: 'User ID is required' },
        } as APIResponse);
        return;
      }

      const [weakAreas, userProgress, stats] = await Promise.all([
        this.analyticsRepo.getWeakAreas(userId, 10),
        this.analyticsRepo.getUserProgress(userId),
        this.analyticsRepo.getInterviewStats(userId),
      ]);

      res.json({
        success: true,
        data: {
          weakAreas,
          learningProgress: userProgress,
          statistics: stats,
        },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PROGRESS_ERROR',
          message: 'Failed to fetch user progress',
        },
      } as APIResponse);
    }
  }

  async getWeakAreas(req: Request, res: Response): Promise<void> {
    try {
      const userId = req.user?.userId || req.params.userId;
      const limit = parseIntQuery(req.query.limit, 5);

      if (!userId) {
        res.status(400).json({
          success: false,
          error: { code: 'INVALID_REQUEST', message: 'User ID is required' },
        } as APIResponse);
        return;
      }

      const weakAreas = await this.analyticsRepo.getWeakAreas(
        userId,
        limit || 5,
      );

      res.json({
        success: true,
        data: { weakAreas },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get weak areas error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'WEAK_AREAS_ERROR',
          message: 'Failed to fetch weak areas',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\query-controller.ts
==============================

/**
 * Query Controller
 * Handles general query processing through the agent system
 */

import { Request, Response } from 'express';
import { getStringParam } from '../utils/helpers';
import { AgentRouter } from '../router/agent-router';
import { MemoryManager } from '../memory/memory-manager';
import { APIResponse, QueryRequest, QueryResponse } from '../types';
import { v4 as uuidv4 } from 'uuid';

export class QueryController {
  constructor(
    private router: AgentRouter,
    private memoryManager: MemoryManager,
  ) {}

  /**
   * Process a user query
   */
  async processQuery(req: Request, res: Response): Promise<void> {
    try {
      const requestData = req.body as QueryRequest;

      // Validate request
      if (!requestData.query || !requestData.userId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Query and userId are required',
          },
        } as APIResponse);
        return;
      }

      // Generate session ID if not provided
      const sessionId = requestData.sessionId || uuidv4();

      // Create session in memory
      await this.memoryManager.createSession(requestData.userId, sessionId);

      // Route query to appropriate agent
      const { agent, decision } = await this.router.routeAndGetAgent({
        query: requestData.query,
        userId: requestData.userId,
        sessionId,
        context: requestData.context,
      });

      console.log(
        `Routing decision: ${decision.agentType} (confidence: ${decision.confidence})`,
      );

      // Process with the selected agent
      const result = await agent.process({
        query: requestData.query,
        userId: requestData.userId,
        sessionId,
        context: requestData.context,
      });

      const response: QueryResponse = {
        response: result.response,
        agentType: agent.type,
        confidence: result.confidence,
        suggestedFollowUps: result.suggestedFollowUps,
        retrievedContext: requestData.useRAG ? [] : undefined, // Would be populated by RAG
      };

      res.json({
        success: true,
        data: response,
        metadata: {
          timestamp: new Date(),
          requestId: uuidv4(),
        },
      } as APIResponse<QueryResponse>);
    } catch (error) {
      console.error('Query processing error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PROCESSING_ERROR',
          message: 'Failed to process query',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Get conversation history for a session
   */
  async getHistory(req: Request, res: Response): Promise<void> {
    try {
      // Fix: Handle string | string[] type from req.params
      const sessionIdParam = req.params.sessionId;
      const sessionId = getStringParam(req.params.sessionId);

      if (!sessionId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Session ID is required',
          },
        } as APIResponse);
        return;
      }

      const history = await this.memoryManager.getConversationContext(
        sessionId,
        100, // Get full history
      );

      res.json({
        success: true,
        data: history,
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Get history error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch conversation history',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\resume-progress-controllers.ts
==============================

/**
 * Resume Controller
 * Handles resume review requests
 */

import { Request, Response } from 'express';
import { AgentRouter } from '../router/agent-router';
import { MemoryManager } from '../memory/memory-manager';
import { APIResponse, ResumeReviewRequest, AgentType } from '../types';
import { v4 as uuidv4 } from 'uuid';
import { getStringParam, parseIntQuery } from '../utils/helpers';

export class ResumeController {
  constructor(
    private router: AgentRouter,
    private memoryManager: MemoryManager,
  ) {}

  /**
   * Review a resume
   */
  async reviewResume(req: Request, res: Response): Promise<void> {
    try {
      const requestData = req.body as ResumeReviewRequest;

      // Validate request
      if (!requestData.userId || !requestData.resumeText) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'userId and resumeText are required',
          },
        } as APIResponse);
        return;
      }

      const sessionId = uuidv4();
      await this.memoryManager.createSession(requestData.userId, sessionId);

      // Get resume review agent
      const agent = this.router.getAgent(AgentType.RESUME_REVIEW);
      if (!agent) {
        throw new Error('Resume review agent not available');
      }

      // Process resume review
      const result = await agent.process({
        query: 'Please review my resume',
        userId: requestData.userId,
        sessionId,
        context: {
          resumeText: requestData.resumeText,
          targetRole: requestData.targetRole,
          targetCompanies: requestData.targetCompanies,
        },
      });

      res.json({
        success: true,
        data: {
          review: result.response,
          analysis: result.metadata?.analysis,
          confidence: result.confidence,
        },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Resume review error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'REVIEW_ERROR',
          message: 'Failed to review resume',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }
}

/**
 * Progress Controller
 * Handles user progress and learning tracking
 */
export class ProgressController {
  constructor(private memoryManager: MemoryManager) {}

  /**
   * Get user progress summary
   */
  async getProgress(req: Request, res: Response): Promise<void> {
    try {
      const userId = getStringParam(req.params.userId);

      if (!userId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'userId is required',
          },
        } as APIResponse);
        return;
      }

      const summary = await this.memoryManager.getUserSummary(userId);

      res.json({
        success: true,
        data: {
          weakAreas: summary.weakAreas,
          learningProgress: summary.progress,
          recentTopics: summary.recentTopics,
        },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Get progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PROGRESS_ERROR',
          message: 'Failed to fetch user progress',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }

  /**
   * Get weak areas for focused practice
   */
  async getWeakAreas(req: Request, res: Response): Promise<void> {
    try {
      const userId = getStringParam(req.params.userId);
      const limit = parseIntQuery(req.query.limit, 5); // ‚úÖ Use parseIntQuery for query params

      if (!userId) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'userId is required',
          },
        } as APIResponse);
        return;
      }

      const weakAreas = await this.memoryManager.getWeakAreas(
        userId,
        limit || 5,
      );

      res.json({
        success: true,
        data: { weakAreas },
        metadata: {
          timestamp: new Date(),
        },
      } as APIResponse);
    } catch (error) {
      console.error('Get weak areas error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'WEAK_AREAS_ERROR',
          message: 'Failed to fetch weak areas',
          details: error instanceof Error ? error.message : 'Unknown error',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\topic.controller.ts
==============================

// src/controllers/topic.controller.ts
import { Request, Response } from 'express';
import { TopicService } from '../services/topic.service';
import { APIResponse } from '../types';
import { QuestionCategory, Difficulty } from '@prisma/client';

export class TopicController {
  private topicService: TopicService;

  constructor() {
    this.topicService = new TopicService();
  }

  /**
   * Get all topics
   */
  async getAllTopics(req: Request, res: Response): Promise<void> {
    try {
      const { category, difficulty, parentId } = req.query;

      const topics = await this.topicService.getAllTopics({
        category: category as QuestionCategory,
        difficulty: difficulty as Difficulty,
        parentId: parentId as string,
      });

      res.json({
        success: true,
        data: { topics },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get topics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch topics',
        },
      } as APIResponse);
    }
  }

  /**
   * Get topic tree
   */
  async getTopicTree(req: Request, res: Response): Promise<void> {
    try {
      const { category } = req.query;

      const tree = await this.topicService.getTopicTree(
        category as QuestionCategory,
      );

      res.json({
        success: true,
        data: { tree },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get topic tree error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch topic tree',
        },
      } as APIResponse);
    }
  }

  /**
   * Get topic details
   */
  async getTopic(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;

      const topic = await this.topicService.getTopicBySlug(slug);

      if (!topic) {
        res.status(404).json({
          success: false,
          error: {
            code: 'NOT_FOUND',
            message: 'Topic not found',
          },
        } as APIResponse);
        return;
      }

      res.json({
        success: true,
        data: { topic },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get topic error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch topic',
        },
      } as APIResponse);
    }
  }

  /**
   * Get topic questions
   */
  async getTopicQuestions(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;
      const { difficulty, limit, sortBy } = req.query;

      const topic = await this.topicService.getTopicBySlug(slug);
      if (!topic) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Topic not found' },
        } as APIResponse);
        return;
      }

      const questions = await this.topicService.getTopicQuestions(topic.id, {
        difficulty: difficulty as Difficulty,
        limit: limit ? parseInt(limit as string) : undefined,
        sortBy: sortBy as any,
      });

      res.json({
        success: true,
        data: { questions },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get topic questions error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'FETCH_ERROR',
          message: 'Failed to fetch topic questions',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user's topic progress
   */
  async getUserTopicProgress(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { slug } = req.params;

      const topic = await this.topicService.getTopicBySlug(slug);
      if (!topic) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Topic not found' },
        } as APIResponse);
        return;
      }

      const progress = await this.topicService.getUserTopicProgress(
        req.user.userId,
        topic.id,
      );

      res.json({
        success: true,
        data: { progress },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get user topic progress error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PROGRESS_ERROR',
          message: 'Failed to fetch progress',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user's mastery overview
   */
  async getMasteryOverview(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const overview = await this.topicService.getUserMasteryOverview(
        req.user.userId,
      );

      res.json({
        success: true,
        data: overview,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get mastery overview error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'OVERVIEW_ERROR',
          message: 'Failed to fetch mastery overview',
        },
      } as APIResponse);
    }
  }

  /**
   * Start topic-specific practice
   */
  async startTopicPractice(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { slug } = req.params;
      const { questionCount, difficulty, duration } = req.body;

      const topic = await this.topicService.getTopicBySlug(slug);
      if (!topic) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Topic not found' },
        } as APIResponse);
        return;
      }

      const session = await this.topicService.startTopicPractice(
        req.user.userId,
        topic.id,
        {
          questionCount: questionCount || 10,
          difficulty: difficulty as Difficulty,
          duration,
        },
      );

      res.json({
        success: true,
        data: { session },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Start topic practice error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'START_ERROR',
          message: 'Failed to start practice session',
        },
      } as APIResponse);
    }
  }

  /**
   * Get recommended topics
   */
  async getRecommendedTopics(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const topics = await this.topicService.getRecommendedTopics(
        req.user.userId,
      );

      res.json({
        success: true,
        data: { topics },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get recommended topics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'RECOMMENDATION_ERROR',
          message: 'Failed to get recommendations',
        },
      } as APIResponse);
    }
  }

  /**
   * Get topic statistics
   */
  async getTopicStatistics(req: Request, res: Response): Promise<void> {
    try {
      const { slug } = req.params;

      const topic = await this.topicService.getTopicBySlug(slug);
      if (!topic) {
        res.status(404).json({
          success: false,
          error: { code: 'NOT_FOUND', message: 'Topic not found' },
        } as APIResponse);
        return;
      }

      const statistics = await this.topicService.getTopicStatistics(topic.id);

      res.json({
        success: true,
        data: statistics,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get topic statistics error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'STATS_ERROR',
          message: 'Failed to fetch topic statistics',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\controllers\user.controller.ts
==============================

// src/controllers/user.controller.ts
import { Request, Response } from 'express';
import { UserRepository } from '../repositories/user.repository';
import { LoginHistoryRepository } from '../repositories/login-history.repository';
import { RefreshTokenRepository } from '../repositories/refresh-token.repository';
import { AnalyticsRepository } from '../repositories/analytics.repository';
import { APIResponse } from '../types';
import { PasswordUtil } from '../utils/password.util';
import prisma from '../config/database';

export class UserController {
  private userRepo: UserRepository;
  private loginHistoryRepo: LoginHistoryRepository;
  private refreshTokenRepo: RefreshTokenRepository;
  private analyticsRepo: AnalyticsRepository;

  constructor() {
    this.userRepo = new UserRepository();
    this.loginHistoryRepo = new LoginHistoryRepository();
    this.refreshTokenRepo = new RefreshTokenRepository();
    this.analyticsRepo = new AnalyticsRepository();
  }

  /**
   * Update user profile
   */
  async updateProfile(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { name, profilePicture } = req.body;
      const updates: any = {};

      if (name) updates.name = name;
      if (profilePicture) updates.profilePicture = profilePicture;

      const user = await this.userRepo.update(req.user.userId, updates);

      res.json({
        success: true,
        data: { user: this.userRepo.toSafeUser(user) },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update profile error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_ERROR',
          message: 'Failed to update profile',
        },
      } as APIResponse);
    }
  }

  /**
   * Change password
   */
  async changePassword(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { currentPassword, newPassword } = req.body;

      if (!currentPassword || !newPassword) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_REQUEST',
            message: 'Current and new password are required',
          },
        } as APIResponse);
        return;
      }

      const user = await this.userRepo.findById(req.user.userId);
      if (!user || !user.passwordHash) {
        res.status(400).json({
          success: false,
          error: {
            code: 'NO_PASSWORD',
            message: 'User has no password set',
          },
        } as APIResponse);
        return;
      }

      // Verify current password
      const isValid = await PasswordUtil.compare(
        currentPassword,
        user.passwordHash,
      );
      if (!isValid) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_PASSWORD',
            message: 'Current password is incorrect',
          },
        } as APIResponse);
        return;
      }

      // Validate new password
      const validation = PasswordUtil.validate(newPassword);
      if (!validation.valid) {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_NEW_PASSWORD',
            message: validation.errors.join(', '),
          },
        } as APIResponse);
        return;
      }

      // Update password
      const newHash = await PasswordUtil.hash(newPassword);
      await this.userRepo.updatePassword(user.id, newHash);

      // Revoke all refresh tokens for security
      await this.refreshTokenRepo.revokeAllForUser(user.id);

      res.json({
        success: true,
        data: { message: 'Password changed successfully. Please login again.' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Change password error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'CHANGE_PASSWORD_ERROR',
          message: 'Failed to change password',
        },
      } as APIResponse);
    }
  }

  /**
   * Get login history
   */
  async getLoginHistory(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const limit = parseInt(req.query.limit as string) || 10;
      const history = await this.loginHistoryRepo.getRecentLogins(
        req.user.userId,
        limit,
      );

      res.json({
        success: true,
        data: { loginHistory: history },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get login history error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'HISTORY_ERROR',
          message: 'Failed to fetch login history',
        },
      } as APIResponse);
    }
  }

  /**
   * Get user preferences
   */
  async getPreferences(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const preferences = await prisma.userPreferences.findUnique({
        where: { userId: req.user.userId },
      });

      res.json({
        success: true,
        data: { preferences },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Get preferences error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'PREFERENCES_ERROR',
          message: 'Failed to fetch preferences',
        },
      } as APIResponse);
    }
  }

  /**
   * Update user preferences
   */
  async updatePreferences(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const {
        difficulty,
        focusAreas,
        interviewType,
        sessionDuration,
        notificationsEnabled,
        emailNotifications,
      } = req.body;

      const preferences = await prisma.userPreferences.upsert({
        where: { userId: req.user.userId },
        update: {
          ...(difficulty && { difficulty }),
          ...(focusAreas && { focusAreas }),
          ...(interviewType && { interviewType }),
          ...(sessionDuration && { sessionDuration }),
          ...(notificationsEnabled !== undefined && { notificationsEnabled }),
          ...(emailNotifications !== undefined && { emailNotifications }),
        },
        create: {
          userId: req.user.userId,
          difficulty: difficulty || 'MEDIUM',
          focusAreas: focusAreas || [],
          interviewType: interviewType || 'fullstack',
          sessionDuration: sessionDuration || 30,
          notificationsEnabled: notificationsEnabled !== false,
          emailNotifications: emailNotifications !== false,
        },
      });

      res.json({
        success: true,
        data: { preferences },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Update preferences error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'UPDATE_PREFERENCES_ERROR',
          message: 'Failed to update preferences',
        },
      } as APIResponse);
    }
  }

  /**
   * Delete account
   */
  async deleteAccount(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const { password, confirmation } = req.body;

      if (confirmation !== 'DELETE MY ACCOUNT') {
        res.status(400).json({
          success: false,
          error: {
            code: 'INVALID_CONFIRMATION',
            message: 'Please type "DELETE MY ACCOUNT" to confirm',
          },
        } as APIResponse);
        return;
      }

      const user = await this.userRepo.findById(req.user.userId);
      if (!user) {
        res.status(404).json({
          success: false,
          error: { code: 'USER_NOT_FOUND', message: 'User not found' },
        } as APIResponse);
        return;
      }

      // Verify password if user has one
      if (user.passwordHash) {
        if (!password) {
          res.status(400).json({
            success: false,
            error: {
              code: 'PASSWORD_REQUIRED',
              message: 'Password is required to delete account',
            },
          } as APIResponse);
          return;
        }

        const isValid = await PasswordUtil.compare(password, user.passwordHash);
        if (!isValid) {
          res.status(400).json({
            success: false,
            error: {
              code: 'INVALID_PASSWORD',
              message: 'Password is incorrect',
            },
          } as APIResponse);
          return;
        }
      }

      // Delete user (cascades to all related data)
      await prisma.user.delete({
        where: { id: req.user.userId },
      });

      res.json({
        success: true,
        data: { message: 'Account deleted successfully' },
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Delete account error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'DELETE_ERROR',
          message: 'Failed to delete account',
        },
      } as APIResponse);
    }
  }

  /**
   * Export user data (GDPR compliance)
   */
  async exportData(req: Request, res: Response): Promise<void> {
    try {
      if (!req.user) {
        res.status(401).json({
          success: false,
          error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
        } as APIResponse);
        return;
      }

      const userId = req.user.userId;

      // Gather all user data
      const [
        user,
        sessions,
        interviews,
        progress,
        weakAreas,
        preferences,
        loginHistory,
      ] = await Promise.all([
        this.userRepo.findById(userId),
        prisma.session.findMany({ where: { userId } }),
        prisma.interviewSession.findMany({
          where: { userId },
          include: { questions: true },
        }),
        this.analyticsRepo.getUserProgress(userId),
        this.analyticsRepo.getWeakAreas(userId, 100),
        prisma.userPreferences.findUnique({ where: { userId } }),
        this.loginHistoryRepo.getRecentLogins(userId, 100),
      ]);

      const exportData = {
        user: user ? this.userRepo.toSafeUser(user) : null,
        sessions,
        interviews,
        progress,
        weakAreas,
        preferences,
        loginHistory,
        exportedAt: new Date(),
      };

      res.json({
        success: true,
        data: exportData,
        metadata: { timestamp: new Date() },
      } as APIResponse);
    } catch (error) {
      console.error('Export data error:', error);
      res.status(500).json({
        success: false,
        error: {
          code: 'EXPORT_ERROR',
          message: 'Failed to export data',
        },
      } as APIResponse);
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\jobs\auto-unsuspend.job.ts
==============================

// src/jobs/auto-unsuspend.job.ts
import cron from 'node-cron';
import prisma from '../config/database';

/**
 * Auto-unsuspend users whose suspension period has expired
 * Runs every hour
 */
export function startAutoUnsuspendJob() {
  cron.schedule('0 * * * *', async () => {
    try {
      console.log('Running auto-unsuspend job...');

      const now = new Date();

      // Find users whose suspension has expired
      const expiredSuspensions = await prisma.user.findMany({
        where: {
          isSuspended: true,
          suspendedUntil: {
            lte: now,
          },
        },
      });

      if (expiredSuspensions.length > 0) {
        // Update users
        await prisma.user.updateMany({
          where: {
            id: {
              in: expiredSuspensions.map((u) => u.id),
            },
          },
          data: {
            isSuspended: false,
            suspendedUntil: null,
            suspensionReason: null,
          },
        });

        // Update suspension records
        await prisma.userSuspension.updateMany({
          where: {
            userId: {
              in: expiredSuspensions.map((u) => u.id),
            },
            endedAt: null,
          },
          data: {
            endedAt: now,
            endedBy: 'SYSTEM',
          },
        });

        console.log(`Auto-unsuspended ${expiredSuspensions.length} users`);
      }
    } catch (error) {
      console.error('Auto-unsuspend job error:', error);
    }
  });

  console.log('Auto-unsuspend job scheduled (runs hourly)');
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\memory\memory-manager.ts
==============================

/**
 * Memory System
 * Handles both short-term (session) and long-term (user) memory
 */

import {
  ShortTermMemory,
  LongTermMemory,
  ConversationTurn,
  WeakArea,
  LearningProgress,
  SkillLevel,
} from '../types';

/**
 * Memory storage interface
 */
export interface IMemoryStore {
  // Short-term memory operations
  getShortTermMemory(sessionId: string): Promise<ShortTermMemory | null>;
  setShortTermMemory(memory: ShortTermMemory): Promise<void>;
  deleteShortTermMemory(sessionId: string): Promise<void>;
  addConversationTurn(sessionId: string, turn: ConversationTurn): Promise<void>;

  // Long-term memory operations
  getLongTermMemory(userId: string): Promise<LongTermMemory | null>;
  setLongTermMemory(memory: LongTermMemory): Promise<void>;
  updateWeakAreas(userId: string, weakAreas: WeakArea[]): Promise<void>;
  updateLearningProgress(userId: string, progress: Partial<LearningProgress>): Promise<void>;

  // Cleanup operations
  cleanupExpiredSessions(timeoutMinutes: number): Promise<number>;
}

/**
 * In-memory implementation of memory store
 * Can be swapped with Redis or database implementation
 */
export class InMemoryStore implements IMemoryStore {
  private shortTermMemories: Map<string, ShortTermMemory> = new Map();
  private longTermMemories: Map<string, LongTermMemory> = new Map();

  async getShortTermMemory(sessionId: string): Promise<ShortTermMemory | null> {
    return this.shortTermMemories.get(sessionId) || null;
  }

  async setShortTermMemory(memory: ShortTermMemory): Promise<void> {
    this.shortTermMemories.set(memory.sessionId, memory);
  }

  async deleteShortTermMemory(sessionId: string): Promise<void> {
    this.shortTermMemories.delete(sessionId);
  }

  async addConversationTurn(sessionId: string, turn: ConversationTurn): Promise<void> {
    const memory = await this.getShortTermMemory(sessionId);
    if (memory) {
      memory.conversationHistory.push(turn);
      memory.lastActivity = new Date();
      await this.setShortTermMemory(memory);
    }
  }

  async getLongTermMemory(userId: string): Promise<LongTermMemory | null> {
    return this.longTermMemories.get(userId) || null;
  }

  async setLongTermMemory(memory: LongTermMemory): Promise<void> {
    this.longTermMemories.set(memory.userId, memory);
  }

  async updateWeakAreas(userId: string, weakAreas: WeakArea[]): Promise<void> {
    const memory = await this.getLongTermMemory(userId);
    if (memory) {
      memory.weakAreas = weakAreas;
      await this.setLongTermMemory(memory);
    }
  }

  async updateLearningProgress(
    userId: string,
    progress: Partial<LearningProgress>
  ): Promise<void> {
    const memory = await this.getLongTermMemory(userId);
    if (memory) {
      memory.learningProgress = {
        ...memory.learningProgress,
        ...progress,
      };
      await this.setLongTermMemory(memory);
    }
  }

  async cleanupExpiredSessions(timeoutMinutes: number): Promise<number> {
    const now = new Date();
    const timeoutMs = timeoutMinutes * 60 * 1000;
    let deletedCount = 0;

    for (const [sessionId, memory] of this.shortTermMemories.entries()) {
      const inactiveTime = now.getTime() - memory.lastActivity.getTime();
      if (inactiveTime > timeoutMs) {
        this.shortTermMemories.delete(sessionId);
        deletedCount++;
      }
    }

    return deletedCount;
  }
}

/**
 * Memory Manager
 * High-level interface for memory operations
 */
export class MemoryManager {
  private store: IMemoryStore;

  constructor(store: IMemoryStore = new InMemoryStore()) {
    this.store = store;
  }

  /**
   * Create or get a short-term memory session
   */
  async createSession(userId: string, sessionId: string): Promise<ShortTermMemory> {
    const existing = await this.store.getShortTermMemory(sessionId);
    if (existing) {
      return existing;
    }

    const memory: ShortTermMemory = {
      sessionId,
      userId,
      conversationHistory: [],
      startTime: new Date(),
      lastActivity: new Date(),
    };

    await this.store.setShortTermMemory(memory);
    return memory;
  }

  /**
   * Get conversation context for an agent
   */
  async getConversationContext(
    sessionId: string,
    maxTurns: number = 10
  ): Promise<ConversationTurn[]> {
    const memory = await this.store.getShortTermMemory(sessionId);
    if (!memory) {
      return [];
    }

    // Return last N turns
    return memory.conversationHistory.slice(-maxTurns);
  }

  /**
   * Add a conversation turn
   */
  async addTurn(sessionId: string, turn: ConversationTurn): Promise<void> {
    await this.store.addConversationTurn(sessionId, turn);
  }

  /**
   * Create or get long-term memory for a user
   */
  async createUserMemory(userId: string): Promise<LongTermMemory> {
    const existing = await this.store.getLongTermMemory(userId);
    if (existing) {
      return existing;
    }

    const memory: LongTermMemory = {
      userId,
      weakAreas: [],
      strengths: [],
      interviewHistory: [],
      learningProgress: {
        totalInterviews: 0,
        topicsCompleted: [],
        currentLevel: SkillLevel.BEGINNER,
        goalLevel: SkillLevel.ADVANCED,
        milestones: [],
      },
    };

    await this.store.setLongTermMemory(memory);
    return memory;
  }

  /**
   * Record a weak area
   */
  async recordWeakArea(
    userId: string,
    topic: string,
    category: string,
    suggestions: string[] = []
  ): Promise<void> {
    const memory = await this.createUserMemory(userId);
    
    // Find existing weak area or create new one
    const existingIndex = memory.weakAreas.findIndex((wa) => wa.topic === topic);
    
    if (existingIndex !== -1) {
      memory.weakAreas[existingIndex].failureCount++;
      memory.weakAreas[existingIndex].lastEncountered = new Date();
      memory.weakAreas[existingIndex].improvementSuggestions.push(...suggestions);
    } else {
      memory.weakAreas.push({
        topic,
        category,
        failureCount: 1,
        lastEncountered: new Date(),
        improvementSuggestions: suggestions,
      });
    }

    await this.store.setLongTermMemory(memory);
  }

  /**
   * Get weak areas for a user
   */
  async getWeakAreas(userId: string, limit: number = 5): Promise<WeakArea[]> {
    const memory = await this.store.getLongTermMemory(userId);
    if (!memory) {
      return [];
    }

    // Sort by failure count and recency
    return memory.weakAreas
      .sort((a, b) => {
        if (a.failureCount !== b.failureCount) {
          return b.failureCount - a.failureCount;
        }
        return b.lastEncountered.getTime() - a.lastEncountered.getTime();
      })
      .slice(0, limit);
  }

  /**
   * Update learning progress
   */
  async updateProgress(
    userId: string,
    updates: Partial<LearningProgress>
  ): Promise<void> {
    await this.store.updateLearningProgress(userId, updates);
  }

  /**
   * Get user's learning summary
   */
  async getUserSummary(userId: string): Promise<{
    weakAreas: WeakArea[];
    progress: LearningProgress;
    recentTopics: string[];
  }> {
    const memory = await this.store.getLongTermMemory(userId);
    if (!memory) {
      return {
        weakAreas: [],
        progress: {
          totalInterviews: 0,
          topicsCompleted: [],
          currentLevel: SkillLevel.BEGINNER,
          goalLevel: SkillLevel.ADVANCED,
          milestones: [],
        },
        recentTopics: [],
      };
    }

    // Get recent topics from interview history
    const recentTopics = memory.interviewHistory
      .slice(-5)
      .flatMap((session) => session.questions.map((q) => q.category))
      .filter((topic, index, self) => self.indexOf(topic) === index);

    return {
      weakAreas: await this.getWeakAreas(userId),
      progress: memory.learningProgress,
      recentTopics,
    };
  }

  /**
   * Cleanup expired sessions
   */
  async cleanup(timeoutMinutes: number = 30): Promise<number> {
    return await this.store.cleanupExpiredSessions(timeoutMinutes);
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\memory\prisma-memory-store.ts
==============================

// src/memory/prisma-memory-store.ts
import prisma from '../config/database';
import { IMemoryStore } from './memory-manager';
import {
  ShortTermMemory,
  LongTermMemory,
  ConversationTurn,
  WeakArea,
  LearningProgress,
} from '../types';
import { Prisma } from '@prisma/client';

export class PrismaMemoryStore implements IMemoryStore {
  async getShortTermMemory(sessionId: string): Promise<ShortTermMemory | null> {
    const session = await prisma.session.findUnique({
      where: { id: sessionId },
    });

    if (!session) return null;

    return {
      sessionId: session.id,
      userId: session.userId,
      conversationHistory: session.conversationHistory as ConversationTurn[],
      startTime: session.createdAt,
      lastActivity: session.lastActivity,
    };
  }

  async setShortTermMemory(memory: ShortTermMemory): Promise<void> {
    const expiresAt = new Date(memory.lastActivity.getTime() + 30 * 60 * 1000); // 30 min

    await prisma.session.upsert({
      where: { id: memory.sessionId },
      update: {
        conversationHistory: memory.conversationHistory as Prisma.JsonArray,
        lastActivity: memory.lastActivity,
        expiresAt,
      },
      create: {
        id: memory.sessionId,
        userId: memory.userId,
        conversationHistory: memory.conversationHistory as Prisma.JsonArray,
        createdAt: memory.startTime,
        lastActivity: memory.lastActivity,
        expiresAt,
      },
    });
  }

  async deleteShortTermMemory(sessionId: string): Promise<void> {
    await prisma.session
      .delete({
        where: { id: sessionId },
      })
      .catch(() => {
        // Ignore if not found
      });
  }

  async addConversationTurn(
    sessionId: string,
    turn: ConversationTurn,
  ): Promise<void> {
    const session = await prisma.session.findUnique({
      where: { id: sessionId },
    });

    if (!session) return;

    const history = session.conversationHistory as ConversationTurn[];
    history.push(turn);

    await prisma.session.update({
      where: { id: sessionId },
      data: {
        conversationHistory: history as Prisma.JsonArray,
        lastActivity: new Date(),
      },
    });
  }

  async getLongTermMemory(userId: string): Promise<LongTermMemory | null> {
    const [weakAreas, userProgress, interviewSessions] = await Promise.all([
      prisma.weakArea.findMany({ where: { userId } }),
      prisma.userProgress.findUnique({ where: { userId } }),
      prisma.interviewSession.findMany({
        where: { userId },
        include: { questions: true },
        orderBy: { createdAt: 'desc' },
        take: 10,
      }),
    ]);

    if (
      !userProgress &&
      weakAreas.length === 0 &&
      interviewSessions.length === 0
    ) {
      return null;
    }

    const learningProgress: LearningProgress = userProgress
      ? {
          totalInterviews: userProgress.totalInterviews,
          topicsCompleted: userProgress.topicsCompleted as string[],
          currentLevel: userProgress.currentLevel,
          goalLevel: userProgress.goalLevel,
          milestones: userProgress.milestones as any[],
        }
      : {
          totalInterviews: 0,
          topicsCompleted: [],
          currentLevel: 'BEGINNER' as any,
          goalLevel: 'ADVANCED' as any,
          milestones: [],
        };

    return {
      userId,
      weakAreas: weakAreas.map((wa) => ({
        topic: wa.topic,
        category: wa.category,
        failureCount: wa.failureCount,
        lastEncountered: wa.lastEncountered,
        improvementSuggestions: wa.improvementSuggestions as string[],
      })),
      strengths: [], // Can be derived from high-performing topics
      interviewHistory: interviewSessions.map((session) => ({
        id: session.id,
        userId: session.userId,
        type: session.type.toLowerCase() as any,
        status: session.status.toLowerCase() as any,
        startTime: session.startTime,
        endTime: session.endTime || undefined,
        questions: session.questions.map((q) => ({
          id: q.id,
          question: q.question,
          difficulty: q.difficulty?.toLowerCase() as any,
          category: q.category,
          expectedAnswer: q.expectedAnswer || undefined,
          userAnswer: q.userAnswer || undefined,
          score: q.score ? Number(q.score) : undefined,
          feedback: q.feedback || undefined,
          timeSpent: q.timeSpent || undefined,
          hints: q.hints as string[],
          hintsUsed: q.hintsUsed,
        })),
        currentQuestionIndex: session.currentQuestionIndex,
        score: session.score ? Number(session.score) : undefined,
        feedback: session.feedback || undefined,
      })),
      learningProgress,
    };
  }

  async setLongTermMemory(memory: LongTermMemory): Promise<void> {
    // Update user progress
    await prisma.userProgress.upsert({
      where: { userId: memory.userId },
      update: {
        totalInterviews: memory.learningProgress.totalInterviews,
        topicsCompleted: memory.learningProgress
          .topicsCompleted as Prisma.JsonArray,
        currentLevel: memory.learningProgress.currentLevel,
        goalLevel: memory.learningProgress.goalLevel,
        milestones: memory.learningProgress.milestones as Prisma.JsonArray,
        lastUpdated: new Date(),
      },
      create: {
        userId: memory.userId,
        totalInterviews: memory.learningProgress.totalInterviews,
        topicsCompleted: memory.learningProgress
          .topicsCompleted as Prisma.JsonArray,
        currentLevel: memory.learningProgress.currentLevel,
        goalLevel: memory.learningProgress.goalLevel,
        milestones: memory.learningProgress.milestones as Prisma.JsonArray,
      },
    });
  }

  async updateWeakAreas(userId: string, weakAreas: WeakArea[]): Promise<void> {
    // Delete existing weak areas
    await prisma.weakArea.deleteMany({ where: { userId } });

    // Create new weak areas
    await prisma.weakArea.createMany({
      data: weakAreas.map((wa) => ({
        userId,
        topic: wa.topic,
        category: wa.category,
        failureCount: wa.failureCount,
        lastEncountered: wa.lastEncountered,
        improvementSuggestions: wa.improvementSuggestions as Prisma.JsonArray,
      })),
    });
  }

  async updateLearningProgress(
    userId: string,
    progress: Partial<LearningProgress>,
  ): Promise<void> {
    await prisma.userProgress.upsert({
      where: { userId },
      update: {
        ...(progress.totalInterviews !== undefined && {
          totalInterviews: progress.totalInterviews,
        }),
        ...(progress.topicsCompleted && {
          topicsCompleted: progress.topicsCompleted as Prisma.JsonArray,
        }),
        ...(progress.currentLevel && { currentLevel: progress.currentLevel }),
        ...(progress.goalLevel && { goalLevel: progress.goalLevel }),
        ...(progress.milestones && {
          milestones: progress.milestones as Prisma.JsonArray,
        }),
        lastUpdated: new Date(),
      },
      create: {
        userId,
        totalInterviews: progress.totalInterviews || 0,
        topicsCompleted: (progress.topicsCompleted as Prisma.JsonArray) || [],
        currentLevel: progress.currentLevel || 'BEGINNER',
        goalLevel: progress.goalLevel || 'ADVANCED',
        milestones: (progress.milestones as Prisma.JsonArray) || [],
      },
    });
  }

  async cleanupExpiredSessions(timeoutMinutes: number): Promise<number> {
    const cutoffTime = new Date(Date.now() - timeoutMinutes * 60 * 1000);

    const result = await prisma.session.deleteMany({
      where: {
        OR: [
          { expiresAt: { lt: new Date() } },
          { lastActivity: { lt: cutoffTime } },
        ],
      },
    });

    return result.count;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\middleware\activity-logger.middleware.ts
==============================

// src/middleware/activity-logger.middleware.ts
import { Request, Response, NextFunction } from 'express';
import prisma from '../config/database';

/**
 * Log user activity
 */
export async function activityLogger(
  req: Request,
  res: Response,
  next: NextFunction,
) {
  // Skip logging for certain endpoints
  const skipPaths = ['/health', '/metrics', '/api/auth/refresh'];
  if (skipPaths.some((path) => req.path.startsWith(path))) {
    return next();
  }

  // Capture the original json method
  const originalJson = res.json.bind(res);

  // Override res.json to capture response
  res.json = function (body: any) {
    // Log activity after response
    if (req.user) {
      setImmediate(async () => {
        try {
          await prisma.userActivityLog.create({
            data: {
              userId: req.user!.userId,
              action: `${req.method} ${req.path}`,
              details: {
                query: req.query,
                params: req.params,
              },
              endpoint: req.path,
              method: req.method,
              statusCode: res.statusCode,
              ipAddress: req.ip,
              userAgent: req.get('user-agent'),
            },
          });
        } catch (error) {
          console.error('Failed to log activity:', error);
        }
      });
    }

    return originalJson(body);
  };

  next();
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\middleware\auth.middleware.ts
==============================

// src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { TokenUtil } from '../utils/token.util';
import { UserRepository } from '../repositories/user.repository';
import { JWTPayload } from '../types/auth.types';
import { UserRole } from '@prisma/client';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: JWTPayload;
    }
  }
}

export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'No authentication token provided',
        },
      });
      return;
    }

    const token = authHeader.substring(7);

    let payload: JWTPayload;
    try {
      payload = TokenUtil.verifyAccessToken(token);
    } catch (error) {
      res.status(401).json({
        success: false,
        error: {
          code: 'INVALID_TOKEN',
          message: 'Invalid or expired token',
        },
      });
      return;
    }

    // Verify user still exists and is active
    const userRepo = new UserRepository();
    const user = await userRepo.findById(payload.userId);

    if (!user || !user.isActive) {
      res.status(401).json({
        success: false,
        error: {
          code: 'USER_INACTIVE',
          message: 'User account is inactive',
        },
      });
      return;
    }

    req.user = payload;
    next();
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'AUTH_ERROR',
        message: 'Authentication failed',
      },
    });
  }
};

export const authorize = (...roles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        success: false,
        error: {
          code: 'UNAUTHORIZED',
          message: 'Authentication required',
        },
      });
      return;
    }

    if (!roles.includes(req.user.role)) {
      res.status(403).json({
        success: false,
        error: {
          code: 'FORBIDDEN',
          message: 'Insufficient permissions',
        },
      });
      return;
    }

    next();
  };
};

export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  const authHeader = req.headers.authorization;

  if (authHeader && authHeader.startsWith('Bearer ')) {
    try {
      const token = authHeader.substring(7);
      const payload = TokenUtil.verifyAccessToken(token);
      req.user = payload;
    } catch (error) {
      // Invalid token, but continue anyway since auth is optional
    }
  }

  next();
};

/**
 * Authorize by role
 */
// export function authorize(...roles: UserRole[]) {
//   return (req: Request, res: Response, next: NextFunction) => {
//     if (!req.user) {
//       return res.status(401).json({
//         success: false,
//         error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
//       });
//     }

//     if (!roles.includes(req.user.role)) {
//       return res.status(403).json({
//         success: false,
//         error: {
//           code: 'FORBIDDEN',
//           message: 'You do not have permission to access this resource',
//         },
//       });
//     }

//     next();
//   };
// }

==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\middleware\rate-limit.middleware.ts
==============================

// src/middleware/rate-limit.middleware.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import redis from '../config/redis';
import { Request } from 'express';

// Global rate limiter
export const globalRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests, please try again later',
    },
  },
  standardHeaders: true,
  legacyHeaders: false,
  store: new RedisStore({
    // @ts-expect-error - Known typing issue with rate-limit-redis
    client: redis,
    prefix: 'rl:global:',
  }),
});

// Auth rate limiter (stricter)
export const authRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 attempts per 15 minutes
  message: {
    success: false,
    error: {
      code: 'TOO_MANY_ATTEMPTS',
      message: 'Too many login attempts, please try again after 15 minutes',
    },
  },
  skipSuccessfulRequests: true,
  store: new RedisStore({
    // @ts-expect-error
    client: redis,
    prefix: 'rl:auth:',
  }),
});

// API rate limiter based on user role
export const createUserRateLimiter = () => {
  return rateLimit({
    windowMs: 15 * 60 * 1000,
    max: async (req: Request) => {
      // Different limits based on user role
      if (!req.user) return 20; // Unauthenticated

      switch (req.user.role) {
        case 'ADMIN':
          return 1000;
        case 'PREMIUM':
          return 200;
        case 'FREE':
        default:
          return 50;
      }
    },
    keyGenerator: (req: Request) => {
      return req.user?.userId || req.ip || 'unknown';
    },
    message: {
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        message: 'Rate limit exceeded. Upgrade to Premium for higher limits.',
      },
    },
    store: new RedisStore({
      // @ts-expect-error
      client: redis,
      prefix: 'rl:user:',
    }),
  });
};

// src/middleware/rate-limit.middleware.ts - ADD admin rate limiter

/**
 * Create admin-specific rate limiter
 */
export function createAdminRateLimiter() {
  return rateLimit({
    store: new RedisStore({
      client: redisClient,
      prefix: 'rate_limit:admin:',
    }),
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 500, // Higher limit for admin users
    message: 'Too many admin requests',
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req: Request) => {
      return req.user?.userId || req.ip || 'anonymous';
    },
  });
}

==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\middleware\upload.middleware.ts
==============================

// src/middleware/upload.middleware.ts
import multer from 'multer';
import path from 'path';
import { Request } from 'express';

// Memory storage for processing before upload to S3
const storage = multer.memoryStorage();

// File filter
const fileFilter = (
  req: Request,
  file: Express.Multer.File,
  cb: multer.FileFilterCallback,
) => {
  // Allowed extensions
  const allowedExtensions = [
    '.jpg',
    '.jpeg',
    '.png',
    '.gif',
    '.webp', // Images
    '.pdf',
    '.doc',
    '.docx', // Documents
    '.js',
    '.ts',
    '.py',
    '.java',
    '.cpp',
    '.c', // Code files
    '.txt',
    '.md', // Text files
    '.svg', // SVG
  ];

  const ext = path.extname(file.originalname).toLowerCase();

  if (allowedExtensions.includes(ext)) {
    cb(null, true);
  } else {
    cb(new Error(`File type ${ext} not allowed`));
  }
};

// Multer configuration
export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max
  },
});

// Single file upload middleware
export const uploadSingle = (fieldName: string = 'file') => {
  return upload.single(fieldName);
};

// Multiple files upload middleware
export const uploadMultiple = (
  fieldName: string = 'files',
  maxCount: number = 5,
) => {
  return upload.array(fieldName, maxCount);
};

// Handle multer errors
export const handleUploadError = (
  err: any,
  req: Request,
  res: any,
  next: any,
) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'FILE_TOO_LARGE',
          message: 'File size exceeds 10MB limit',
        },
      });
    }
    if (err.code === 'LIMIT_FILE_COUNT') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'TOO_MANY_FILES',
          message: 'Too many files uploaded',
        },
      });
    }
  }

  if (err) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'UPLOAD_ERROR',
        message: err.message || 'File upload failed',
      },
    });
  }

  next();
};


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\middleware\validation.middleware.ts
==============================

// src/middleware/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';

export const validate = (schema: z.ZodSchema) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    try {
      await schema.parseAsync(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          error: {
            code: 'VALIDATION_ERROR',
            message: 'Invalid request data',
            details: error.errors.map((err) => ({
              field: err.path.join('.'),
              message: err.message,
            })),
          },
        });
        return;
      }

      next(error);
    }
  };
};


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\rag\rag-service.ts
==============================

/**
 * RAG Service
 * Orchestrates retrieval-augmented generation
 */

import { IVectorDatabase } from '../services/vector-db/base-vector-db';
import { RAGContext, RetrievalResult, Document } from '../types';

export interface RAGConfig {
  topK?: number;
  similarityThreshold?: number;
  searchStrategy?: 'semantic' | 'hybrid' | 'keyword';
}

export class RAGService {
  constructor(
    private vectorDb: IVectorDatabase,
    private config: RAGConfig = {}
  ) {
    this.config = {
      topK: config.topK || 5,
      similarityThreshold: config.similarityThreshold || 0.7,
      searchStrategy: config.searchStrategy || 'semantic',
    };
  }

  /**
   * Retrieve relevant context for a query
   */
  async retrieveContext(
    query: string,
    filter?: Record<string, unknown>
  ): Promise<RAGContext> {
    const results = await this.vectorDb.search(
      query,
      this.config.topK,
      filter
    );

    // Filter by similarity threshold
    const filteredResults = results.filter(
      (r) => r.relevance >= this.config.similarityThreshold!
    );

    return {
      query,
      retrievedDocs: filteredResults,
      totalResults: results.length,
      searchStrategy: this.config.searchStrategy!,
    };
  }

  /**
   * Index documents into the vector store
   */
  async indexDocuments(documents: Document[]): Promise<void> {
    await this.vectorDb.addDocuments(documents);
  }

  /**
   * Index a single document
   */
  async indexDocument(document: Document): Promise<void> {
    await this.vectorDb.addDocument(document);
  }

  /**
   * Delete documents by category
   */
  async deleteByCategory(category: string): Promise<void> {
    // Note: This is a simplified implementation
    // In production, you'd want to query by category first, then delete
    console.warn('Delete by category not fully implemented');
  }

  /**
   * Get statistics about indexed documents
   */
  async getStats(): Promise<{
    totalDocuments: number;
    categories: Record<string, number>;
  }> {
    // This would require additional implementation in the vector DB
    return {
      totalDocuments: 0,
      categories: {},
    };
  }

  /**
   * Format retrieved context for prompt injection
   */
  formatContextForPrompt(context: RAGContext): string {
    if (context.retrievedDocs.length === 0) {
      return '';
    }

    let formatted = '\n\n--- Retrieved Context ---\n';
    
    context.retrievedDocs.forEach((result, index) => {
      formatted += `\n[${index + 1}] (Relevance: ${(result.relevance * 100).toFixed(1)}%)\n`;
      formatted += `Source: ${result.document.metadata.source}\n`;
      formatted += `Content: ${result.document.content}\n`;
      
      if (result.document.metadata.company) {
        formatted += `Company: ${result.document.metadata.company}\n`;
      }
      
      if (result.document.metadata.difficulty) {
        formatted += `Difficulty: ${result.document.metadata.difficulty}\n`;
      }
    });

    formatted += '\n--- End of Context ---\n';
    
    return formatted;
  }

  /**
   * Update RAG configuration
   */
  updateConfig(config: Partial<RAGConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current configuration
   */
  getConfig(): RAGConfig {
    return { ...this.config };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\repositories\analytics.repository.ts
==============================

// src/repositories/analytics.repository.ts
import prisma from '../config/database';
import { InterviewSession, InterviewQuestion, Prisma } from '@prisma/client';

export interface InterviewStats {
  totalInterviews: number;
  completedInterviews: number;
  averageScore: number;
  completionRate: number;
  totalTimeSpent: number;
}

export interface TopicPerformance {
  topic: string;
  category: string;
  totalQuestions: number;
  averageScore: number;
  successRate: number;
}

export interface PerformanceTrend {
  date: Date;
  averageScore: number;
  interviewCount: number;
}

export class AnalyticsRepository {
  async getInterviewStats(userId: string): Promise<InterviewStats> {
    const sessions = await prisma.interviewSession.findMany({
      where: { userId },
      include: { questions: true },
    });

    const completed = sessions.filter((s) => s.status === 'COMPLETED');

    const totalScore = completed.reduce(
      (sum, s) => sum + (Number(s.score) || 0),
      0,
    );
    const totalTime = sessions.reduce(
      (sum, s) => sum + (s.durationMinutes || 0),
      0,
    );

    return {
      totalInterviews: sessions.length,
      completedInterviews: completed.length,
      averageScore: completed.length > 0 ? totalScore / completed.length : 0,
      completionRate:
        sessions.length > 0 ? (completed.length / sessions.length) * 100 : 0,
      totalTimeSpent: totalTime,
    };
  }

  async getTopicPerformance(userId: string): Promise<TopicPerformance[]> {
    const questions = await prisma.interviewQuestion.findMany({
      where: {
        session: { userId },
        score: { not: null },
      },
      select: {
        category: true,
        score: true,
      },
    });

    const topicMap = new Map<string, { scores: number[]; total: number }>();

    questions.forEach((q) => {
      if (!topicMap.has(q.category)) {
        topicMap.set(q.category, { scores: [], total: 0 });
      }
      const data = topicMap.get(q.category)!;
      data.scores.push(Number(q.score));
      data.total++;
    });

    const performance: TopicPerformance[] = [];
    topicMap.forEach((data, category) => {
      const avgScore =
        data.scores.reduce((a, b) => a + b, 0) / data.scores.length;
      const successRate =
        (data.scores.filter((s) => s >= 60).length / data.total) * 100;

      performance.push({
        topic: category,
        category: category,
        totalQuestions: data.total,
        averageScore: avgScore,
        successRate,
      });
    });

    return performance.sort((a, b) => b.averageScore - a.averageScore);
  }

  async getPerformanceTrends(
    userId: string,
    days: number = 30,
  ): Promise<PerformanceTrend[]> {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const sessions = await prisma.interviewSession.findMany({
      where: {
        userId,
        status: 'COMPLETED',
        createdAt: { gte: startDate },
      },
      orderBy: { createdAt: 'asc' },
    });

    const dailyMap = new Map<string, { scores: number[]; count: number }>();

    sessions.forEach((session) => {
      const dateKey = session.createdAt.toISOString().split('T')[0];
      if (!dailyMap.has(dateKey)) {
        dailyMap.set(dateKey, { scores: [], count: 0 });
      }
      const data = dailyMap.get(dateKey)!;
      if (session.score) {
        data.scores.push(Number(session.score));
      }
      data.count++;
    });

    const trends: PerformanceTrend[] = [];
    dailyMap.forEach((data, dateKey) => {
      trends.push({
        date: new Date(dateKey),
        averageScore:
          data.scores.length > 0
            ? data.scores.reduce((a, b) => a + b, 0) / data.scores.length
            : 0,
        interviewCount: data.count,
      });
    });

    return trends;
  }

  async getWeakAreas(userId: string, limit: number = 5) {
    return prisma.weakArea.findMany({
      where: { userId },
      orderBy: [{ failureCount: 'desc' }, { lastEncountered: 'desc' }],
      take: limit,
    });
  }

  async getUserProgress(userId: string) {
    return prisma.userProgress.findUnique({
      where: { userId },
    });
  }

  async updateUserProgress(
    userId: string,
    data: Prisma.UserProgressUpdateInput,
  ) {
    return prisma.userProgress.upsert({
      where: { userId },
      update: data,
      create: {
        userId,
        ...data,
      },
    });
  }

  async recordWeakArea(userId: string, topic: string, category: string) {
    return prisma.weakArea.upsert({
      where: {
        userId_topic: { userId, topic },
      },
      update: {
        failureCount: { increment: 1 },
        lastEncountered: new Date(),
      },
      create: {
        userId,
        topic,
        category,
        failureCount: 1,
      },
    });
  }

  async getComparativeAnalytics(userId: string) {
    const userStats = await this.getInterviewStats(userId);

    const globalStats = await prisma.interviewSession.aggregate({
      where: { status: 'COMPLETED' },
      _avg: { score: true },
      _count: true,
    });

    const userRanking = await prisma.$queryRaw<{ rank: bigint }[]>`
      WITH user_scores AS (
        SELECT 
          "userId",
          AVG(score) as avg_score
        FROM "InterviewSession"
        WHERE status = 'COMPLETED' AND score IS NOT NULL
        GROUP BY "userId"
      )
      SELECT COUNT(*) + 1 as rank
      FROM user_scores
      WHERE avg_score > (
        SELECT avg_score FROM user_scores WHERE "userId" = ${userId}
      )
    `;

    return {
      userAverageScore: userStats.averageScore,
      globalAverageScore: Number(globalStats._avg.score) || 0,
      totalUsers: globalStats._count,
      userRank: Number(userRanking[0]?.rank || 0),
      percentile: userRanking[0]
        ? (
            (1 - Number(userRanking[0].rank) / globalStats._count) *
            100
          ).toFixed(1)
        : 0,
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\repositories\login-history.repository.ts
==============================

// src/repositories/login-history.repository.ts
import prisma from '../config/database';

export class LoginHistoryRepository {
  async create(
    userId: string,
    ipAddress: string,
    userAgent: string,
    loginMethod: string,
    success: boolean = true,
  ) {
    return prisma.loginHistory.create({
      data: {
        userId,
        ipAddress,
        userAgent,
        loginMethod,
        success,
      },
    });
  }

  async getRecentLogins(userId: string, limit: number = 10) {
    return prisma.loginHistory.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });
  }

  async getFailedAttempts(userId: string, since: Date) {
    return prisma.loginHistory.count({
      where: {
        userId,
        success: false,
        createdAt: { gte: since },
      },
    });
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\repositories\refresh-token.repository.ts
==============================

// src/repositories/refresh-token.repository.ts
import prisma from '../config/database';
import { RefreshToken } from '@prisma/client';

export class RefreshTokenRepository {
  async create(
    userId: string,
    token: string,
    expiresAt: Date,
  ): Promise<RefreshToken> {
    return prisma.refreshToken.create({
      data: {
        userId,
        token,
        expiresAt,
      },
    });
  }

  async findByToken(token: string): Promise<RefreshToken | null> {
    return prisma.refreshToken.findUnique({
      where: { token },
      include: { user: true },
    });
  }

  async revoke(token: string, replacedByToken?: string): Promise<void> {
    await prisma.refreshToken.update({
      where: { token },
      data: {
        revoked: true,
        replacedByToken,
      },
    });
  }

  async revokeAllForUser(userId: string): Promise<void> {
    await prisma.refreshToken.updateMany({
      where: { userId },
      data: { revoked: true },
    });
  }

  async deleteExpired(): Promise<number> {
    const result = await prisma.refreshToken.deleteMany({
      where: {
        expiresAt: {
          lt: new Date(),
        },
      },
    });
    return result.count;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\repositories\session.repository.ts
==============================

// src/repositories/session.repository.ts
import prisma from '../config/database';
import { Session } from '@prisma/client';
import { ConversationTurn } from '../types';

export class SessionRepository {
  async create(
    userId: string,
    sessionId: string,
    expiresAt: Date,
  ): Promise<Session> {
    return prisma.session.create({
      data: {
        id: sessionId,
        userId,
        expiresAt,
      },
    });
  }

  async findById(sessionId: string): Promise<Session | null> {
    return prisma.session.findUnique({
      where: { id: sessionId },
    });
  }

  async addConversationTurn(
    sessionId: string,
    turn: ConversationTurn,
  ): Promise<void> {
    const session = await this.findById(sessionId);
    if (!session) return;

    const history = session.conversationHistory as ConversationTurn[];
    history.push(turn);

    await prisma.session.update({
      where: { id: sessionId },
      data: {
        conversationHistory: history,
        lastActivity: new Date(),
      },
    });
  }

  async updateLastActivity(sessionId: string): Promise<void> {
    await prisma.session.update({
      where: { id: sessionId },
      data: { lastActivity: new Date() },
    });
  }

  async deleteExpired(): Promise<number> {
    const result = await prisma.session.deleteMany({
      where: {
        expiresAt: {
          lt: new Date(),
        },
      },
    });
    return result.count;
  }

  async findByUserId(userId: string, limit: number = 10): Promise<Session[]> {
    return prisma.session.findMany({
      where: { userId },
      orderBy: { lastActivity: 'desc' },
      take: limit,
    });
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\repositories\user.repository.ts
==============================

// src/repositories/user.repository.ts
import prisma from '../config/database';
import { User, UserRole } from '@prisma/client';
import { RegisterDTO, SafeUser } from '../types/auth.types';

export class UserRepository {
  async create(data: RegisterDTO & { passwordHash: string }): Promise<User> {
    return prisma.user.create({
      data: {
        email: data.email,
        passwordHash: data.passwordHash,
        name: data.name,
      },
    });
  }

  async findById(id: string): Promise<User | null> {
    return prisma.user.findUnique({
      where: { id },
    });
  }

  async findByEmail(email: string): Promise<User | null> {
    return prisma.user.findUnique({
      where: { email },
    });
  }

  async findByVerificationToken(token: string): Promise<User | null> {
    return prisma.user.findFirst({
      where: {
        verificationToken: token,
        verificationTokenExpires: {
          gte: new Date(),
        },
      },
    });
  }

  async findByResetToken(token: string): Promise<User | null> {
    return prisma.user.findFirst({
      where: {
        resetToken: token,
        resetTokenExpires: {
          gte: new Date(),
        },
      },
    });
  }

  async findByOAuth(provider: string, oauthId: string): Promise<User | null> {
    return prisma.user.findFirst({
      where: {
        oauthProvider: provider,
        oauthId,
      },
    });
  }

  async update(id: string, data: Partial<User>): Promise<User> {
    return prisma.user.update({
      where: { id },
      data,
    });
  }

  async updateLastLogin(id: string): Promise<void> {
    await prisma.user.update({
      where: { id },
      data: { lastLogin: new Date() },
    });
  }

  async setVerificationToken(
    id: string,
    token: string,
    expires: Date,
  ): Promise<void> {
    await prisma.user.update({
      where: { id },
      data: {
        verificationToken: token,
        verificationTokenExpires: expires,
      },
    });
  }

  async setResetToken(id: string, token: string, expires: Date): Promise<void> {
    await prisma.user.update({
      where: { id },
      data: {
        resetToken: token,
        resetTokenExpires: expires,
      },
    });
  }

  async verifyEmail(id: string): Promise<void> {
    await prisma.user.update({
      where: { id },
      data: {
        emailVerified: true,
        verificationToken: null,
        verificationTokenExpires: null,
      },
    });
  }

  async updatePassword(id: string, passwordHash: string): Promise<void> {
    await prisma.user.update({
      where: { id },
      data: {
        passwordHash,
        resetToken: null,
        resetTokenExpires: null,
      },
    });
  }

  toSafeUser(user: User): SafeUser {
    const { passwordHash, verificationToken, resetToken, ...safeUser } = user;
    return safeUser;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\router\agent-router.ts
==============================

/**
 * Agent Router
 * Routes queries to the appropriate agent using hybrid strategy
 */

import {
  AgentType,
  BaseAgentInput,
  RoutingDecision,
  RouterStrategy,
  IAgent,
} from '../types';
import { ILLMProvider } from '../services/llm/base-provider';

export class AgentRouter {
  private agents: Map<AgentType, IAgent> = new Map();
  private strategy: RouterStrategy;

  constructor(
    private llmProvider: ILLMProvider,
    strategy: RouterStrategy = RouterStrategy.HYBRID
  ) {
    this.strategy = strategy;
  }

  /**
   * Register an agent
   */
  registerAgent(agent: IAgent): void {
    this.agents.set(agent.type, agent);
  }

  /**
   * Get all registered agents
   */
  getAgents(): IAgent[] {
    return Array.from(this.agents.values());
  }

  /**
   * Route a query to the appropriate agent
   */
  async route(input: BaseAgentInput): Promise<RoutingDecision> {
    switch (this.strategy) {
      case RouterStrategy.RULE_BASED:
        return await this.ruleBasedRouting(input);
      case RouterStrategy.LLM_BASED:
        return await this.llmBasedRouting(input);
      case RouterStrategy.HYBRID:
        return await this.hybridRouting(input);
      default:
        throw new Error(`Unsupported routing strategy: ${this.strategy}`);
    }
  }

  /**
   * Rule-based routing using keyword matching
   * Fast but less flexible
   */
  private async ruleBasedRouting(input: BaseAgentInput): Promise<RoutingDecision> {
    const queryLower = input.query.toLowerCase();

    // Priority-based keyword matching
    const rules: Array<{
      agentType: AgentType;
      keywords: string[];
      weight: number;
    }> = [
      {
        agentType: AgentType.RESUME_REVIEW,
        keywords: ['resume', 'cv', 'curriculum vitae', 'review my resume'],
        weight: 3,
      },
      {
        agentType: AgentType.DSA_INTERVIEW,
        keywords: [
          'algorithm',
          'leetcode',
          'coding',
          'data structure',
          'array',
          'tree',
          'graph',
          'sorting',
          'complexity',
        ],
        weight: 2,
      },
      {
        agentType: AgentType.SYSTEM_DESIGN,
        keywords: [
          'system design',
          'architecture',
          'scalability',
          'distributed',
          'design',
          'microservice',
          'load balancer',
        ],
        weight: 2,
      },
      {
        agentType: AgentType.HR_BEHAVIORAL,
        keywords: [
          'tell me about',
          'behavioral',
          'star method',
          'describe a time',
          'teamwork',
          'conflict',
          'leadership',
        ],
        weight: 2,
      },
      {
        agentType: AgentType.LEARNING_SUPPORT,
        keywords: [
          'progress',
          'improvement',
          'weak',
          'practice',
          'study plan',
          'roadmap',
          'learning',
        ],
        weight: 1,
      },
    ];

    // Calculate scores for each agent
    const scores = new Map<AgentType, number>();

    for (const rule of rules) {
      let score = 0;
      for (const keyword of rule.keywords) {
        if (queryLower.includes(keyword)) {
          score += rule.weight;
        }
      }
      if (score > 0) {
        scores.set(rule.agentType, score);
      }
    }

    if (scores.size === 0) {
      // Default to DSA if no match
      return {
        agentType: AgentType.DSA_INTERVIEW,
        confidence: 0.3,
        reasoning: 'No clear match, defaulting to DSA Interview Agent',
        fallbackAgents: [AgentType.LEARNING_SUPPORT],
      };
    }

    // Get agent with highest score
    const sortedScores = Array.from(scores.entries()).sort((a, b) => b[1] - a[1]);
    const [topAgent, topScore] = sortedScores[0];

    // Calculate confidence based on score difference
    const totalScore = Array.from(scores.values()).reduce((a, b) => a + b, 0);
    const confidence = topScore / totalScore;

    return {
      agentType: topAgent,
      confidence: Math.min(confidence, 0.9), // Cap at 0.9 for rule-based
      reasoning: `Keyword matching suggests ${topAgent}`,
      fallbackAgents: sortedScores.slice(1, 3).map(([agent]) => agent),
    };
  }

  /**
   * LLM-based routing using intent classification
   * More flexible but slower
   */
  private async llmBasedRouting(input: BaseAgentInput): Promise<RoutingDecision> {
    const agentDescriptions = Array.from(this.agents.values())
      .map(
        (agent) => `- ${agent.type}: ${agent.description}`
      )
      .join('\n');

    const routingPrompt = `You are a query router for an AI interview coach system.

Available agents:
${agentDescriptions}

User query: "${input.query}"

Determine which agent should handle this query. Consider:
1. The primary intent of the query
2. The type of help the user needs
3. Context clues in the query

Respond with JSON containing:
- agentType: the agent type (exact string match from list above)
- confidence: your confidence (0-1)
- reasoning: brief explanation
- fallbackAgents: array of alternative agents (optional)`;

    const schema = {
      agentType: 'string',
      confidence: 'number (0-1)',
      reasoning: 'string',
      fallbackAgents: 'array of strings (optional)',
    };

    try {
      const decision = await this.llmProvider.generateStructuredOutput<RoutingDecision>(
        {
          messages: [
            {
              role: 'system',
              content: 'You are an expert at understanding user intent and routing queries.',
            },
            { role: 'user', content: routingPrompt },
          ],
          temperature: 0.3,
          maxTokens: 500,
        },
        schema
      );

      return decision;
    } catch (error) {
      console.error('LLM routing failed, falling back to rules:', error);
      return await this.ruleBasedRouting(input);
    }
  }

  /**
   * Hybrid routing: use rules first, LLM for ambiguous cases
   * Best balance of speed and accuracy
   */
  private async hybridRouting(input: BaseAgentInput): Promise<RoutingDecision> {
    // Try rule-based first
    const ruleDecision = await this.ruleBasedRouting(input);

    // If confidence is high enough, use rule-based result
    if (ruleDecision.confidence >= 0.7) {
      return {
        ...ruleDecision,
        reasoning: `Rule-based routing (high confidence): ${ruleDecision.reasoning}`,
      };
    }

    // Otherwise, use LLM for better accuracy
    console.log('Low confidence from rules, using LLM routing...');
    const llmDecision = await this.llmBasedRouting(input);

    return {
      ...llmDecision,
      reasoning: `Hybrid routing (LLM fallback): ${llmDecision.reasoning}`,
    };
  }

  /**
   * Get the agent for a given type
   */
  getAgent(agentType: AgentType): IAgent | undefined {
    return this.agents.get(agentType);
  }

  /**
   * Execute routing and get the appropriate agent
   */
  async routeAndGetAgent(input: BaseAgentInput): Promise<{
    agent: IAgent;
    decision: RoutingDecision;
  }> {
    const decision = await this.route(input);
    const agent = this.getAgent(decision.agentType);

    if (!agent) {
      throw new Error(`No agent found for type: ${decision.agentType}`);
    }

    return { agent, decision };
  }

  /**
   * Set routing strategy
   */
  setStrategy(strategy: RouterStrategy): void {
    this.strategy = strategy;
  }

  /**
   * Get current strategy
   */
  getStrategy(): RouterStrategy {
    return this.strategy;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\admin\admin-user.routes.ts
==============================

// src/routes/admin/admin-user.routes.ts
import express, { Router } from 'express';
import { AdminUserController } from '../../controllers/admin/admin-user.controller';
import { authenticate, authorize } from '../../middleware/auth.middleware';
import { createAdminRateLimiter } from '../../middleware/rate-limit.middleware';

export function createAdminUserRoutes(): Router {
  const router = express.Router();
  const controller = new AdminUserController();
  const adminRateLimit = createAdminRateLimiter();

  // All routes require admin authentication
  router.use(authenticate);
  router.use(authorize('ADMIN'));
  router.use(adminRateLimit);

  /**
   * GET /api/admin/users
   * Get users with filters and pagination
   * Query params: search, role, status, emailVerified, dateFrom, dateTo, isSuspicious, page, limit, sortBy, sortOrder
   */
  router.get('/users', (req, res) => controller.getUsers(req, res));

  /**
   * GET /api/admin/users/stats
   * Get dashboard statistics
   */
  router.get('/users/stats', (req, res) =>
    controller.getDashboardStats(req, res),
  );

  /**
   * GET /api/admin/users/:userId
   * Get complete user details
   */
  router.get('/users/:userId', (req, res) =>
    controller.getUserDetails(req, res),
  );

  /**
   * POST /api/admin/users/:userId/ban
   * Ban a user
   * Body: { reason: string, isPermanent?: boolean }
   */
  router.post('/users/:userId/ban', (req, res) => controller.banUser(req, res));

  /**
   * POST /api/admin/users/:userId/unban
   * Unban a user
   */
  router.post('/users/:userId/unban', (req, res) =>
    controller.unbanUser(req, res),
  );

  /**
   * POST /api/admin/users/:userId/suspend
   * Suspend a user
   * Body: { reason: string, durationHours: number }
   */
  router.post('/users/:userId/suspend', (req, res) =>
    controller.suspendUser(req, res),
  );

  /**
   * POST /api/admin/users/:userId/unsuspend
   * Unsuspend a user
   */
  router.post('/users/:userId/unsuspend', (req, res) =>
    controller.unsuspendUser(req, res),
  );

  /**
   * PATCH /api/admin/users/:userId/role
   * Change user role
   * Body: { role: "FREE" | "PREMIUM" | "ADMIN" }
   */
  router.patch('/users/:userId/role', (req, res) =>
    controller.changeUserRole(req, res),
  );

  /**
   * POST /api/admin/users/:userId/reset-password
   * Reset user password
   * Body: { newPassword: string }
   */
  router.post('/users/:userId/reset-password', (req, res) =>
    controller.resetUserPassword(req, res),
  );

  /**
   * DELETE /api/admin/users/:userId
   * Delete a user
   * Body: { reason: string }
   */
  router.delete('/users/:userId', (req, res) =>
    controller.deleteUser(req, res),
  );

  /**
   * PATCH /api/admin/users/:userId/notes
   * Update admin notes for user
   * Body: { notes: string }
   */
  router.patch('/users/:userId/notes', (req, res) =>
    controller.updateAdminNotes(req, res),
  );

  /**
   * PATCH /api/admin/users/:userId/suspicious
   * Mark/unmark user as suspicious
   * Body: { isSuspicious: boolean }
   */
  router.patch('/users/:userId/suspicious', (req, res) =>
    controller.markSuspicious(req, res),
  );

  /**
   * GET /api/admin/users/:userId/activity
   * Get user activity log
   * Query params: limit
   */
  router.get('/users/:userId/activity', (req, res) =>
    controller.getUserActivity(req, res),
  );

  /**
   * GET /api/admin/users/:userId/export
   * Export user data (GDPR)
   */
  router.get('/users/:userId/export', (req, res) =>
    controller.exportUserData(req, res),
  );

  /**
   * POST /api/admin/users/bulk-ban
   * Bulk ban users
   * Body: { userIds: string[], reason: string }
   */
  router.post('/users/bulk-ban', (req, res) =>
    controller.bulkBanUsers(req, res),
  );

  /**
   * GET /api/admin/actions
   * Get admin action logs (audit trail)
   * Query params: adminId, targetUserId, action, dateFrom, dateTo, page, limit
   */
  router.get('/actions', (req, res) => controller.getAdminActions(req, res));

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\ai-question-generator.routes.ts
==============================

// src/routes/ai-question-generator.routes.ts
import express, { Router } from 'express';
import { AIQuestionGeneratorController } from '../controllers/ai-question-generator.controller';
import { authenticate, authorize } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';
import { ILLMProvider } from '../services/llm/base-provider';

export function createAIQuestionGeneratorRoutes(
  llmProvider: ILLMProvider,
): Router {
  const router = express.Router();
  const controller = new AIQuestionGeneratorController(llmProvider);
  const userRateLimit = createUserRateLimiter();

  /**
   * POST /api/ai-questions/generate
   * Generate AI questions
   * Body: { generationType, baseQuestionId?, difficulty?, category?, count? }
   */
  router.post('/generate', authenticate, userRateLimit, (req, res) =>
    controller.generateQuestions(req, res),
  );

  /**
   * POST /api/ai-questions/:questionId/similar
   * Generate similar questions to existing one
   * Body: { count }
   */
  router.post('/:questionId/similar', authenticate, userRateLimit, (req, res) =>
    controller.generateSimilar(req, res),
  );

  /**
   * GET /api/ai-questions/:questionId
   * Get generated question by ID
   */
  router.get('/:questionId', authenticate, (req, res) =>
    controller.getQuestion(req, res),
  );

  /**
   * POST /api/ai-questions/:questionId/usage
   * Record question usage
   * Body: { sessionId?, wasSuccessful?, timeSpent?, userRating?, userFeedback? }
   */
  router.post('/:questionId/usage', authenticate, userRateLimit, (req, res) =>
    controller.recordUsage(req, res),
  );

  /**
   * GET /api/ai-questions/admin/pending
   * Get questions pending review (admin only)
   */
  router.get('/admin/pending', authenticate, authorize('ADMIN'), (req, res) =>
    controller.getPendingReview(req, res),
  );

  /**
   * POST /api/ai-questions/:questionId/approve
   * Approve generated question (admin only)
   */
  router.post(
    '/:questionId/approve',
    authenticate,
    authorize('ADMIN'),
    (req, res) => controller.approveQuestion(req, res),
  );

  /**
   * GET /api/ai-questions/admin/statistics
   * Get generation statistics (admin only)
   */
  router.get(
    '/admin/statistics',
    authenticate,
    authorize('ADMIN'),
    (req, res) => controller.getStatistics(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\analytics.routes.ts
==============================

// src/routes/analytics.routes.ts
import express, { Router } from 'express';
import { AnalyticsController } from '../controllers/analytics.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createAnalyticsRoutes(): Router {
  const router = express.Router();
  const analyticsController = new AnalyticsController();
  const userRateLimit = createUserRateLimiter();

  // All analytics routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * GET /api/analytics/dashboard
   * Get complete dashboard with all analytics
   */
  router.get('/dashboard', (req, res) =>
    analyticsController.getDashboard(req, res),
  );

  /**
   * GET /api/analytics/stats
   * Get interview statistics
   */
  router.get('/stats', (req, res) =>
    analyticsController.getInterviewStats(req, res),
  );

  /**
   * GET /api/analytics/performance/topics
   * Get topic-wise performance breakdown
   */
  router.get('/performance/topics', (req, res) =>
    analyticsController.getTopicPerformance(req, res),
  );

  /**
   * GET /api/analytics/performance/trends
   * Get performance trends over time
   */
  router.get('/performance/trends', (req, res) =>
    analyticsController.getPerformanceTrends(req, res),
  );

  /**
   * GET /api/analytics/comparative
   * Get comparative analytics (user vs peers)
   */
  router.get('/comparative', (req, res) =>
    analyticsController.getComparativeAnalytics(req, res),
  );

  /**
   * GET /api/analytics/skill-gaps
   * Identify skill gaps and recommendations
   */
  router.get('/skill-gaps', (req, res) =>
    analyticsController.getSkillGaps(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\api-routes.ts
==============================

/**
 * API Routes
 * Defines all REST API endpoints
 */

import express, { Router } from 'express';
import { QueryController } from '../controllers/query-controller';
import { InterviewController } from '../controllers/interview-controller';
import {
  ResumeController,
  ProgressController,
} from '../controllers/resume-progress-controllers';

/**
 * Create and configure all API routes
 */
export function createRoutes(
  queryController: QueryController,
  interviewController: InterviewController,
  resumeController: ResumeController,
  progressController: ProgressController
): Router {
  const router = express.Router();

  // ============================================================================
  // Query Routes
  // ============================================================================

  /**
   * POST /api/query
   * Process a general query through the agent system
   */
  router.post('/query', (req, res) => queryController.processQuery(req, res));

  /**
   * GET /api/query/history/:sessionId
   * Get conversation history for a session
   */
  router.get('/query/history/:sessionId', (req, res) =>
    queryController.getHistory(req, res)
  );

  // ============================================================================
  // Interview Routes
  // ============================================================================

  /**
   * POST /api/interview/start
   * Start a new mock interview session
   */
  router.post('/interview/start', (req, res) =>
    interviewController.startInterview(req, res)
  );

  /**
   * POST /api/interview/answer
   * Submit answer to current question
   */
  router.post('/interview/answer', (req, res) =>
    interviewController.submitAnswer(req, res)
  );

  /**
   * GET /api/interview/:sessionId/hint
   * Request a hint for current question
   */
  router.get('/interview/:sessionId/hint', (req, res) =>
    interviewController.requestHint(req, res)
  );

  /**
   * GET /api/interview/:sessionId
   * Get interview session status
   */
  router.get('/interview/:sessionId', (req, res) =>
    interviewController.getSessionStatus(req, res)
  );

  /**
   * POST /api/interview/:sessionId/pause
   * Pause interview session
   */
  router.post('/interview/:sessionId/pause', (req, res) =>
    interviewController.pauseSession(req, res)
  );

  /**
   * POST /api/interview/:sessionId/resume
   * Resume interview session
   */
  router.post('/interview/:sessionId/resume', (req, res) =>
    interviewController.resumeSession(req, res)
  );

  // ============================================================================
  // Resume Routes
  // ============================================================================

  /**
   * POST /api/resume/review
   * Submit resume for review
   */
  router.post('/resume/review', (req, res) =>
    resumeController.reviewResume(req, res)
  );

  // ============================================================================
  // Progress Routes
  // ============================================================================

  /**
   * GET /api/progress/:userId
   * Get user's overall progress
   */
  router.get('/progress/:userId', (req, res) =>
    progressController.getProgress(req, res)
  );

  /**
   * GET /api/progress/:userId/weak-areas
   * Get user's weak areas
   */
  router.get('/progress/:userId/weak-areas', (req, res) =>
    progressController.getWeakAreas(req, res)
  );

  // ============================================================================
  // Health Check
  // ============================================================================

  /**
   * GET /api/health
   * Health check endpoint
   */
  router.get('/health', (req, res) => {
    res.json({
      success: true,
      data: {
        status: 'healthy',
        timestamp: new Date(),
        version: '1.0.0',
      },
    });
  });

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\auth.routes.ts
==============================

// src/routes/auth.routes.ts - UPDATE with OAuth routes
import express, { Router } from 'express';
import passport from 'passport';
import { AuthController } from '../controllers/auth.controller';
import { authenticate } from '../middleware/auth.middleware';
import { authRateLimiter } from '../middleware/rate-limit.middleware';
import { validate } from '../middleware/validation.middleware';
import {
  registerSchema,
  loginSchema,
  passwordResetRequestSchema,
  passwordResetConfirmSchema,
} from '../utils/validation';

export function createAuthRoutes(): Router {
  const router = express.Router();
  const authController = new AuthController();

  // ============================================================================
  // Email/Password Authentication
  // ============================================================================

  router.post(
    '/register',
    authRateLimiter,
    validate(registerSchema),
    (req, res) => authController.register(req, res),
  );

  router.post('/login', authRateLimiter, validate(loginSchema), (req, res) =>
    authController.login(req, res),
  );

  router.post('/refresh', (req, res) => authController.refreshToken(req, res));

  router.post('/logout', authenticate, (req, res) =>
    authController.logout(req, res),
  );

  router.get('/verify-email', (req, res) =>
    authController.verifyEmail(req, res),
  );

  router.post(
    '/forgot-password',
    authRateLimiter,
    validate(passwordResetRequestSchema),
    (req, res) => authController.requestPasswordReset(req, res),
  );

  router.post(
    '/reset-password',
    validate(passwordResetConfirmSchema),
    (req, res) => authController.resetPassword(req, res),
  );

  router.get('/me', authenticate, (req, res) =>
    authController.getCurrentUser(req, res),
  );

  // ============================================================================
  // OAuth - Google
  // ============================================================================

  /**
   * GET /api/auth/google
   * Initiate Google OAuth flow
   */
  router.get(
    '/google',
    passport.authenticate('google', {
      scope: ['profile', 'email'],
      session: false,
    }),
  );

  /**
   * GET /api/auth/google/callback
   * Google OAuth callback
   */
  router.get(
    '/google/callback',
    passport.authenticate('google', {
      session: false,
      failureRedirect: `${process.env.FRONTEND_URL}/login?error=google_failed`,
    }),
    (req, res) => authController.oauthCallback(req, res),
  );

  // ============================================================================
  // OAuth - GitHub
  // ============================================================================

  /**
   * GET /api/auth/github
   * Initiate GitHub OAuth flow
   */
  router.get(
    '/github',
    passport.authenticate('github', {
      scope: ['user:email'],
      session: false,
    }),
  );

  /**
   * GET /api/auth/github/callback
   * GitHub OAuth callback
   */
  router.get(
    '/github/callback',
    passport.authenticate('github', {
      session: false,
      failureRedirect: `${process.env.FRONTEND_URL}/login?error=github_failed`,
    }),
    (req, res) => authController.oauthCallback(req, res),
  );

  // ============================================================================
  // OAuth Account Management
  // ============================================================================

  /**
   * POST /api/auth/oauth/link
   * Link OAuth account to current user
   */
  router.post('/oauth/link', authenticate, (req, res) =>
    authController.linkOAuthAccount(req, res),
  );

  /**
   * DELETE /api/auth/oauth/unlink
   * Unlink OAuth account from current user
   */
  router.delete('/oauth/unlink', authenticate, (req, res) =>
    authController.unlinkOAuthAccount(req, res),
  );

  /**
   * POST /api/auth/set-password
   * Set password for OAuth-only users
   */
  router.post('/set-password', authenticate, (req, res) =>
    authController.setPassword(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\company.routes.ts
==============================

// src/routes/company.routes.ts
import express, { Router } from 'express';
import { CompanyController } from '../controllers/company.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createCompanyRoutes(): Router {
  const router = express.Router();
  const controller = new CompanyController();
  const userRateLimit = createUserRateLimiter();

  /**
   * GET /api/companies
   * Get all companies
   */
  router.get('/', (req, res) => controller.getAllCompanies(req, res));

  /**
   * GET /api/companies/recommended
   * Get recommended companies (requires auth)
   */
  router.get('/recommended', authenticate, userRateLimit, (req, res) =>
    controller.getRecommendedCompanies(req, res),
  );

  /**
   * GET /api/companies/:slug
   * Get company details
   */
  router.get('/:slug', (req, res) => controller.getCompany(req, res));

  /**
   * GET /api/companies/:slug/questions
   * Get company questions
   */
  router.get('/:slug/questions', (req, res) =>
    controller.getCompanyQuestions(req, res),
  );

  /**
   * GET /api/companies/:slug/statistics
   * Get company statistics
   */
  router.get('/:slug/statistics', (req, res) =>
    controller.getCompanyStatistics(req, res),
  );

  /**
   * GET /api/companies/:slug/progress
   * Get user's company progress (requires auth)
   */
  router.get('/:slug/progress', authenticate, userRateLimit, (req, res) =>
    controller.getUserCompanyProgress(req, res),
  );

  /**
   * POST /api/companies/:slug/practice
   * Start company-specific practice (requires auth)
   */
  router.post('/:slug/practice', authenticate, userRateLimit, (req, res) =>
    controller.startCompanyPractice(req, res),
  );

  /**
   * POST /api/companies/:slug/experience
   * Add interview experience (requires auth)
   */
  router.post('/:slug/experience', authenticate, userRateLimit, (req, res) =>
    controller.addInterviewExperience(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\file-upload.routes.ts
==============================

// src/routes/file-upload.routes.ts
import express, { Router } from 'express';
import { FileUploadController } from '../controllers/file-upload.controller';
import { authenticate } from '../middleware/auth.middleware';
import {
  uploadSingle,
  handleUploadError,
} from '../middleware/upload.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createFileUploadRoutes(): Router {
  const router = express.Router();
  const controller = new FileUploadController();
  const userRateLimit = createUserRateLimiter();

  // All routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * POST /api/files/upload
   * Upload a file
   */
  router.post('/upload', uploadSingle('file'), handleUploadError, (req, res) =>
    controller.uploadFile(req, res),
  );

  /**
   * GET /api/files
   * Get user's files
   */
  router.get('/', (req, res) => controller.getUserFiles(req, res));

  /**
   * DELETE /api/files/:fileId
   * Delete a file
   */
  router.delete('/:fileId', (req, res) => controller.deleteFile(req, res));

  /**
   * GET /api/files/:fileId/url
   * Get signed URL for file
   */
  router.get('/:fileId/url', (req, res) => controller.getSignedUrl(req, res));

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\gamification.routes.ts
==============================

// src/routes/gamification.routes.ts
import express, { Router } from 'express';
import { GamificationController } from '../controllers/gamification.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createGamificationRoutes(): Router {
  const router = express.Router();
  const controller = new GamificationController();
  const userRateLimit = createUserRateLimiter();

  // All routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * GET /api/gamification/achievements
   * Get user achievements
   */
  router.get('/achievements', (req, res) =>
    controller.getAchievements(req, res),
  );

  /**
   * GET /api/gamification/leaderboard
   * Get leaderboard
   */
  router.get('/leaderboard', (req, res) => controller.getLeaderboard(req, res));

  /**
   * POST /api/gamification/daily-goal
   * Update daily goal progress
   */
  router.post('/daily-goal', (req, res) =>
    controller.updateDailyGoal(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\interview.routes.ts
==============================

// src/routes/interview.routes.ts - UPDATE existing with new endpoints
import express, { Router } from 'express';
import { InterviewController } from '../controllers/interview.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createInterviewRoutes(controller: InterviewController): Router {
  const router = express.Router();
  const userRateLimit = createUserRateLimiter();

  // All routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * POST /api/interview/start
   * Start new interview session
   */
  router.post('/start', (req, res) => controller.startInterview(req, res));

  /**
   * POST /api/interview/answer
   * Submit answer to question
   */
  router.post('/answer', (req, res) => controller.submitAnswer(req, res));

  /**
   * GET /api/interview/:sessionId
   * Get session status
   */
  router.get('/:sessionId', (req, res) =>
    controller.getSessionStatus(req, res),
  );

  /**
   * GET /api/interview/:sessionId/hint
   * Request hint
   */
  router.get('/:sessionId/hint', (req, res) =>
    controller.requestHint(req, res),
  );

  /**
   * POST /api/interview/:sessionId/pause
   * Pause session
   */
  router.post('/:sessionId/pause', (req, res) =>
    controller.pauseSession(req, res),
  );

  /**
   * POST /api/interview/:sessionId/resume
   * Resume session
   */
  router.post('/:sessionId/resume', (req, res) =>
    controller.resumeSession(req, res),
  );

  // ============================================================================
  // NEW ENDPOINTS - Timer
  // ============================================================================

  /**
   * GET /api/interview/:sessionId/timer
   * Get timer status
   */
  router.get('/:sessionId/timer', (req, res) =>
    controller.getTimerStatus(req, res),
  );

  /**
   * POST /api/interview/:sessionId/timer/pause
   * Pause timer
   */
  router.post('/:sessionId/timer/pause', (req, res) =>
    controller.pauseTimer(req, res),
  );

  /**
   * POST /api/interview/:sessionId/timer/resume
   * Resume timer
   */
  router.post('/:sessionId/timer/resume', (req, res) =>
    controller.resumeTimer(req, res),
  );

  // ============================================================================
  // NEW ENDPOINTS - Replay
  // ============================================================================

  /**
   * GET /api/interview/:sessionId/replay
   * Get interview replay
   */
  router.get('/:sessionId/replay', (req, res) =>
    controller.getReplay(req, res),
  );

  /**
   * POST /api/interview/replay/:replayId/progress
   * Update replay progress
   */
  router.post('/replay/:replayId/progress', (req, res) =>
    controller.updateReplayProgress(req, res),
  );

  /**
   * GET /api/interview/replay/history
   * Get replay history
   */
  router.get('/replay/history', (req, res) =>
    controller.getReplayHistory(req, res),
  );

  /**
   * GET /api/interview/compare
   * Compare two interview attempts
   */
  router.get('/compare', (req, res) => controller.compareAttempts(req, res));

  // ============================================================================
  // NEW ENDPOINTS - Question Rating
  // ============================================================================

  /**
   * POST /api/interview/questions/:questionId/rate
   * Rate question difficulty
   */
  router.post('/questions/:questionId/rate', (req, res) =>
    controller.rateQuestion(req, res),
  );

  /**
   * GET /api/interview/questions/:questionId/ratings
   * Get question ratings
   */
  router.get('/questions/:questionId/ratings', (req, res) =>
    controller.getQuestionRatings(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\learning-path.routes.ts
==============================

// src/routes/learning-path.routes.ts
import express, { Router } from 'express';
import { LearningPathController } from '../controllers/learning-path.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createLearningPathRoutes(): Router {
  const router = express.Router();
  const controller = new LearningPathController();
  const userRateLimit = createUserRateLimiter();

  // All routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * POST /api/learning-path/generate
   * Generate personalized learning path
   */
  router.post('/generate', (req, res) => controller.generatePath(req, res));

  /**
   * GET /api/learning-path
   * Get current learning path
   */
  router.get('/', (req, res) => controller.getPath(req, res));

  /**
   * POST /api/learning-path/topics/:topicId/complete
   * Mark topic as completed
   */
  router.post('/topics/:topicId/complete', (req, res) =>
    controller.completeTopic(req, res),
  );

  /**
   * PATCH /api/learning-path/topics/:topicId/progress
   * Update topic progress
   */
  router.patch('/topics/:topicId/progress', (req, res) =>
    controller.updateTopicProgress(req, res),
  );

  /**
   * GET /api/learning-path/recommendations
   * Get personalized recommendations
   */
  router.get('/recommendations', (req, res) =>
    controller.getRecommendations(req, res),
  );

  /**
   * POST /api/learning-path/recommendations/generate
   * Generate fresh recommendations
   */
  router.post('/recommendations/generate', (req, res) =>
    controller.generateRecommendations(req, res),
  );

  /**
   * POST /api/learning-path/recommendations/:recommendationId/complete
   * Mark recommendation as completed
   */
  router.post('/recommendations/:recommendationId/complete', (req, res) =>
    controller.completeRecommendation(req, res),
  );

  /**
   * GET /api/learning-path/reviews
   * Get spaced repetition reviews
   */
  router.get('/reviews', (req, res) => controller.getDueReviews(req, res));

  /**
   * POST /api/learning-path/reviews/:itemId
   * Record spaced repetition review
   */
  router.post('/reviews/:itemId', (req, res) =>
    controller.recordReview(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\topic.routes.ts
==============================

// src/routes/topic.routes.ts
import express, { Router } from 'express';
import { TopicController } from '../controllers/topic.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createTopicRoutes(): Router {
  const router = express.Router();
  const controller = new TopicController();
  const userRateLimit = createUserRateLimiter();

  /**
   * GET /api/topics
   * Get all topics
   */
  router.get('/', (req, res) => controller.getAllTopics(req, res));

  /**
   * GET /api/topics/tree
   * Get topic tree (hierarchy)
   */
  router.get('/tree', (req, res) => controller.getTopicTree(req, res));

  /**
   * GET /api/topics/recommended
   * Get recommended topics (requires auth)
   */
  router.get('/recommended', authenticate, userRateLimit, (req, res) =>
    controller.getRecommendedTopics(req, res),
  );

  /**
   * GET /api/topics/mastery
   * Get user's mastery overview (requires auth)
   */
  router.get('/mastery', authenticate, userRateLimit, (req, res) =>
    controller.getMasteryOverview(req, res),
  );

  /**
   * GET /api/topics/:slug
   * Get topic details
   */
  router.get('/:slug', (req, res) => controller.getTopic(req, res));

  /**
   * GET /api/topics/:slug/questions
   * Get topic questions
   */
  router.get('/:slug/questions', (req, res) =>
    controller.getTopicQuestions(req, res),
  );

  /**
   * GET /api/topics/:slug/statistics
   * Get topic statistics
   */
  router.get('/:slug/statistics', (req, res) =>
    controller.getTopicStatistics(req, res),
  );

  /**
   * GET /api/topics/:slug/progress
   * Get user's topic progress (requires auth)
   */
  router.get('/:slug/progress', authenticate, userRateLimit, (req, res) =>
    controller.getUserTopicProgress(req, res),
  );

  /**
   * POST /api/topics/:slug/practice
   * Start topic-specific practice (requires auth)
   */
  router.post('/:slug/practice', authenticate, userRateLimit, (req, res) =>
    controller.startTopicPractice(req, res),
  );

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\routes\user.routes.ts
==============================

// src/routes/user.routes.ts
import express, { Router } from 'express';
import { UserController } from '../controllers/user.controller';
import { authenticate } from '../middleware/auth.middleware';
import { createUserRateLimiter } from '../middleware/rate-limit.middleware';

export function createUserRoutes(): Router {
  const router = express.Router();
  const userController = new UserController();
  const userRateLimit = createUserRateLimiter();

  // All user routes require authentication
  router.use(authenticate);
  router.use(userRateLimit);

  /**
   * PATCH /api/user/profile
   * Update user profile
   */
  router.patch('/profile', (req, res) =>
    userController.updateProfile(req, res),
  );

  /**
   * POST /api/user/change-password
   * Change password
   */
  router.post('/change-password', (req, res) =>
    userController.changePassword(req, res),
  );

  /**
   * GET /api/user/login-history
   * Get login history
   */
  router.get('/login-history', (req, res) =>
    userController.getLoginHistory(req, res),
  );

  /**
   * GET /api/user/preferences
   * Get user preferences
   */
  router.get('/preferences', (req, res) =>
    userController.getPreferences(req, res),
  );

  /**
   * PATCH /api/user/preferences
   * Update user preferences
   */
  router.patch('/preferences', (req, res) =>
    userController.updatePreferences(req, res),
  );

  /**
   * DELETE /api/user/account
   * Delete user account
   */
  router.delete('/account', (req, res) =>
    userController.deleteAccount(req, res),
  );

  /**
   * GET /api/user/export
   * Export all user data (GDPR)
   */
  router.get('/export', (req, res) => userController.exportData(req, res));

  return router;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\server.ts
==============================

/**
 * Server Entry Point
 * Initializes and starts the Express server
 */

import dotenv from 'dotenv';
import { createApp } from './app';
import { LLMProviderFactory } from './services/llm/provider-factory';
import { PineconeVectorDatabase } from './services/vector-db/pinecone-db';
import { IVectorDatabase } from './services/vector-db/base-vector-db';
import { RouterStrategy } from './types';

import { startAutoUnsuspendJob } from './jobs/auto-unsuspend.job';


// Load environment variables
dotenv.config();

/**
 * Initialize server
 */
async function startServer() {
  try {
    console.log('üöÄ Starting AI Interview Coach...');

    // ============================================================================
    // Initialize LLM Provider
    // ============================================================================

    console.log('Initializing LLM provider...');
    const llmProvider = LLMProviderFactory.initializeFromEnv();
    const isAvailable = await llmProvider.isAvailable();

    if (!isAvailable) {
      throw new Error(
        `LLM provider ${llmProvider.name} is not available. Check your API key.`,
      );
    }

    console.log(`‚úÖ LLM Provider: ${llmProvider.name}`);

    // ============================================================================
    // Initialize Vector Database (Optional)
    // ============================================================================

    let vectorDb: IVectorDatabase | undefined = undefined;
    const vectorDbProvider = process.env.VECTOR_DB_PROVIDER;

    if (vectorDbProvider === 'pinecone') {
      console.log('Initializing Pinecone...');
      try {
        const pineconeApiKey = process.env.PINECONE_API_KEY;
        const indexName = process.env.PINECONE_INDEX_NAME || 'interview-coach';
        const namespace = process.env.PINECONE_NAMESPACE || 'default';
        const cloud = process.env.PINECONE_CLOUD || 'aws';
        const region = process.env.PINECONE_REGION || 'us-east-1';

        if (!pineconeApiKey) {
          throw new Error(
            'PINECONE_API_KEY not found in environment variables',
          );
        }

        vectorDb = new PineconeVectorDatabase(
          {
            indexName,
            namespace,
            cloud,
            region,
            embeddingDimension: 1536,
          },
          pineconeApiKey,
        );

        await vectorDb.initialize({
          indexName,
          namespace,
          cloud,
          region,
        });

        const isReady = await vectorDb.isReady();

        if (isReady) {
          console.log('‚úÖ Vector Database: Pinecone');
          console.log(`   Index: ${indexName}`);
          console.log(`   Namespace: ${namespace}`);
        } else {
          console.warn(
            '‚ö†Ô∏è  Pinecone initialized but not ready. RAG features may be limited.',
          );
        }
      } catch (error) {
        console.warn(
          '‚ö†Ô∏è  Pinecone initialization failed. Continuing without vector search.',
        );
        console.warn(
          '   Error:',
          error instanceof Error ? error.message : error,
        );
        console.warn(
          '   Make sure you have set PINECONE_API_KEY in your .env file',
        );
        vectorDb = undefined;
      }
    } else {
      console.log('‚ö†Ô∏è  Vector database not configured. RAG features disabled.');
      console.log('   Set VECTOR_DB_PROVIDER=pinecone in .env to enable.');
    }

    // ============================================================================
    // Create Application
    // ============================================================================

    console.log('Creating Express application...');

    const routingStrategy =
      (process.env.ROUTING_STRATEGY as RouterStrategy) || RouterStrategy.HYBRID;

    const app = createApp({
      llmProvider,
      vectorDb,
      routingStrategy,
    });

    // ============================================================================
    // Start Server
    // ============================================================================

    const PORT = parseInt(process.env.PORT || '3000');

    app.listen(PORT, () => {
      console.log('');
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      console.log('  üéØ AI Interview Coach API Server');
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      console.log('');
      console.log(`  ‚ûú Server:      http://localhost:${PORT}`);
      console.log(`  ‚ûú Health:      http://localhost:${PORT}/api/health`);
      console.log(`  ‚ûú Docs:        http://localhost:${PORT}/`);
      console.log('');
      console.log('  Configuration:');
      console.log(`    ‚Ä¢ LLM:       ${llmProvider.name}`);
      console.log(`    ‚Ä¢ Vector DB: ${vectorDb ? 'Pinecone' : 'Disabled'}`);
      console.log(`    ‚Ä¢ Routing:   ${routingStrategy}`);
      console.log(`    ‚Ä¢ Env:       ${process.env.NODE_ENV || 'development'}`);
      console.log('');
      console.log('  Available Endpoints:');
      console.log('    POST /api/query');
      console.log('    POST /api/interview/start');
      console.log('    POST /api/interview/answer');
      console.log('    POST /api/resume/review');
      console.log('    GET  /api/progress/:userId');
      console.log('');
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      console.log('');
      console.log('  Press Ctrl+C to stop');
      console.log('');
    });

    // Start scheduled jobs
    startAutoUnsuspendJob();

    // ============================================================================
    // Graceful Shutdown
    // ============================================================================

    process.on('SIGTERM', async () => {
      console.log('\n\nüõë Shutting down gracefully...');

      // Close vector DB if configured
      if (vectorDb) {
        await vectorDb.close();
      }

      console.log('‚úÖ Goodbye!');
      process.exit(0);
    });
  } catch (error) {
    console.error('‚ùå Failed to start server:');
    console.error(error);
    process.exit(1);
  }
}

// Start the server
startServer();


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\adaptive-interview.service.ts
==============================

// src/services/adaptive-interview.service.ts
import prisma from '../config/database';
import { QuestionBankService } from './question-bank.service';
import {
  Difficulty,
  QuestionCategory,
  InterviewType,
  DeveloperRole,
} from '@prisma/client';

export class AdaptiveInterviewService {
  private questionBankService: QuestionBankService;

  constructor() {
    this.questionBankService = new QuestionBankService();
  }

  /**
   * Get next question based on user performance
   */
  async getNextAdaptiveQuestion(sessionId: string) {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
      include: { questions: true },
    });

    if (!session) {
      throw new Error('Session not found');
    }

    // Calculate current performance
    const answeredQuestions = session.questions.filter((q) => q.score !== null);

    if (answeredQuestions.length === 0) {
      // First question - start with medium
      return this.getQuestionByDifficulty(
        session.type,
        session.role || undefined,
        'MEDIUM',
      );
    }

    const recentScores = answeredQuestions
      .slice(-3)
      .map((q) => Number(q.score));

    const avgRecentScore =
      recentScores.reduce((a, b) => a + b, 0) / recentScores.length;

    // Determine next difficulty
    let nextDifficulty: Difficulty;

    if (avgRecentScore >= 85) {
      // Excellent performance - increase difficulty
      nextDifficulty = this.increaseDifficulty(session.difficulty || 'MEDIUM');
    } else if (avgRecentScore < 60) {
      // Poor performance - decrease difficulty
      nextDifficulty = this.decreaseDifficulty(session.difficulty || 'MEDIUM');
    } else {
      // Maintain current difficulty
      nextDifficulty = session.difficulty || 'MEDIUM';
    }

    // Update session difficulty
    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: { difficulty: nextDifficulty },
    });

    return this.getQuestionByDifficulty(
      session.type,
      session.role || undefined,
      nextDifficulty,
    );
  }

  /**
   * Get question by difficulty
   */
  private async getQuestionByDifficulty(
    type: InterviewType,
    role: DeveloperRole | undefined,
    difficulty: Difficulty,
  ) {
    return this.questionBankService.generateQuestions({
      type,
      role,
      difficulty,
      duration: 15,
      questionCount: 1,
    });
  }

  /**
   * Increase difficulty level
   */
  private increaseDifficulty(current: Difficulty): Difficulty {
    if (current === 'EASY') return 'MEDIUM';
    if (current === 'MEDIUM') return 'HARD';
    return 'HARD';
  }

  /**
   * Decrease difficulty level
   */
  private decreaseDifficulty(current: Difficulty): Difficulty {
    if (current === 'HARD') return 'MEDIUM';
    if (current === 'MEDIUM') return 'EASY';
    return 'EASY';
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\admin\admin-user.service.ts
==============================

// src/services/admin/admin-user.service.ts
import prisma from '../../config/database';
import { UserRole, AdminActionType, Prisma } from '@prisma/client';
import bcrypt from 'bcrypt';

interface UserFilters {
  search?: string;
  role?: UserRole;
  status?: 'active' | 'banned' | 'suspended' | 'inactive';
  emailVerified?: boolean;
  dateFrom?: Date;
  dateTo?: Date;
  isSuspicious?: boolean;
  page?: number;
  limit?: number;
  sortBy?: 'createdAt' | 'lastLogin' | 'email' | 'name';
  sortOrder?: 'asc' | 'desc';
}

export class AdminUserService {
  /**
   * Get users with advanced filters and pagination
   */
  async getUsers(filters: UserFilters) {
    const {
      search,
      role,
      status,
      emailVerified,
      dateFrom,
      dateTo,
      isSuspicious,
      page = 1,
      limit = 50,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = filters;

    const where: Prisma.UserWhereInput = {};

    // Search by email or name
    if (search) {
      where.OR = [
        { email: { contains: search, mode: 'insensitive' } },
        { name: { contains: search, mode: 'insensitive' } },
      ];
    }

    // Filter by role
    if (role) {
      where.role = role;
    }

    // Filter by status
    if (status === 'banned') {
      where.isBanned = true;
    } else if (status === 'suspended') {
      where.isSuspended = true;
    } else if (status === 'inactive') {
      where.isActive = false;
    } else if (status === 'active') {
      where.isActive = true;
      where.isBanned = false;
      where.isSuspended = false;
    }

    // Filter by email verification
    if (emailVerified !== undefined) {
      where.emailVerified = emailVerified;
    }

    // Filter by date range
    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) where.createdAt.gte = dateFrom;
      if (dateTo) where.createdAt.lte = dateTo;
    }

    // Filter suspicious users
    if (isSuspicious !== undefined) {
      where.isSuspicious = isSuspicious;
    }

    // Get total count
    const total = await prisma.user.count({ where });

    // Get paginated users
    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        emailVerified: true,
        isActive: true,
        isBanned: true,
        isSuspended: true,
        isSuspicious: true,
        createdAt: true,
        lastLogin: true,
        profilePicture: true,
        bannedAt: true,
        suspendedUntil: true,
        _count: {
          select: {
            interviewSessions: true,
            achievements: true,
          },
        },
      },
      orderBy: { [sortBy]: sortOrder },
      skip: (page - 1) * limit,
      take: limit,
    });

    return {
      users,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * Get complete user details for admin
   */
  async getUserDetails(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        refreshTokens: {
          where: { revoked: false },
          select: {
            id: true,
            createdAt: true,
            expiresAt: true,
          },
        },
        interviewSessions: {
          select: {
            id: true,
            type: true,
            status: true,
            score: true,
            startTime: true,
            endTime: true,
          },
          orderBy: { startTime: 'desc' },
          take: 10,
        },
        loginHistory: {
          orderBy: { createdAt: 'desc' },
          take: 20,
        },
        userProgress: true,
        weakAreas: {
          orderBy: { failureCount: 'desc' },
          take: 5,
        },
        preferences: true,
        achievements: {
          include: {
            achievement: true,
          },
          orderBy: { unlockedAt: 'desc' },
          take: 10,
        },
        bans: {
          orderBy: { createdAt: 'desc' },
          take: 5,
        },
        suspensions: {
          orderBy: { createdAt: 'desc' },
          take: 5,
        },
      },
    });

    if (!user) {
      throw new Error('User not found');
    }

    // Get user statistics
    const stats = await this.getUserStatistics(userId);

    // Get recent activity
    const recentActivity = await prisma.userActivityLog.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 50,
    });

    return {
      user,
      stats,
      recentActivity,
    };
  }

  /**
   * Get user statistics
   */
  async getUserStatistics(userId: string) {
    const [
      totalInterviews,
      completedInterviews,
      avgScore,
      totalTimeSpent,
      questionsSolved,
      currentStreak,
    ] = await Promise.all([
      prisma.interviewSession.count({ where: { userId } }),
      prisma.interviewSession.count({ where: { userId, status: 'COMPLETED' } }),
      prisma.interviewSession.aggregate({
        where: { userId, score: { not: null } },
        _avg: { score: true },
      }),
      prisma.studySession.aggregate({
        where: { userId },
        _sum: { durationMinutes: true },
      }),
      prisma.userProgress.findUnique({
        where: { userId },
        select: { problemsSolved: true, currentStreak: true },
      }),
    ]);

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { createdAt: true, lastLogin: true },
    });

    const accountAge = user
      ? Math.floor(
          (Date.now() - user.createdAt.getTime()) / (1000 * 60 * 60 * 24),
        )
      : 0;

    return {
      totalInterviews,
      completedInterviews,
      completionRate:
        totalInterviews > 0 ? (completedInterviews / totalInterviews) * 100 : 0,
      avgScore: avgScore._avg.score ? Number(avgScore._avg.score) : 0,
      totalTimeSpent: totalTimeSpent._sum.durationMinutes || 0,
      questionsSolved: questionsSolved?.problemsSolved || 0,
      currentStreak: questionsSolved?.currentStreak || 0,
      accountAge,
      daysSinceLastLogin: user?.lastLogin
        ? Math.floor(
            (Date.now() - user.lastLogin.getTime()) / (1000 * 60 * 60 * 24),
          )
        : null,
    };
  }

  /**
   * Ban user
   */
  async banUser(
    userId: string,
    adminId: string,
    reason: string,
    isPermanent: boolean = true,
  ) {
    // Create ban record
    await prisma.userBan.create({
      data: {
        userId,
        bannedBy: adminId,
        reason,
        isPermanent,
      },
    });

    // Update user
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        isBanned: true,
        bannedAt: new Date(),
        bannedBy: adminId,
        banReason: reason,
        isActive: false,
      },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_BANNED',
      reason,
      changes: {
        before: { isBanned: false },
        after: { isBanned: true },
      },
    });

    // Revoke all refresh tokens
    await prisma.refreshToken.updateMany({
      where: { userId },
      data: { revoked: true },
    });

    return user;
  }

  /**
   * Unban user
   */
  async unbanUser(userId: string, adminId: string) {
    // Update ban record
    await prisma.userBan.updateMany({
      where: { userId, unbannedAt: null },
      data: {
        unbannedAt: new Date(),
        unbannedBy: adminId,
      },
    });

    // Update user
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        isBanned: false,
        bannedAt: null,
        bannedBy: null,
        banReason: null,
        isActive: true,
      },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_UNBANNED',
      changes: {
        before: { isBanned: true },
        after: { isBanned: false },
      },
    });

    return user;
  }

  /**
   * Suspend user
   */
  async suspendUser(
    userId: string,
    adminId: string,
    reason: string,
    durationHours: number,
  ) {
    const expiresAt = new Date(Date.now() + durationHours * 60 * 60 * 1000);

    // Create suspension record
    await prisma.userSuspension.create({
      data: {
        userId,
        suspendedBy: adminId,
        reason,
        duration: durationHours,
        expiresAt,
      },
    });

    // Update user
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        isSuspended: true,
        suspendedUntil: expiresAt,
        suspendedBy: adminId,
        suspensionReason: reason,
      },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_SUSPENDED',
      reason,
      changes: {
        before: { isSuspended: false },
        after: { isSuspended: true, suspendedUntil: expiresAt },
      },
    });

    return user;
  }

  /**
   * Unsuspend user
   */
  async unsuspendUser(userId: string, adminId: string) {
    // Update suspension record
    await prisma.userSuspension.updateMany({
      where: { userId, endedAt: null },
      data: {
        endedAt: new Date(),
        endedBy: adminId,
      },
    });

    // Update user
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        isSuspended: false,
        suspendedUntil: null,
        suspendedBy: null,
        suspensionReason: null,
      },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_UNSUSPENDED',
      changes: {
        before: { isSuspended: true },
        after: { isSuspended: false },
      },
    });

    return user;
  }

  /**
   * Change user role
   */
  async changeUserRole(userId: string, adminId: string, newRole: UserRole) {
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user) throw new Error('User not found');

    const oldRole = user.role;

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { role: newRole },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_ROLE_CHANGED',
      changes: {
        before: { role: oldRole },
        after: { role: newRole },
      },
    });

    return updatedUser;
  }

  /**
   * Reset user password (admin action)
   */
  async resetUserPassword(
    userId: string,
    adminId: string,
    newPassword: string,
  ) {
    const passwordHash = await bcrypt.hash(newPassword, 12);

    const user = await prisma.user.update({
      where: { id: userId },
      data: { passwordHash },
    });

    // Revoke all refresh tokens
    await prisma.refreshToken.updateMany({
      where: { userId },
      data: { revoked: true },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_PASSWORD_RESET',
    });

    return user;
  }

  /**
   * Delete user (admin action)
   */
  async deleteUser(userId: string, adminId: string, reason: string) {
    // Get user data before deletion
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { email: true, name: true, role: true },
    });

    // Delete user (cascade will handle related data)
    await prisma.user.delete({
      where: { id: userId },
    });

    // Log admin action
    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'USER_DELETED',
      reason,
      metadata: { deletedUser: user },
    });

    return { success: true, deletedUser: user };
  }

  /**
   * Update admin notes
   */
  async updateAdminNotes(userId: string, adminId: string, notes: string) {
    const user = await prisma.user.update({
      where: { id: userId },
      data: { adminNotes: notes },
    });

    return user;
  }

  /**
   * Mark user as suspicious
   */
  async markSuspicious(userId: string, adminId: string, isSuspicious: boolean) {
    const user = await prisma.user.update({
      where: { id: userId },
      data: { isSuspicious },
    });

    await this.logAdminAction({
      adminId,
      targetUserId: userId,
      targetType: 'USER',
      action: 'OTHER',
      metadata: { action: 'mark_suspicious', isSuspicious },
    });

    return user;
  }

  /**
   * Get user activity timeline
   */
  async getUserActivity(userId: string, limit: number = 50) {
    const activities = await prisma.userActivityLog.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });

    return activities;
  }

  /**
   * Export user data (GDPR)
   */
  async exportUserData(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        interviewSessions: true,
        userProgress: true,
        weakAreas: true,
        preferences: true,
        loginHistory: true,
        achievements: {
          include: { achievement: true },
        },
      },
    });

    return user;
  }

  /**
   * Bulk ban users
   */
  async bulkBanUsers(userIds: string[], adminId: string, reason: string) {
    const operation = await prisma.bulkOperation.create({
      data: {
        adminId,
        operationType: 'BAN_USERS',
        userIds: userIds,
        totalCount: userIds.length,
        action: 'USER_BANNED',
        parameters: { reason },
        status: 'PROCESSING',
      },
    });

    let successCount = 0;
    let failureCount = 0;
    const results: any[] = [];

    for (const userId of userIds) {
      try {
        await this.banUser(userId, adminId, reason, true);
        successCount++;
        results.push({ userId, success: true });
      } catch (error) {
        failureCount++;
        results.push({
          userId,
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    }

    await prisma.bulkOperation.update({
      where: { id: operation.id },
      data: {
        status: 'COMPLETED',
        successCount,
        failureCount,
        completedAt: new Date(),
        results,
      },
    });

    return {
      operationId: operation.id,
      successCount,
      failureCount,
      results,
    };
  }

  /**
   * Log admin action
   */
  private async logAdminAction(data: {
    adminId: string;
    targetUserId?: string;
    targetType: any;
    targetId?: string;
    action: any;
    reason?: string;
    changes?: any;
    metadata?: any;
    ipAddress?: string;
    userAgent?: string;
  }) {
    return prisma.adminAction.create({
      data: {
        adminId: data.adminId,
        targetUserId: data.targetUserId,
        targetType: data.targetType,
        targetId: data.targetId,
        action: data.action,
        reason: data.reason,
        changes: data.changes as any,
        metadata: data.metadata as any,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent,
      },
    });
  }

  /**
   * Get admin actions (audit log)
   */
  async getAdminActions(filters: {
    adminId?: string;
    targetUserId?: string;
    action?: AdminActionType;
    dateFrom?: Date;
    dateTo?: Date;
    page?: number;
    limit?: number;
  }) {
    const {
      adminId,
      targetUserId,
      action,
      dateFrom,
      dateTo,
      page = 1,
      limit = 50,
    } = filters;

    const where: Prisma.AdminActionWhereInput = {};

    if (adminId) where.adminId = adminId;
    if (targetUserId) where.targetUserId = targetUserId;
    if (action) where.action = action;

    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) where.createdAt.gte = dateFrom;
      if (dateTo) where.createdAt.lte = dateTo;
    }

    const [total, actions] = await Promise.all([
      prisma.adminAction.count({ where }),
      prisma.adminAction.findMany({
        where,
        include: {
          admin: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          targetUser: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return {
      actions,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * Get dashboard statistics
   */
  async getDashboardStats() {
    const [
      totalUsers,
      newUsersToday,
      newUsersThisWeek,
      activeUsers,
      bannedUsers,
      suspendedUsers,
      freeUsers,
      premiumUsers,
      adminUsers,
    ] = await Promise.all([
      prisma.user.count(),
      prisma.user.count({
        where: {
          createdAt: {
            gte: new Date(new Date().setHours(0, 0, 0, 0)),
          },
        },
      }),
      prisma.user.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
          },
        },
      }),
      prisma.user.count({ where: { isActive: true } }),
      prisma.user.count({ where: { isBanned: true } }),
      prisma.user.count({ where: { isSuspended: true } }),
      prisma.user.count({ where: { role: 'FREE' } }),
      prisma.user.count({ where: { role: 'PREMIUM' } }),
      prisma.user.count({ where: { role: 'ADMIN' } }),
    ]);

    return {
      totalUsers,
      newUsersToday,
      newUsersThisWeek,
      activeUsers,
      bannedUsers,
      suspendedUsers,
      byRole: {
        free: freeUsers,
        premium: premiumUsers,
        admin: adminUsers,
      },
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\ai-question-generator.service.ts
==============================

// src/services/ai-question-generator.service.ts
import { ILLMProvider } from './llm/base-provider';
import prisma from '../config/database';
import {
  GenerationType,
  Difficulty,
  QuestionCategory,
  QuestionStatus,
  Prisma,
} from '@prisma/client';

interface GenerationConfig {
  generationType: GenerationType;
  baseQuestionId?: string;
  topicId?: string;
  companyId?: string;
  difficulty?: Difficulty;
  category?: QuestionCategory;
  count?: number;
  parameters?: {
    focus?: string[];
    style?: 'interview' | 'practice' | 'competitive';
    includeTestCases?: boolean;
    includeExplanation?: boolean;
    language?: string;
  };
}

interface GeneratedQuestion {
  question: string;
  description?: string;
  difficulty: Difficulty;
  category: QuestionCategory;
  subcategory?: string;
  hints: string[];
  solution: string;
  sampleCode: string;
  explanation: string;
  testCases: TestCase[];
  timeComplexity: string;
  spaceComplexity: string;
}

interface TestCase {
  input: any;
  expectedOutput: any;
  explanation?: string;
}

export class AIQuestionGeneratorService {
  constructor(private llmProvider: ILLMProvider) {}

  /**
   * Main entry point: Generate questions based on configuration
   */
  async generateQuestions(
    userId: string,
    config: GenerationConfig,
  ): Promise<string[]> {
    // Create generation request
    const request = await prisma.questionGenerationRequest.create({
      data: {
        userId,
        generationType: config.generationType,
        baseQuestionId: config.baseQuestionId,
        topicId: config.topicId,
        companyId: config.companyId,
        difficulty: config.difficulty,
        category: config.category,
        count: config.count || 1,
        parameters: config.parameters as any,
        status: 'PROCESSING',
      },
    });

    const startTime = Date.now();

    try {
      const questions: string[] = [];

      for (let i = 0; i < (config.count || 1); i++) {
        const generatedQuestion = await this.generateSingleQuestion(config);

        if (generatedQuestion) {
          // Save to database
          const savedQuestion = await this.saveGeneratedQuestion(
            generatedQuestion,
            config,
            request.id,
          );

          questions.push(savedQuestion.id);
        }
      }

      // Update request status
      await prisma.questionGenerationRequest.update({
        where: { id: request.id },
        data: {
          status: 'COMPLETED',
          generatedQuestions: questions,
          processingTime: Date.now() - startTime,
          completedAt: new Date(),
        },
      });

      return questions;
    } catch (error) {
      // Update request with error
      await prisma.questionGenerationRequest.update({
        where: { id: request.id },
        data: {
          status: 'FAILED',
          errorMessage:
            error instanceof Error ? error.message : 'Unknown error',
          completedAt: new Date(),
        },
      });

      throw error;
    }
  }

  /**
   * Generate a single question
   */
  private async generateSingleQuestion(
    config: GenerationConfig,
  ): Promise<GeneratedQuestion | null> {
    switch (config.generationType) {
      case 'SIMILAR':
        return this.generateSimilarQuestion(config.baseQuestionId!);
      case 'VARIATION':
        return this.generateVariation(config.baseQuestionId!);
      case 'FROM_TOPIC':
        return this.generateFromTopic(config.category!, config.difficulty);
      case 'FROM_COMPANY':
        return this.generateFromCompany(config.companyId!);
      case 'FOLLOW_UP':
        return this.generateFollowUp(config.baseQuestionId!);
      case 'EASIER':
        return this.generateEasierVersion(config.baseQuestionId!);
      case 'HARDER':
        return this.generateHarderVersion(config.baseQuestionId!);
      case 'PERSONALIZED':
        return this.generatePersonalized(config);
      default:
        throw new Error(`Unknown generation type: ${config.generationType}`);
    }
  }

  /**
   * Generate similar question to existing one
   */
  private async generateSimilarQuestion(
    baseQuestionId: string,
  ): Promise<GeneratedQuestion | null> {
    const baseQuestion = await prisma.questionBank.findUnique({
      where: { id: baseQuestionId },
    });

    if (!baseQuestion) {
      throw new Error('Base question not found');
    }

    const prompt = `Generate a similar coding question to the following, but with different constraints and examples:

**Original Question:**
${baseQuestion.question}

**Difficulty:** ${baseQuestion.difficulty}
**Category:** ${baseQuestion.category}

Generate a NEW question that:
1. Tests the same core concept
2. Has different input/output examples
3. Has slightly different constraints
4. Is NOT a direct copy

Provide the response in JSON format:
{
  "question": "Clear problem statement",
  "description": "Detailed description with examples",
  "difficulty": "EASY|MEDIUM|HARD",
  "category": "${baseQuestion.category}",
  "subcategory": "specific topic",
  "hints": ["hint1", "hint2", "hint3"],
  "solution": "Step-by-step solution approach",
  "sampleCode": "Complete working code with comments",
  "explanation": "Why this approach works",
  "testCases": [
    {
      "input": { "param1": value },
      "expectedOutput": value,
      "explanation": "why this test case"
    }
  ],
  "timeComplexity": "O(...)",
  "spaceComplexity": "O(...)"
}`;

    return this.callLLMForGeneration(prompt, baseQuestion.difficulty);
  }

  /**
   * Generate variation of existing question
   */
  private async generateVariation(
    baseQuestionId: string,
  ): Promise<GeneratedQuestion | null> {
    const baseQuestion = await prisma.questionBank.findUnique({
      where: { id: baseQuestionId },
    });

    if (!baseQuestion) {
      throw new Error('Base question not found');
    }

    const prompt = `Create a variation of this coding question by changing ONE aspect:

**Original Question:**
${baseQuestion.question}

Change ONE of these aspects:
- Data structure used (array ‚Üí linked list, tree ‚Üí graph)
- Constraint (sorted ‚Üí unsorted, positive ‚Üí any integer)
- Operation (find ‚Üí count, delete ‚Üí insert)
- Input format

Keep everything else the same. Provide complete solution and test cases in JSON format as before.`;

    return this.callLLMForGeneration(prompt, baseQuestion.difficulty);
  }

  /**
   * Generate question from topic/category
   */
  private async generateFromTopic(
    category: QuestionCategory,
    difficulty?: Difficulty,
  ): Promise<GeneratedQuestion | null> {
    const diff = difficulty || 'MEDIUM';

    const categoryDescriptions: Record<QuestionCategory, string> = {
      ARRAYS: 'array manipulation, two pointers, sliding window',
      STRINGS: 'string processing, pattern matching',
      LINKED_LISTS: 'linked list traversal, manipulation',
      TREES: 'binary trees, BST, tree traversal',
      GRAPHS: 'graph traversal, BFS, DFS, shortest paths',
      DYNAMIC_PROGRAMMING: 'memoization, tabulation, optimization',
      SORTING: 'sorting algorithms, custom comparators',
      SEARCHING: 'binary search, search algorithms',
      HASH_TABLES: 'hashing, hash maps, frequency counting',
      STACKS_QUEUES: 'stack/queue operations, monotonic stacks',
      RECURSION: 'recursive solutions, backtracking',
      GREEDY: 'greedy algorithms, optimization',
      BACKTRACKING: 'exhaustive search with pruning',
      BIT_MANIPULATION: 'bitwise operations',

      // Frontend
      JAVASCRIPT_ES6: 'modern JavaScript, ES6+ features',
      REACT: 'React components, hooks, state management',
      HTML_CSS: 'HTML structure, CSS styling, layouts',
      TYPESCRIPT: 'TypeScript types, interfaces',
      STATE_MANAGEMENT: 'Redux, Context API, state patterns',
      WEB_PERFORMANCE: 'optimization, lazy loading',
      ACCESSIBILITY: 'ARIA, keyboard navigation',
      RESPONSIVE_DESIGN: 'responsive layouts, media queries',
      BROWSER_APIS: 'DOM, localStorage, fetch API',
      WEBPACK_BUNDLING: 'build tools, bundling',
      TESTING_FRONTEND: 'Jest, React Testing Library',
      VUE: 'Vue.js framework',
      ANGULAR: 'Angular framework',

      // Backend
      REST_API_DESIGN: 'RESTful API design principles',
      GRAPHQL: 'GraphQL schemas, queries',
      DATABASE_DESIGN: 'schema design, normalization',
      SQL: 'SQL queries, joins, optimization',
      NOSQL: 'NoSQL databases, document stores',
      AUTHENTICATION: 'auth strategies, JWT, OAuth',
      MICROSERVICES: 'service architecture, communication',
      CACHING: 'caching strategies, Redis',
      MESSAGE_QUEUES: 'message queues, pub/sub',
      DOCKER: 'containerization, Docker',
      KUBERNETES: 'orchestration, K8s',
      CI_CD: 'continuous integration, deployment',
      TESTING_BACKEND: 'backend testing, mocking',
      SECURITY: 'security best practices, vulnerabilities',

      // System Design
      SCALABILITY: 'scaling, load balancing',
      DISTRIBUTED_SYSTEMS: 'distributed computing',
      LOAD_BALANCING: 'load balancing strategies',
      CAP_THEOREM: 'consistency, availability, partition tolerance',

      // Behavioral
      LEADERSHIP: 'leadership scenarios',
      TEAMWORK: 'team collaboration',
      CONFLICT_RESOLUTION: 'conflict handling',
      COMMUNICATION: 'communication skills',
    };

    const prompt = `Generate a ${diff} difficulty coding question about ${categoryDescriptions[category] || category}.

Requirements:
- Difficulty: ${diff}
- Category: ${category}
- Should be interview-appropriate
- Include 3-5 test cases with edge cases
- Provide optimal solution with complexity analysis

Return JSON format with all fields as specified previously.`;

    return this.callLLMForGeneration(prompt, diff);
  }

  /**
   * Generate question based on company patterns
   */
  private async generateFromCompany(
    companyId: string,
  ): Promise<GeneratedQuestion | null> {
    const company = await prisma.company.findUnique({
      where: { id: companyId },
      include: {
        questions: {
          include: { question: true },
          take: 10,
          orderBy: { frequency: 'desc' },
        },
      },
    });

    if (!company) {
      throw new Error('Company not found');
    }

    // Analyze company patterns
    const categories = company.questions.map((q) => q.question.category);
    const difficulties = company.questions.map((q) => q.question.difficulty);
    const mostCommonCategory = this.getMostCommon(categories);
    const mostCommonDifficulty = this.getMostCommon(difficulties);

    const exampleQuestions = company.questions
      .slice(0, 3)
      .map((q) => q.question.question)
      .join('\n\n');

    const prompt = `Generate a coding question in the style of ${company.name} interviews.

**${company.name} Interview Patterns:**
- Common category: ${mostCommonCategory}
- Typical difficulty: ${mostCommonDifficulty}

**Example questions from ${company.name}:**
${exampleQuestions}

Generate a NEW question that fits ${company.name}'s interview style. Return JSON format.`;

    return this.callLLMForGeneration(
      prompt,
      mostCommonDifficulty as Difficulty,
    );
  }

  /**
   * Generate follow-up question
   */
  private async generateFollowUp(
    baseQuestionId: string,
  ): Promise<GeneratedQuestion | null> {
    const baseQuestion = await prisma.questionBank.findUnique({
      where: { id: baseQuestionId },
    });

    if (!baseQuestion) {
      throw new Error('Base question not found');
    }

    const prompt = `Given that a candidate just solved this question:

**Original Question:**
${baseQuestion.question}

Generate a natural FOLLOW-UP question that an interviewer would ask:

Follow-up types:
1. Add a new constraint (e.g., "What if the array is unsorted?")
2. Optimize further (e.g., "Can you do it in O(1) space?")
3. Handle edge cases (e.g., "What if input is empty or null?")
4. Extend the problem (e.g., "Now return all solutions, not just one")

The follow-up should be slightly harder and build on the original problem. Return JSON format.`;

    return this.callLLMForGeneration(
      prompt,
      this.increaseDifficulty(baseQuestion.difficulty),
    );
  }

  /**
   * Generate easier version
   */
  private async generateEasierVersion(
    baseQuestionId: string,
  ): Promise<GeneratedQuestion | null> {
    const baseQuestion = await prisma.questionBank.findUnique({
      where: { id: baseQuestionId },
    });

    if (!baseQuestion) {
      throw new Error('Base question not found');
    }

    if (baseQuestion.difficulty === 'EASY') {
      throw new Error('Cannot generate easier version of EASY question');
    }

    const prompt = `Simplify this coding question to make it easier:

**Original Question:**
${baseQuestion.question}
**Current Difficulty:** ${baseQuestion.difficulty}

Make it easier by:
1. Reducing constraints (e.g., sorted array, positive integers only)
2. Simplifying requirements (e.g., just find one solution, not all)
3. Providing more structure (e.g., hint at the data structure to use)

Target difficulty: ${this.decreaseDifficulty(baseQuestion.difficulty)}

Return JSON format.`;

    return this.callLLMForGeneration(
      prompt,
      this.decreaseDifficulty(baseQuestion.difficulty),
    );
  }

  /**
   * Generate harder version
   */
  private async generateHarderVersion(
    baseQuestionId: string,
  ): Promise<GeneratedQuestion | null> {
    const baseQuestion = await prisma.questionBank.findUnique({
      where: { id: baseQuestionId },
    });

    if (!baseQuestion) {
      throw new Error('Base question not found');
    }

    if (baseQuestion.difficulty === 'HARD') {
      throw new Error('Cannot generate harder version of HARD question');
    }

    const prompt = `Make this coding question more challenging:

**Original Question:**
${baseQuestion.question}
**Current Difficulty:** ${baseQuestion.difficulty}

Make it harder by:
1. Adding constraints (e.g., must be O(1) space, unsorted data)
2. Requiring multiple solutions (e.g., find all valid combinations)
3. Adding edge cases (e.g., handle negative numbers, duplicates)
4. Requiring optimization (e.g., must beat O(n¬≤) time)

Target difficulty: ${this.increaseDifficulty(baseQuestion.difficulty)}

Return JSON format.`;

    return this.callLLMForGeneration(
      prompt,
      this.increaseDifficulty(baseQuestion.difficulty),
    );
  }

  /**
   * Generate personalized question based on user's weak areas
   */
  private async generatePersonalized(
    config: GenerationConfig,
  ): Promise<GeneratedQuestion | null> {
    // This would use user's weak areas to generate targeted questions
    // For now, delegate to FROM_TOPIC
    if (config.category) {
      return this.generateFromTopic(config.category, config.difficulty);
    }

    throw new Error('Category required for personalized generation');
  }

  /**
   * Call LLM for question generation
   */
  private async callLLMForGeneration(
    prompt: string,
    difficulty: Difficulty,
  ): Promise<GeneratedQuestion | null> {
    const systemPrompt = `You are an expert coding interview question generator. 
Generate high-quality, interview-appropriate coding questions with complete solutions.

CRITICAL RULES:
1. Questions must be original and not copied from LeetCode/HackerRank
2. Include 3-5 diverse test cases (normal, edge, corner cases)
3. Provide optimal solution with clear complexity analysis
4. Code should be clean, commented, and working
5. Explanation should be educational and clear

Always return valid JSON format with ALL required fields.`;

    try {
      const response = await this.llmProvider.generateCompletion({
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: prompt },
        ],
        temperature: 0.7,
        maxTokens: 3000,
      });

      // Extract JSON from response
      const jsonMatch =
        response.content.match(/```json\n([\s\S]*?)\n```/) ||
        response.content.match(/\{[\s\S]*\}/);

      if (!jsonMatch) {
        console.error('No JSON found in response:', response.content);
        return null;
      }

      const jsonStr = jsonMatch[1] || jsonMatch[0];
      const generated = JSON.parse(jsonStr) as GeneratedQuestion;

      // Validate generated question
      if (!this.validateGeneratedQuestion(generated)) {
        console.error('Generated question failed validation');
        return null;
      }

      return generated;
    } catch (error) {
      console.error('LLM generation error:', error);
      return null;
    }
  }

  /**
   * Validate generated question
   */
  private validateGeneratedQuestion(question: any): boolean {
    const required = [
      'question',
      'difficulty',
      'category',
      'hints',
      'solution',
      'sampleCode',
      'testCases',
    ];

    for (const field of required) {
      if (!question[field]) {
        console.error(`Missing required field: ${field}`);
        return false;
      }
    }

    // Validate hints array
    if (!Array.isArray(question.hints) || question.hints.length < 2) {
      console.error('Hints must be an array with at least 2 items');
      return false;
    }

    // Validate test cases
    if (!Array.isArray(question.testCases) || question.testCases.length < 3) {
      console.error('Must have at least 3 test cases');
      return false;
    }

    return true;
  }

  /**
   * Save generated question to database
   */
  private async saveGeneratedQuestion(
    generated: GeneratedQuestion,
    config: GenerationConfig,
    requestId: string,
  ) {
    return prisma.aIGeneratedQuestion.create({
      data: {
        baseQuestionId: config.baseQuestionId,
        generationType: config.generationType,
        question: generated.question,
        description: generated.description,
        difficulty: generated.difficulty,
        category: generated.category,
        subcategory: generated.subcategory,
        hints: generated.hints,
        solution: generated.solution,
        sampleCode: generated.sampleCode,
        explanation: generated.explanation,
        testCases: generated.testCases as any,
        timeComplexity: generated.timeComplexity,
        spaceComplexity: generated.spaceComplexity,
        prompt: `Request ID: ${requestId}`,
        model: this.llmProvider.constructor.name,
        temperature: 0.7,
        status: 'PENDING_REVIEW',
      },
    });
  }

  /**
   * Generate multiple similar questions (batch)
   */
  async generateBatch(
    userId: string,
    baseQuestionId: string,
    count: number,
  ): Promise<string[]> {
    return this.generateQuestions(userId, {
      generationType: 'SIMILAR',
      baseQuestionId,
      count,
    });
  }

  /**
   * Get AI-generated question by ID
   */
  async getGeneratedQuestion(questionId: string) {
    return prisma.aIGeneratedQuestion.findUnique({
      where: { id: questionId },
      include: {
        baseQuestion: true,
        variations: true,
        reviews: true,
      },
    });
  }

  /**
   * Approve generated question
   */
  async approveQuestion(questionId: string, reviewerId: string) {
    return prisma.aIGeneratedQuestion.update({
      where: { id: questionId },
      data: {
        status: 'APPROVED',
        isApproved: true,
        approvedBy: reviewerId,
        approvedAt: new Date(),
      },
    });
  }

  /**
   * Get questions pending review
   */
  async getPendingReview(limit: number = 10) {
    return prisma.aIGeneratedQuestion.findMany({
      where: { status: 'PENDING_REVIEW' },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });
  }

  /**
   * Record question usage
   */
  async recordUsage(
    questionId: string,
    userId: string,
    data: {
      sessionId?: string;
      wasSuccessful?: boolean;
      timeSpent?: number;
      userRating?: number;
      userFeedback?: string;
    },
  ) {
    // Create usage record
    await prisma.aIQuestionUsage.create({
      data: {
        questionId,
        userId,
        ...data,
      },
    });

    // Update question statistics
    await prisma.aIGeneratedQuestion.update({
      where: { id: questionId },
      data: {
        timesUsed: { increment: 1 },
      },
    });
  }

  /**
   * Get generation statistics
   */
  async getGenerationStats() {
    const [total, byType, byStatus, recentGenerations] = await Promise.all([
      prisma.aIGeneratedQuestion.count(),

      prisma.aIGeneratedQuestion.groupBy({
        by: ['generationType'],
        _count: { id: true },
      }),

      prisma.aIGeneratedQuestion.groupBy({
        by: ['status'],
        _count: { id: true },
      }),

      prisma.aIGeneratedQuestion.findMany({
        take: 10,
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          question: true,
          difficulty: true,
          category: true,
          status: true,
          createdAt: true,
        },
      }),
    ]);

    return {
      total,
      byType,
      byStatus,
      recentGenerations,
    };
  }

  // Helper methods
  private getMostCommon<T>(arr: T[]): T {
    const counts = new Map<T, number>();
    arr.forEach((item) => counts.set(item, (counts.get(item) || 0) + 1));
    return Array.from(counts.entries()).reduce((a, b) =>
      b[1] > a[1] ? b : a,
    )[0];
  }

  private increaseDifficulty(current: Difficulty): Difficulty {
    if (current === 'EASY') return 'MEDIUM';
    if (current === 'MEDIUM') return 'HARD';
    return 'HARD';
  }

  private decreaseDifficulty(current: Difficulty): Difficulty {
    if (current === 'HARD') return 'MEDIUM';
    if (current === 'MEDIUM') return 'EASY';
    return 'EASY';
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\auth\auth.service.ts
==============================

// src/services/auth/auth.service.ts
import { UserRepository } from '../../repositories/user.repository';
import { RefreshTokenRepository } from '../../repositories/refresh-token.repository';
import { LoginHistoryRepository } from '../../repositories/login-history.repository';
import { PasswordUtil } from '../../utils/password.util';
import { TokenUtil } from '../../utils/token.util';
import { EmailUtil } from '../../utils/email.util';
import {
  RegisterDTO,
  LoginDTO,
  AuthTokens,
  SafeUser,
  OAuthProfile,
} from '../../types/auth.types';
import redis from '../../config/redis';

export class AuthService {
  private userRepo: UserRepository;
  private refreshTokenRepo: RefreshTokenRepository;
  private loginHistoryRepo: LoginHistoryRepository;

  constructor() {
    this.userRepo = new UserRepository();
    this.refreshTokenRepo = new RefreshTokenRepository();
    this.loginHistoryRepo = new LoginHistoryRepository();
  }

  async register(
    data: RegisterDTO,
  ): Promise<{ user: SafeUser; message: string }> {
    // Check if user exists
    const existingUser = await this.userRepo.findByEmail(data.email);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    // Validate password
    const passwordValidation = PasswordUtil.validate(data.password);
    if (!passwordValidation.valid) {
      throw new Error(passwordValidation.errors.join(', '));
    }

    // Hash password
    const passwordHash = await PasswordUtil.hash(data.password);

    // Create user
    const user = await this.userRepo.create({
      ...data,
      passwordHash,
    });

    // Generate verification token
    const verificationToken = TokenUtil.generateVerificationToken();
    const tokenExpiry = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

    await this.userRepo.setVerificationToken(
      user.id,
      verificationToken,
      tokenExpiry,
    );

    // Send verification email
    try {
      await EmailUtil.sendVerificationEmail(
        user.email,
        verificationToken,
        user.name,
      );
    } catch (error) {
      console.error('Failed to send verification email:', error);
    }

    return {
      user: this.userRepo.toSafeUser(user),
      message:
        'Registration successful. Please check your email to verify your account.',
    };
  }

  async login(
    data: LoginDTO,
    ipAddress: string,
    userAgent: string,
  ): Promise<{ user: SafeUser; tokens: AuthTokens }> {
    // Find user
    const user = await this.userRepo.findByEmail(data.email);
    if (!user || !user.passwordHash) {
      await this.loginHistoryRepo.create(
        user?.id || 'unknown',
        ipAddress,
        userAgent,
        'email',
        false,
      );
      throw new Error('Invalid email or password');
    }

    // Check if account is active
    if (!user.isActive) {
      throw new Error('Account has been deactivated');
    }

    // Verify password
    const isValidPassword = await PasswordUtil.compare(
      data.password,
      user.passwordHash,
    );
    if (!isValidPassword) {
      await this.loginHistoryRepo.create(
        user.id,
        ipAddress,
        userAgent,
        'email',
        false,
      );
      throw new Error('Invalid email or password');
    }

    // Check for too many failed attempts
    const recentFailures = await this.loginHistoryRepo.getFailedAttempts(
      user.id,
      new Date(Date.now() - 15 * 60 * 1000), // Last 15 minutes
    );

    if (recentFailures >= 5) {
      throw new Error(
        'Too many failed login attempts. Please try again later.',
      );
    }

    // Generate tokens
    const tokens = await this.generateTokens(user.id, user.email, user.role);

    // Update last login
    await this.userRepo.updateLastLogin(user.id);

    // Record successful login
    await this.loginHistoryRepo.create(
      user.id,
      ipAddress,
      userAgent,
      'email',
      true,
    );

    return {
      user: this.userRepo.toSafeUser(user),
      tokens,
    };
  }

  async refreshTokens(refreshToken: string): Promise<AuthTokens> {
    // Verify token
    let payload;
    try {
      payload = TokenUtil.verifyRefreshToken(refreshToken);
    } catch (error) {
      throw new Error('Invalid refresh token');
    }

    // Find token in database
    const tokenRecord = await this.refreshTokenRepo.findByToken(refreshToken);
    if (!tokenRecord || tokenRecord.revoked) {
      throw new Error('Refresh token has been revoked');
    }

    if (tokenRecord.expiresAt < new Date()) {
      throw new Error('Refresh token has expired');
    }

    // Generate new tokens
    const newTokens = await this.generateTokens(
      payload.userId,
      payload.email,
      payload.role,
    );

    // Revoke old refresh token
    await this.refreshTokenRepo.revoke(refreshToken, newTokens.refreshToken);

    return newTokens;
  }

  async logout(refreshToken: string): Promise<void> {
    await this.refreshTokenRepo.revoke(refreshToken);
  }

  async verifyEmail(token: string): Promise<{ user: SafeUser }> {
    const user = await this.userRepo.findByVerificationToken(token);
    if (!user) {
      throw new Error('Invalid or expired verification token');
    }

    await this.userRepo.verifyEmail(user.id);

    // Send welcome email
    try {
      await EmailUtil.sendWelcomeEmail(user.email, user.name);
    } catch (error) {
      console.error('Failed to send welcome email:', error);
    }

    return {
      user: this.userRepo.toSafeUser(user),
    };
  }

  async requestPasswordReset(email: string): Promise<{ message: string }> {
    const user = await this.userRepo.findByEmail(email);
    if (!user) {
      // Don't reveal if user exists
      return { message: 'If the email exists, a reset link has been sent.' };
    }

    const resetToken = TokenUtil.generateResetToken();
    const tokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    await this.userRepo.setResetToken(user.id, resetToken, tokenExpiry);

    try {
      await EmailUtil.sendPasswordResetEmail(user.email, resetToken, user.name);
    } catch (error) {
      console.error('Failed to send password reset email:', error);
    }

    return { message: 'If the email exists, a reset link has been sent.' };
  }

  async resetPassword(
    token: string,
    newPassword: string,
  ): Promise<{ message: string }> {
    const user = await this.userRepo.findByResetToken(token);
    if (!user) {
      throw new Error('Invalid or expired reset token');
    }

    // Validate new password
    const passwordValidation = PasswordUtil.validate(newPassword);
    if (!passwordValidation.valid) {
      throw new Error(passwordValidation.errors.join(', '));
    }

    // Hash new password
    const passwordHash = await PasswordUtil.hash(newPassword);

    // Update password
    await this.userRepo.updatePassword(user.id, passwordHash);

    // Revoke all refresh tokens for security
    await this.refreshTokenRepo.revokeAllForUser(user.id);

    return {
      message:
        'Password reset successful. Please login with your new password.',
    };
  }

  async loginWithOAuth(
    profile: OAuthProfile,
    ipAddress: string,
    userAgent: string,
  ): Promise<{ user: SafeUser; tokens: AuthTokens; isNewUser: boolean }> {
    // Check if user exists
    let user = await this.userRepo.findByOAuth(profile.provider, profile.id);
    let isNewUser = false;

    if (!user) {
      // Check if email already exists
      user = await this.userRepo.findByEmail(profile.email);

      if (user) {
        // Link OAuth to existing account
        await this.userRepo.update(user.id, {
          oauthProvider: profile.provider,
          oauthId: profile.id,
          profilePicture: profile.picture,
          emailVerified: true, // OAuth emails are pre-verified
        });
      } else {
        // Create new user
        user = await this.userRepo.create({
          email: profile.email,
          name: profile.name,
          passwordHash: '', // No password for OAuth users
        });

        await this.userRepo.update(user.id, {
          oauthProvider: profile.provider,
          oauthId: profile.id,
          profilePicture: profile.picture,
          emailVerified: true,
        });

        isNewUser = true;
      }
    }

    // Generate tokens
    const tokens = await this.generateTokens(user.id, user.email, user.role);

    // Update last login
    await this.userRepo.updateLastLogin(user.id);

    // Record login
    await this.loginHistoryRepo.create(
      user.id,
      ipAddress,
      userAgent,
      profile.provider,
      true,
    );

    return {
      user: this.userRepo.toSafeUser(user),
      tokens,
      isNewUser,
    };
  }

  private async generateTokens(
    userId: string,
    email: string,
    role: any,
  ): Promise<AuthTokens> {
    const payload = { userId, email, role };

    const accessToken = TokenUtil.generateAccessToken(payload);
    const refreshToken = TokenUtil.generateRefreshToken(payload);

    // Store refresh token in database
    await this.refreshTokenRepo.create(
      userId,
      refreshToken,
      TokenUtil.getRefreshTokenExpiry(),
    );

    return {
      accessToken,
      refreshToken,
      expiresIn: 15 * 60, // 15 minutes in seconds
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\code-execution.service.ts
==============================

// src/services/code-execution.service.ts
import axios from 'axios';
import { ProgrammingLanguage } from '@prisma/client';

interface CodeExecutionResult {
  success: boolean;
  output?: string;
  error?: string;
  executionTime?: number;
  memory?: number;
  testCasesPassed?: number;
  testCasesTotal?: number;
  testCaseResults?: TestCaseResult[];
}

interface TestCaseResult {
  input: any;
  expectedOutput: any;
  actualOutput: any;
  passed: boolean;
  executionTime?: number;
}

export class CodeExecutionService {
  private apiUrl =
    process.env.CODE_EXECUTION_API || 'https://api.jdoodle.com/v1/execute';
  private clientId = process.env.JDOODLE_CLIENT_ID;
  private clientSecret = process.env.JDOODLE_CLIENT_SECRET;

  /**
   * Execute code with test cases
   */
  async executeCode(
    code: string,
    language: ProgrammingLanguage,
    testCases: any[],
  ): Promise<CodeExecutionResult> {
    const languageVersionMap: Record<
      ProgrammingLanguage,
      { language: string; version: string }
    > = {
      JAVASCRIPT: { language: 'nodejs', version: '18' },
      TYPESCRIPT: { language: 'nodejs', version: '18' },
      PYTHON: { language: 'python3', version: '3' },
      JAVA: { language: 'java', version: '17' },
      CPP: { language: 'cpp17', version: '1' },
      CSHARP: { language: 'csharp', version: '4' },
      GO: { language: 'go', version: '3' },
      RUST: { language: 'rust', version: '1' },
      SWIFT: { language: 'swift', version: '5' },
      KOTLIN: { language: 'kotlin', version: '3' },
    };

    const langConfig = languageVersionMap[language];
    const results: TestCaseResult[] = [];
    let passed = 0;

    for (const testCase of testCases) {
      try {
        const wrappedCode = this.wrapCodeWithTestCase(code, testCase, language);

        const response = await axios.post(this.apiUrl, {
          clientId: this.clientId,
          clientSecret: this.clientSecret,
          script: wrappedCode,
          language: langConfig.language,
          versionIndex: langConfig.version,
        });

        const output = response.data.output?.trim();
        const expectedOutput = JSON.stringify(testCase.expectedOutput);
        const actualOutput = output;

        const testPassed = this.compareOutputs(actualOutput, expectedOutput);

        if (testPassed) passed++;

        results.push({
          input: testCase.input,
          expectedOutput: testCase.expectedOutput,
          actualOutput: actualOutput,
          passed: testPassed,
          executionTime: response.data.cpuTime,
        });
      } catch (error) {
        results.push({
          input: testCase.input,
          expectedOutput: testCase.expectedOutput,
          actualOutput: null,
          passed: false,
        });
      }
    }

    return {
      success: passed === testCases.length,
      testCasesPassed: passed,
      testCasesTotal: testCases.length,
      testCaseResults: results,
    };
  }

  /**
   * Wrap user code with test case execution
   */
  private wrapCodeWithTestCase(
    code: string,
    testCase: any,
    language: ProgrammingLanguage,
  ): string {
    const input = JSON.stringify(testCase.input);

    if (language === 'JAVASCRIPT' || language === 'TYPESCRIPT') {
      return `
${code}

// Test execution
const input = ${input};
const result = typeof twoSum === 'function' ? twoSum(...Object.values(input)) : null;
console.log(JSON.stringify(result));
      `;
    } else if (language === 'PYTHON') {
      return `
${code}

# Test execution
import json
input_data = ${input}
result = two_sum(**input_data) if 'two_sum' in dir() else None
print(json.dumps(result))
      `;
    }

    return code;
  }

  /**
   * Compare actual vs expected output
   */
  private compareOutputs(actual: string, expected: string): boolean {
    try {
      const actualParsed = JSON.parse(actual);
      const expectedParsed = JSON.parse(expected);
      return JSON.stringify(actualParsed) === JSON.stringify(expectedParsed);
    } catch {
      return actual === expected;
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\company.service.ts
==============================

// src/services/company.service.ts
import prisma from '../config/database';
import { CompanyDifficulty, Difficulty, Prisma } from '@prisma/client';

interface CompanyData {
  name: string;
  slug: string;
  description?: string;
  industry?: string;
  size?: string;
  locations?: string[];
  interviewProcess?: any;
  interviewDifficulty?: CompanyDifficulty;
  isPremium?: boolean;
}

export class CompanyService {
  /**
   * Create company
   */
  async createCompany(data: CompanyData) {
    return prisma.company.create({
      data: {
        ...data,
        locations: data.locations || [],
      },
    });
  }

  /**
   * Get all companies
   */
  async getAllCompanies(filters?: {
    industry?: string;
    size?: string;
    difficulty?: CompanyDifficulty;
    isPremium?: boolean;
  }) {
    return prisma.company.findMany({
      where: {
        isActive: true,
        ...(filters?.industry && { industry: filters.industry }),
        ...(filters?.size && { size: filters.size }),
        ...(filters?.difficulty && { interviewDifficulty: filters.difficulty }),
        ...(filters?.isPremium !== undefined && {
          isPremium: filters.isPremium,
        }),
      },
      include: {
        _count: {
          select: {
            questions: true,
            interviewTips: true,
            interviewExperiences: true,
          },
        },
      },
      orderBy: { totalInterviews: 'desc' },
    });
  }

  /**
   * Get company by slug
   */
  async getCompanyBySlug(slug: string) {
    return prisma.company.findUnique({
      where: { slug },
      include: {
        questions: {
          include: {
            question: {
              include: {
                difficultyRatings: {
                  take: 5,
                  orderBy: { createdAt: 'desc' },
                },
              },
            },
          },
          orderBy: { frequency: 'desc' },
          take: 50,
        },
        interviewTips: {
          where: { isPinned: true },
          orderBy: { upvotes: 'desc' },
          take: 10,
        },
        interviewExperiences: {
          orderBy: { upvotes: 'desc' },
          take: 10,
        },
        preparationPlans: {
          where: { isActive: true },
          orderBy: { duration: 'asc' },
        },
      },
    });
  }

  /**
   * Add question to company
   */
  async addQuestionToCompany(
    companyId: string,
    questionId: string,
    metadata: {
      frequency?: number;
      round?: string;
      position?: string;
    },
  ) {
    return prisma.companyQuestion.create({
      data: {
        companyId,
        questionId,
        ...metadata,
      },
    });
  }

  /**
   * Get company questions
   */
  async getCompanyQuestions(
    companyId: string,
    filters?: {
      difficulty?: Difficulty;
      category?: string;
      round?: string;
      limit?: number;
    },
  ) {
    const where: any = { companyId };

    if (filters?.difficulty) {
      where.question = { difficulty: filters.difficulty };
    }

    if (filters?.category) {
      where.question = { ...where.question, category: filters.category };
    }

    if (filters?.round) {
      where.round = filters.round;
    }

    return prisma.companyQuestion.findMany({
      where,
      include: {
        question: true,
      },
      orderBy: { frequency: 'desc' },
      take: filters?.limit || 50,
    });
  }

  /**
   * Get company statistics
   */
  async getCompanyStatistics(companyId: string) {
    const [
      totalQuestions,
      categoryBreakdown,
      difficultyBreakdown,
      avgSuccessRate,
    ] = await Promise.all([
      prisma.companyQuestion.count({ where: { companyId } }),

      prisma.companyQuestion.groupBy({
        by: ['round'],
        where: { companyId },
        _count: { id: true },
      }),

      prisma.$queryRaw`
        SELECT q.difficulty, COUNT(*) as count
        FROM "CompanyQuestion" cq
        JOIN "QuestionBank" q ON cq."questionId" = q.id
        WHERE cq."companyId" = ${companyId}
        GROUP BY q.difficulty
      `,

      prisma.userCompanyProgress.aggregate({
        where: { companyId },
        _avg: { averageScore: true },
      }),
    ]);

    return {
      totalQuestions,
      categoryBreakdown,
      difficultyBreakdown,
      averageSuccessRate: avgSuccessRate._avg.averageScore,
    };
  }

  /**
   * Create company preparation plan
   */
  async createPreparationPlan(
    companyId: string,
    plan: {
      name: string;
      description?: string;
      duration: number;
      difficulty: Difficulty;
      phases: any[];
      estimatedHours: number;
      isPremium?: boolean;
    },
  ) {
    return prisma.companyPreparationPlan.create({
      data: {
        companyId,
        ...plan,
      },
    });
  }

  /**
   * Get user's company progress
   */
  async getUserCompanyProgress(userId: string, companyId: string) {
    let progress = await prisma.userCompanyProgress.findUnique({
      where: {
        userId_companyId: {
          userId,
          companyId,
        },
      },
    });

    if (!progress) {
      progress = await prisma.userCompanyProgress.create({
        data: {
          userId,
          companyId,
        },
      });
    }

    return progress;
  }

  /**
   * Update user's company progress
   */
  async updateUserProgress(
    userId: string,
    companyId: string,
    data: Partial<{
      questionsAttempted: number;
      questionsCompleted: number;
      averageScore: number;
      status: any;
      strongTopics: string[];
      weakTopics: string[];
    }>,
  ) {
    return prisma.userCompanyProgress.upsert({
      where: {
        userId_companyId: {
          userId,
          companyId,
        },
      },
      update: {
        ...data,
        lastPracticed: new Date(),
        updatedAt: new Date(),
      },
      create: {
        userId,
        companyId,
        ...data,
      },
    });
  }

  /**
   * Add interview experience
   */
  async addInterviewExperience(
    companyId: string,
    userId: string,
    experience: {
      position: string;
      experienceLevel: string;
      rounds: any[];
      outcome: string;
      difficulty: CompanyDifficulty;
      preparation: string;
      tips?: string;
      isAnonymous?: boolean;
    },
  ) {
    return prisma.companyInterviewExperience.create({
      data: {
        companyId,
        userId,
        ...experience,
      },
    });
  }

  /**
   * Get recommended companies for user
   */
  async getRecommendedCompanies(userId: string) {
    // Get user's skill level and preferences
    const userProgress = await prisma.userProgress.findUnique({
      where: { userId },
    });

    const preferences = await prisma.userPreferences.findUnique({
      where: { userId },
    });

    // Get companies matching user's profile
    const companies = await prisma.company.findMany({
      where: {
        isActive: true,
        ...(preferences?.targetCompanies && {
          name: { in: preferences.targetCompanies as string[] },
        }),
      },
      include: {
        _count: {
          select: { questions: true },
        },
      },
      take: 10,
    });

    return companies;
  }

  /**
   * Start company-specific practice session
   */
  async startCompanyPractice(
    userId: string,
    companyId: string,
    config: {
      questionCount: number;
      difficulty?: Difficulty;
      duration?: number;
    },
  ) {
    // Get company questions
    const companyQuestions = await this.getCompanyQuestions(companyId, {
      difficulty: config.difficulty,
      limit: config.questionCount,
    });

    // Create practice session
    const session = await prisma.practiceSession.create({
      data: {
        userId,
        type: 'COMPANY_SPECIFIC',
        companyId,
        questionCount: config.questionCount,
        difficulty: config.difficulty,
        duration: config.duration,
      },
    });

    // Add questions to session
    await Promise.all(
      companyQuestions.map((cq, index) =>
        prisma.practiceSessionQuestion.create({
          data: {
            sessionId: session.id,
            questionId: cq.questionId,
            questionIndex: index,
          },
        }),
      ),
    );

    return prisma.practiceSession.findUnique({
      where: { id: session.id },
      include: {
        questions: {
          include: {
            question: true,
          },
          orderBy: { questionIndex: 'asc' },
        },
      },
    });
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\embedding\embedding-service.ts
==============================

/**
 * Embedding Service
 * Generates vector embeddings for text using the configured LLM provider
 */

import OpenAI from 'openai';

export class EmbeddingService {
  private openaiClient: OpenAI | null = null;
  private embeddingModel: string;

  constructor(embeddingModel: string = 'text-embedding-3-small') {
    this.embeddingModel = embeddingModel;
    
    // Initialize OpenAI client for embeddings
    // Most providers use OpenAI-compatible embedding endpoints
    const apiKey = process.env.OPENAI_API_KEY;
    if (apiKey) {
      this.openaiClient = new OpenAI({ apiKey });
    }
  }

  /**
   * Generate embedding for a single text
   */
  async generateEmbedding(text: string): Promise<number[]> {
    if (!this.openaiClient) {
      // Fallback: return a random embedding for testing
      console.warn('No OpenAI client available, using random embeddings');
      return this.generateRandomEmbedding(1536);
    }

    try {
      const response = await this.openaiClient.embeddings.create({
        model: this.embeddingModel,
        input: text,
      });

      return response.data[0].embedding;
    } catch (error) {
      console.error('Failed to generate embedding:', error);
      // Fallback to random embedding
      return this.generateRandomEmbedding(1536);
    }
  }

  /**
   * Generate embeddings for multiple texts
   */
  async generateEmbeddings(texts: string[]): Promise<number[][]> {
    if (!this.openaiClient) {
      console.warn('No OpenAI client available, using random embeddings');
      return texts.map(() => this.generateRandomEmbedding(1536));
    }

    try {
      const response = await this.openaiClient.embeddings.create({
        model: this.embeddingModel,
        input: texts,
      });

      return response.data.map((item) => item.embedding);
    } catch (error) {
      console.error('Failed to generate embeddings:', error);
      return texts.map(() => this.generateRandomEmbedding(1536));
    }
  }

  /**
   * Generate a random embedding (for testing/fallback)
   */
  private generateRandomEmbedding(dimension: number): number[] {
    const embedding = new Array(dimension);
    for (let i = 0; i < dimension; i++) {
      embedding[i] = Math.random() * 2 - 1; // Random values between -1 and 1
    }
    
    // Normalize the vector
    const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
    return embedding.map((val) => val / magnitude);
  }

  /**
   * Calculate cosine similarity between two embeddings
   */
  cosineSimilarity(embedding1: number[], embedding2: number[]): number {
    if (embedding1.length !== embedding2.length) {
      throw new Error('Embeddings must have the same dimension');
    }

    let dotProduct = 0;
    let magnitude1 = 0;
    let magnitude2 = 0;

    for (let i = 0; i < embedding1.length; i++) {
      dotProduct += embedding1[i] * embedding2[i];
      magnitude1 += embedding1[i] * embedding1[i];
      magnitude2 += embedding2[i] * embedding2[i];
    }

    magnitude1 = Math.sqrt(magnitude1);
    magnitude2 = Math.sqrt(magnitude2);

    if (magnitude1 === 0 || magnitude2 === 0) {
      return 0;
    }

    return dotProduct / (magnitude1 * magnitude2);
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\enhanced-interview-session-manager.ts
==============================

// src/services/enhanced-interview-session-manager.ts - ADD timer support

export class EnhancedInterviewSessionManager {
  private questionBankService: QuestionBankService;
  private timerService: TimerService; // NEW

  constructor(
    private llmProvider: ILLMProvider,
    private memoryManager: MemoryManager,
    private vectorDb?: IVectorDatabase,
  ) {
    this.questionBankService = new QuestionBankService();
    this.timerService = new TimerService(); // NEW
  }

  /**
   * Start a new interview session with role-based questions
   * UPDATED: Add timer support
   */
  async startSession(
    userId: string,
    type: InterviewType,
    role?: DeveloperRole,
    difficulty: Difficulty = 'MEDIUM',
    duration?: number,
    focusAreas?: QuestionCategory[],
    isTimed: boolean = false, // NEW
    timeLimitPerQuestion?: number, // NEW (in seconds)
  ): Promise<InterviewSession & { questions: InterviewQuestion[] }> {
    const sessionId = uuidv4();

    // Generate questions based on configuration
    const config: InterviewConfig = {
      type,
      role,
      difficulty,
      duration: duration || 30,
      focusAreas,
    };

    const questionTemplates =
      await this.questionBankService.generateQuestions(config);

    // Calculate time limits
    let totalTimeLimit: number | undefined;
    let timePerQuestion: number | undefined;

    if (isTimed) {
      if (duration) {
        totalTimeLimit = duration; // Total minutes for interview
      }

      if (timeLimitPerQuestion) {
        timePerQuestion = timeLimitPerQuestion; // Seconds per question
      } else if (duration) {
        // Distribute time evenly across questions
        timePerQuestion = Math.floor(
          (duration * 60) / questionTemplates.length,
        );
      }
    }

    // Create interview session in database
    const session = await prisma.interviewSession.create({
      data: {
        id: sessionId,
        userId,
        type,
        role,
        difficulty,
        totalQuestions: questionTemplates.length,
        focusAreas: focusAreas || [],
        isTimed, // NEW
        timeLimit: totalTimeLimit, // NEW
        timeLimitPerQuestion: timePerQuestion, // NEW
        expiresAt: new Date(Date.now() + (duration || 30) * 60 * 1000),
      },
      include: { questions: true },
    });

    // Create questions in database
    const questions = await Promise.all(
      questionTemplates.map((template, index) =>
        prisma.interviewQuestion.create({
          data: {
            sessionId,
            questionIndex: index,
            question: template.question,
            difficulty: template.difficulty,
            category: template.category,
            subcategory: template.subcategory,
            hints: template.hints,
            expectedAnswer: template.sampleAnswer,
            sampleCode: template.sampleCode,
            testCases: template.testCases as any,
            timeAllocated: timePerQuestion, // NEW
          },
        }),
      ),
    );

    // Start timer if timed interview
    if (isTimed) {
      await this.timerService.startSessionTimer(sessionId);

      // Start timer for first question
      if (questions.length > 0 && timePerQuestion) {
        await this.timerService.startQuestionTimer(
          questions[0].id,
          timePerQuestion,
        );
      }
    }

    // Create memory session
    await this.memoryManager.createSession(userId, sessionId);

    return { ...session, questions };
  }

  /**
   * Submit answer with timer handling
   * UPDATED: Add timer support
   */
  async submitAnswer(
    sessionId: string,
    answer: string,
    code?: string,
    timeSpent?: number,
  ): Promise<{
    feedback: string;
    score: number;
    nextQuestion: InterviewQuestion | null;
    sessionCompleted: boolean;
    timeExpired?: boolean; // NEW
  }> {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
      include: { questions: true },
    });

    if (!session) {
      throw new Error('Session not found');
    }

    // Check if time expired (for timed interviews)
    let timeExpired = false;
    if (session.isTimed) {
      timeExpired = await this.timerService.isTimeExpired(sessionId);

      if (timeExpired) {
        await this.timerService.handleTimeout(sessionId);
        return {
          feedback: 'Time expired. Interview automatically completed.',
          score: 0,
          nextQuestion: null,
          sessionCompleted: true,
          timeExpired: true,
        };
      }
    }

    const currentQuestion = session.questions[session.currentQuestionIndex];
    if (!currentQuestion) {
      throw new Error('No current question');
    }

    // Calculate time spent if not provided
    let actualTimeSpent = timeSpent;
    if (!actualTimeSpent && currentQuestion.timeStarted) {
      actualTimeSpent = await this.timerService.getQuestionTimeSpent(
        currentQuestion.id,
      );
    }

    // Evaluate answer
    const evaluation = await this.evaluateAnswer(
      currentQuestion,
      answer,
      code,
      session.type,
      session.role,
    );

    // Update question with answer and feedback
    await prisma.interviewQuestion.update({
      where: { id: currentQuestion.id },
      data: {
        userAnswer: answer,
        userCode: code,
        score: evaluation.score,
        feedback: evaluation.feedback,
        timeSpent: actualTimeSpent,
        timeSubmitted: new Date(), // NEW
        answeredAt: new Date(),
      },
    });

    // Record weak areas if score is low
    if (evaluation.score < 60) {
      await this.recordWeakArea(
        session.userId,
        currentQuestion.category,
        currentQuestion.subcategory,
      );
    }

    // Move to next question
    const nextIndex = session.currentQuestionIndex + 1;
    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: { currentQuestionIndex: nextIndex },
    });

    const nextQuestion =
      nextIndex < session.questions.length
        ? session.questions[nextIndex]
        : null;

    // Start timer for next question (if timed)
    if (nextQuestion && session.isTimed && session.timeLimitPerQuestion) {
      await this.timerService.startQuestionTimer(
        nextQuestion.id,
        session.timeLimitPerQuestion,
      );
    }

    const sessionCompleted = nextQuestion === null;

    if (sessionCompleted) {
      await this.completeSession(sessionId);
    }

    return {
      feedback: evaluation.feedback,
      score: evaluation.score,
      nextQuestion,
      sessionCompleted,
      timeExpired,
    };
  }

  // ... rest of existing methods remain the same
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\file-upload.service.ts
==============================

// src/services/file-upload.service.ts
import {
  S3Client,
  PutObjectCommand,
  DeleteObjectCommand,
  GetObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import sharp from 'sharp';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import prisma from '../config/database';
import { FileCategory } from '@prisma/client';

interface UploadedFile {
  fieldname: string;
  originalname: string;
  encoding: string;
  mimetype: string;
  buffer: Buffer;
  size: number;
}

interface FileUploadResult {
  id: string;
  url: string;
  thumbnailUrl?: string;
  filename: string;
  size: number;
  mimeType: string;
}

export class FileUploadService {
  private s3Client: S3Client;
  private bucket: string;
  private region: string;
  private useLocalStorage: boolean;

  constructor() {
    this.bucket = process.env.S3_BUCKET || 'interview-coach-uploads';
    this.region = process.env.AWS_REGION || 'us-east-1';
    this.useLocalStorage = process.env.USE_LOCAL_STORAGE === 'true';

    if (!this.useLocalStorage) {
      this.s3Client = new S3Client({
        region: this.region,
        credentials: {
          accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
        },
      });
    }
  }

  /**
   * Upload file to S3 or local storage
   */
  async uploadFile(
    file: UploadedFile,
    userId: string,
    category: FileCategory,
  ): Promise<FileUploadResult> {
    // Validate file
    this.validateFile(file, category);

    // Generate unique filename
    const ext = path.extname(file.originalname);
    const filename = `${userId}/${category.toLowerCase()}/${uuidv4()}${ext}`;

    let url: string;
    let thumbnailUrl: string | undefined;

    if (this.useLocalStorage) {
      // Local storage (for development)
      url = await this.uploadToLocal(file.buffer, filename);

      if (this.isImage(file.mimetype)) {
        thumbnailUrl = await this.createThumbnail(file.buffer, filename);
      }
    } else {
      // S3 upload (for production)
      url = await this.uploadToS3(file.buffer, filename, file.mimetype);

      if (this.isImage(file.mimetype)) {
        thumbnailUrl = await this.uploadThumbnailToS3(file.buffer, filename);
      }
    }

    // Save to database
    const upload = await prisma.fileUpload.create({
      data: {
        userId,
        filename,
        originalName: file.originalname,
        mimeType: file.mimetype,
        size: file.size,
        url,
        thumbnailUrl,
        category,
      },
    });

    return {
      id: upload.id,
      url: upload.url,
      thumbnailUrl: upload.thumbnailUrl || undefined,
      filename: upload.filename,
      size: upload.size,
      mimeType: upload.mimeType,
    };
  }

  /**
   * Upload to S3
   */
  private async uploadToS3(
    buffer: Buffer,
    filename: string,
    mimeType: string,
  ): Promise<string> {
    const command = new PutObjectCommand({
      Bucket: this.bucket,
      Key: filename,
      Body: buffer,
      ContentType: mimeType,
    });

    await this.s3Client.send(command);

    return `https://${this.bucket}.s3.${this.region}.amazonaws.com/${filename}`;
  }

  /**
   * Upload to local storage
   */
  private async uploadToLocal(
    buffer: Buffer,
    filename: string,
  ): Promise<string> {
    const fs = require('fs').promises;
    const uploadDir = path.join(process.cwd(), 'uploads');
    const filePath = path.join(uploadDir, filename);

    // Create directory if it doesn't exist
    await fs.mkdir(path.dirname(filePath), { recursive: true });

    // Write file
    await fs.writeFile(filePath, buffer);

    return `/uploads/${filename}`;
  }

  /**
   * Create thumbnail
   */
  private async createThumbnail(
    buffer: Buffer,
    filename: string,
  ): Promise<string> {
    const thumbnail = await sharp(buffer)
      .resize(200, 200, {
        fit: 'cover',
        position: 'center',
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    const thumbnailFilename = filename.replace(/\.[^.]+$/, '_thumb.jpg');

    if (this.useLocalStorage) {
      return this.uploadToLocal(thumbnail, thumbnailFilename);
    } else {
      return this.uploadToS3(thumbnail, thumbnailFilename, 'image/jpeg');
    }
  }

  /**
   * Upload thumbnail to S3
   */
  private async uploadThumbnailToS3(
    buffer: Buffer,
    filename: string,
  ): Promise<string> {
    const thumbnail = await sharp(buffer)
      .resize(200, 200, {
        fit: 'cover',
        position: 'center',
      })
      .jpeg({ quality: 80 })
      .toBuffer();

    const thumbnailFilename = filename.replace(/\.[^.]+$/, '_thumb.jpg');

    return this.uploadToS3(thumbnail, thumbnailFilename, 'image/jpeg');
  }

  /**
   * Delete file
   */
  async deleteFile(fileId: string, userId: string): Promise<void> {
    const file = await prisma.fileUpload.findFirst({
      where: { id: fileId, userId },
    });

    if (!file) {
      throw new Error('File not found');
    }

    if (this.useLocalStorage) {
      await this.deleteFromLocal(file.filename);
      if (file.thumbnailUrl) {
        const thumbnailPath = file.thumbnailUrl.replace('/uploads/', '');
        await this.deleteFromLocal(thumbnailPath);
      }
    } else {
      await this.deleteFromS3(file.filename);
      if (file.thumbnailUrl) {
        const thumbnailKey = file.thumbnailUrl.split('.com/')[1];
        await this.deleteFromS3(thumbnailKey);
      }
    }

    await prisma.fileUpload.delete({ where: { id: fileId } });
  }

  /**
   * Delete from S3
   */
  private async deleteFromS3(filename: string): Promise<void> {
    const command = new DeleteObjectCommand({
      Bucket: this.bucket,
      Key: filename,
    });

    await this.s3Client.send(command);
  }

  /**
   * Delete from local storage
   */
  private async deleteFromLocal(filename: string): Promise<void> {
    const fs = require('fs').promises;
    const filePath = path.join(process.cwd(), 'uploads', filename);

    try {
      await fs.unlink(filePath);
    } catch (error) {
      // File might not exist, ignore
    }
  }

  /**
   * Get user files
   */
  async getUserFiles(userId: string, category?: FileCategory) {
    return prisma.fileUpload.findMany({
      where: {
        userId,
        ...(category && { category }),
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Get signed URL for private file
   */
  async getSignedUrl(fileId: string, userId: string): Promise<string> {
    const file = await prisma.fileUpload.findFirst({
      where: { id: fileId, userId },
    });

    if (!file) {
      throw new Error('File not found');
    }

    if (this.useLocalStorage) {
      return file.url;
    }

    const command = new GetObjectCommand({
      Bucket: this.bucket,
      Key: file.filename,
    });

    return await getSignedUrl(this.s3Client, command, { expiresIn: 3600 });
  }

  /**
   * Validate file
   */
  private validateFile(file: UploadedFile, category: FileCategory): void {
    const maxSizes = {
      PROFILE_PICTURE: 5 * 1024 * 1024, // 5MB
      RESUME: 10 * 1024 * 1024, // 10MB
      CODE_FILE: 1 * 1024 * 1024, // 1MB
      DIAGRAM: 5 * 1024 * 1024, // 5MB
      SCREENSHOT: 5 * 1024 * 1024, // 5MB
      DOCUMENT: 10 * 1024 * 1024, // 10MB
      OTHER: 5 * 1024 * 1024, // 5MB
    };

    const allowedMimeTypes = {
      PROFILE_PICTURE: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
      RESUME: [
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      ],
      CODE_FILE: [
        'text/plain',
        'application/javascript',
        'text/x-python',
        'text/x-java',
      ],
      DIAGRAM: ['image/jpeg', 'image/png', 'image/svg+xml'],
      SCREENSHOT: ['image/jpeg', 'image/png'],
      DOCUMENT: [
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      ],
      OTHER: ['*'],
    };

    // Check file size
    if (file.size > maxSizes[category]) {
      throw new Error(
        `File size exceeds maximum allowed size of ${maxSizes[category] / 1024 / 1024}MB`,
      );
    }

    // Check mime type
    const allowed = allowedMimeTypes[category];
    if (!allowed.includes('*') && !allowed.includes(file.mimetype)) {
      throw new Error(`File type ${file.mimetype} not allowed for ${category}`);
    }
  }

  /**
   * Check if file is an image
   */
  private isImage(mimeType: string): boolean {
    return mimeType.startsWith('image/');
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\gamification.service.ts
==============================

// src/services/gamification.service.ts
import prisma from '../config/database';
import { MilestoneType } from '@prisma/client';

export class GamificationService {
  /**
   * Check and award achievements
   */
  async checkAchievements(userId: string) {
    const userProgress = await prisma.userProgress.findUnique({
      where: { userId },
    });

    if (!userProgress) return [];

    const newAchievements = [];

    // Check various achievement conditions
    const achievementChecks = [
      {
        code: 'first_interview',
        condition: userProgress.totalInterviews >= 1,
      },
      {
        code: 'interview_master',
        condition: userProgress.totalInterviews >= 100,
      },
      {
        code: 'perfect_score',
        condition: userProgress.perfectScores >= 1,
      },
      {
        code: 'perfect_10',
        condition: userProgress.perfectScores >= 10,
      },
      {
        code: 'week_streak',
        condition: userProgress.currentStreak >= 7,
      },
      {
        code: 'month_streak',
        condition: userProgress.currentStreak >= 30,
      },
      {
        code: 'century_club',
        condition: userProgress.problemsSolved >= 100,
      },
      {
        code: 'problem_crusher',
        condition: userProgress.problemsSolved >= 500,
      },
    ];

    for (const check of achievementChecks) {
      if (check.condition) {
        const achievement = await prisma.achievement.findUnique({
          where: { code: check.code },
        });

        if (achievement) {
          // Check if user already has this achievement
          const existing = await prisma.userAchievement.findUnique({
            where: {
              userId_achievementId: {
                userId,
                achievementId: achievement.id,
              },
            },
          });

          if (!existing) {
            const awarded = await prisma.userAchievement.create({
              data: {
                userId,
                achievementId: achievement.id,
              },
              include: { achievement: true },
            });

            newAchievements.push(awarded);
          }
        }
      }
    }

    return newAchievements;
  }

  /**
   * Update daily goal
   */
  async updateDailyGoal(
    userId: string,
    minutesStudied: number,
    questionsAnswered: number,
  ) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const preferences = await prisma.userPreferences.findUnique({
      where: { userId },
    });

    const goalMinutes = preferences?.dailyGoalMinutes || 30;
    const questionsGoal = 5;

    const dailyGoal = await prisma.dailyGoal.upsert({
      where: {
        userId_date: {
          userId,
          date: today,
        },
      },
      update: {
        actualMinutes: { increment: minutesStudied },
        questionsActual: { increment: questionsAnswered },
      },
      create: {
        userId,
        date: today,
        goalMinutes,
        questionsGoal,
        actualMinutes: minutesStudied,
        questionsActual: questionsAnswered,
      },
    });

    // Check if goal completed
    if (
      dailyGoal.actualMinutes >= dailyGoal.goalMinutes &&
      dailyGoal.questionsActual >= dailyGoal.questionsGoal &&
      !dailyGoal.isCompleted
    ) {
      await prisma.dailyGoal.update({
        where: { id: dailyGoal.id },
        data: { isCompleted: true },
      });

      // Update streak
      await this.updateStreak(userId, 'daily_practice');
    }

    return dailyGoal;
  }

  /**
   * Update streak
   */
  async updateStreak(userId: string, type: string) {
    const streak = await prisma.streak.findUnique({
      where: {
        userId_type: {
          userId,
          type,
        },
      },
    });

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    if (!streak) {
      // Create new streak
      return prisma.streak.create({
        data: {
          userId,
          type,
          current: 1,
          longest: 1,
          lastDate: today,
        },
      });
    }

    const lastDate = new Date(streak.lastDate || today);
    lastDate.setHours(0, 0, 0, 0);

    const daysDiff = Math.floor(
      (today.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24),
    );

    if (daysDiff === 0) {
      // Same day - no change
      return streak;
    } else if (daysDiff === 1) {
      // Consecutive day - increment
      const newCurrent = streak.current + 1;
      const newLongest = Math.max(newCurrent, streak.longest);

      const updated = await prisma.streak.update({
        where: { id: streak.id },
        data: {
          current: newCurrent,
          longest: newLongest,
          lastDate: today,
        },
      });

      // Update user progress
      await prisma.userProgress.update({
        where: { userId },
        data: {
          currentStreak: newCurrent,
          longestStreak: newLongest,
        },
      });

      return updated;
    } else {
      // Streak broken - reset
      return prisma.streak.update({
        where: { id: streak.id },
        data: {
          current: 1,
          lastDate: today,
        },
      });
    }
  }

  /**
   * Get user achievements
   */
  async getUserAchievements(userId: string) {
    return prisma.userAchievement.findMany({
      where: { userId },
      include: { achievement: true },
      orderBy: { unlockedAt: 'desc' },
    });
  }

  /**
   * Get leaderboard
   */
  async getLeaderboard(limit: number = 10) {
    const topUsers = await prisma.userProgress.findMany({
      take: limit,
      orderBy: { problemsSolved: 'desc' },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            profilePicture: true,
          },
        },
      },
    });

    return topUsers.map((progress, index) => ({
      rank: index + 1,
      userId: progress.userId,
      name: progress.user.name,
      profilePicture: progress.user.profilePicture,
      problemsSolved: progress.problemsSolved,
      averageScore: Number(progress.averageScore || 0),
      currentStreak: progress.currentStreak,
    }));
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\interview-replay.service.ts
==============================

// src/services/interview-replay.service.ts
import prisma from '../config/database';

interface ReplayStep {
  stepNumber: number;
  timestamp: Date;
  type: 'question' | 'answer' | 'hint' | 'feedback';
  data: any;
}

export class InterviewReplayService {
  /**
   * Get interview recording for replay
   */
  async getInterviewRecording(sessionId: string, userId: string) {
    const session = await prisma.interviewSession.findFirst({
      where: { id: sessionId, userId },
      include: {
        questions: {
          orderBy: { questionIndex: 'asc' },
        },
      },
    });

    if (!session) {
      throw new Error('Interview session not found');
    }

    if (!session.isReplayable) {
      throw new Error('This interview is not available for replay');
    }

    // Build replay timeline
    const timeline: ReplayStep[] = [];
    let stepNumber = 0;

    // Start event
    timeline.push({
      stepNumber: stepNumber++,
      timestamp: session.startTime,
      type: 'question',
      data: {
        action: 'interview_started',
        sessionInfo: {
          type: session.type,
          role: session.role,
          difficulty: session.difficulty,
          totalQuestions: session.totalQuestions,
          isTimed: session.isTimed,
          timeLimit: session.timeLimit,
        },
      },
    });

    // Questions and answers
    for (const question of session.questions) {
      // Question displayed
      timeline.push({
        stepNumber: stepNumber++,
        timestamp: question.createdAt,
        type: 'question',
        data: {
          questionIndex: question.questionIndex,
          question: question.question,
          category: question.category,
          difficulty: question.difficulty,
          hints: question.hints,
          timeAllocated: question.timeAllocated,
        },
      });

      // Answer submitted
      if (question.answeredAt) {
        timeline.push({
          stepNumber: stepNumber++,
          timestamp: question.answeredAt,
          type: 'answer',
          data: {
            questionIndex: question.questionIndex,
            userAnswer: question.userAnswer,
            userCode: question.userCode,
            timeSpent: question.timeSpent,
            wasAutoSubmitted: question.wasAutoSubmitted,
          },
        });

        // Feedback received
        if (question.feedback) {
          timeline.push({
            stepNumber: stepNumber++,
            timestamp: question.answeredAt,
            type: 'feedback',
            data: {
              questionIndex: question.questionIndex,
              score: question.score,
              feedback: question.feedback,
              isCorrect: question.isCorrect,
            },
          });
        }
      }
    }

    // End event
    if (session.endTime) {
      timeline.push({
        stepNumber: stepNumber++,
        timestamp: session.endTime,
        type: 'feedback',
        data: {
          action: 'interview_completed',
          finalScore: session.score,
          feedback: session.feedback,
        },
      });
    }

    return {
      session: {
        id: session.id,
        type: session.type,
        role: session.role,
        startTime: session.startTime,
        endTime: session.endTime,
        totalQuestions: session.totalQuestions,
        score: session.score,
      },
      timeline,
      totalSteps: timeline.length,
    };
  }

  /**
   * Start replay session
   */
  async startReplay(sessionId: string, userId: string) {
    const session = await prisma.interviewSession.findFirst({
      where: { id: sessionId, userId },
    });

    if (!session) {
      throw new Error('Interview session not found');
    }

    const recording = await this.getInterviewRecording(sessionId, userId);

    const replay = await prisma.interviewReplay.create({
      data: {
        sessionId,
        userId,
        totalSteps: recording.totalSteps,
      },
    });

    // Update replay count
    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: {
        replayCount: { increment: 1 },
        lastReplayedAt: new Date(),
      },
    });

    return {
      replayId: replay.id,
      recording,
    };
  }

  /**
   * Update replay progress
   */
  async updateReplayProgress(replayId: string, currentStep: number) {
    return prisma.interviewReplay.update({
      where: { id: replayId },
      data: { currentStep },
    });
  }

  /**
   * Complete replay
   */
  async completeReplay(replayId: string) {
    return prisma.interviewReplay.update({
      where: { id: replayId },
      data: { endTime: new Date() },
    });
  }

  /**
   * Set playback speed
   */
  async setPlaybackSpeed(replayId: string, speed: number) {
    if (speed < 0.5 || speed > 2.0) {
      throw new Error('Playback speed must be between 0.5 and 2.0');
    }

    return prisma.interviewReplay.update({
      where: { id: replayId },
      data: { playbackSpeed: speed },
    });
  }

  /**
   * Get user's replay history
   */
  async getReplayHistory(userId: string) {
    return prisma.interviewReplay.findMany({
      where: { userId },
      include: {
        session: {
          select: {
            type: true,
            role: true,
            score: true,
            startTime: true,
            totalQuestions: true,
          },
        },
      },
      orderBy: { startTime: 'desc' },
      take: 20,
    });
  }

  /**
   * Compare two interview attempts
   */
  async compareAttempts(
    sessionId1: string,
    sessionId2: string,
    userId: string,
  ) {
    const [session1, session2] = await Promise.all([
      prisma.interviewSession.findFirst({
        where: { id: sessionId1, userId },
        include: { questions: true },
      }),
      prisma.interviewSession.findFirst({
        where: { id: sessionId2, userId },
        include: { questions: true },
      }),
    ]);

    if (!session1 || !session2) {
      throw new Error('One or both sessions not found');
    }

    return {
      session1: {
        id: session1.id,
        date: session1.startTime,
        score: session1.score,
        timeSpent: session1.durationMinutes,
        questionsCorrect: session1.questions.filter((q) => q.isCorrect).length,
      },
      session2: {
        id: session2.id,
        date: session2.startTime,
        score: session2.score,
        timeSpent: session2.durationMinutes,
        questionsCorrect: session2.questions.filter((q) => q.isCorrect).length,
      },
      improvement: {
        scoreDelta: Number(session2.score || 0) - Number(session1.score || 0),
        timeDelta:
          (session2.durationMinutes || 0) - (session1.durationMinutes || 0),
        correctDelta:
          session2.questions.filter((q) => q.isCorrect).length -
          session1.questions.filter((q) => q.isCorrect).length,
      },
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\interview-session-manager.ts
==============================

/**
 * Interview Session Manager - FIXED VERSION
 * Manages mock interview sessions
 *
 * KEY FIX: Improved implementation detection to properly recognize valid code
 */

import { v4 as uuidv4 } from 'uuid';
import { InterviewSession, InterviewQuestion, AgentType } from '../types';
import { ILLMProvider } from '../services/llm/base-provider';
import { MemoryManager } from '../memory/memory-manager';
import { IVectorDatabase } from '../services/vector-db/base-vector-db';

export class InterviewSessionManager {
  private activeSessions: Map<string, InterviewSession> = new Map();

  constructor(
    private llmProvider: ILLMProvider,
    private memoryManager: MemoryManager,
    private vectorDb?: IVectorDatabase,
  ) {}

  /**
   * Start a new interview session
   */
  async startSession(
    userId: string,
    type: 'dsa' | 'system_design' | 'behavioral' | 'mixed',
    difficulty: 'easy' | 'medium' | 'hard' = 'medium',
    duration?: number,
    focusAreas?: string[],
  ): Promise<InterviewSession> {
    const sessionId = uuidv4();

    // Generate questions based on type and difficulty
    const questions = await this.generateQuestions(
      type,
      difficulty,
      focusAreas,
      duration,
    );

    const session: InterviewSession = {
      id: sessionId,
      userId,
      type,
      status: 'active',
      startTime: new Date(),
      questions,
      currentQuestionIndex: 0,
    };

    this.activeSessions.set(sessionId, session);

    // Create memory session
    await this.memoryManager.createSession(userId, sessionId);

    // Record in long-term memory
    const userMemory = await this.memoryManager.createUserMemory(userId);
    userMemory.interviewHistory.push(session);

    return session;
  }

  /**
   * Get current question
   */
  getCurrentQuestion(sessionId: string): InterviewQuestion | null {
    const session = this.activeSessions.get(sessionId);
    if (!session || session.currentQuestionIndex >= session.questions.length) {
      return null;
    }

    return session.questions[session.currentQuestionIndex];
  }

  /**
   * Submit answer to current question
   */
  async submitAnswer(
    sessionId: string,
    answer: string,
    timeSpent?: number,
  ): Promise<{
    feedback: string;
    score: number;
    nextQuestion: InterviewQuestion | null;
    sessionCompleted: boolean;
  }> {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error('Session not found');
    }

    const currentQuestion = session.questions[session.currentQuestionIndex];
    if (!currentQuestion) {
      throw new Error('No current question');
    }

    // Evaluate the answer
    const evaluation = await this.evaluateAnswer(
      currentQuestion,
      answer,
      session.type,
    );

    // Update question with answer and feedback
    currentQuestion.userAnswer = answer;
    currentQuestion.score = evaluation.score;
    currentQuestion.feedback = evaluation.feedback;
    currentQuestion.timeSpent = timeSpent;

    // Record weak areas if score is low
    if (evaluation.score < 60) {
      await this.memoryManager.recordWeakArea(
        session.userId,
        currentQuestion.category,
        session.type,
        [evaluation.feedback],
      );
    }

    // Move to next question
    session.currentQuestionIndex++;
    const nextQuestion =
      session.currentQuestionIndex < session.questions.length
        ? session.questions[session.currentQuestionIndex]
        : null;

    // Check if session is completed
    const sessionCompleted = nextQuestion === null;
    if (sessionCompleted) {
      await this.completeSession(sessionId);
    }

    return {
      feedback: evaluation.feedback,
      score: evaluation.score,
      nextQuestion,
      sessionCompleted,
    };
  }

  /**
   * Request a hint for current question
   */
  requestHint(sessionId: string): string | null {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      return null;
    }

    const currentQuestion = session.questions[session.currentQuestionIndex];
    if (!currentQuestion || !currentQuestion.hints) {
      return null;
    }

    const hintsUsed = currentQuestion.hintsUsed || 0;
    if (hintsUsed >= currentQuestion.hints.length) {
      return null;
    }

    currentQuestion.hintsUsed = hintsUsed + 1;
    return currentQuestion.hints[hintsUsed];
  }

  /**
   * Complete a session
   */
  private async completeSession(sessionId: string): Promise<void> {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      return;
    }

    session.status = 'completed';
    session.endTime = new Date();

    // Calculate overall score
    const totalScore = session.questions.reduce(
      (sum, q) => sum + (q.score || 0),
      0,
    );
    session.score = totalScore / session.questions.length;

    // Generate overall feedback
    session.feedback = await this.generateSessionFeedback(session);

    // Update learning progress
    await this.memoryManager.updateProgress(session.userId, {
      totalInterviews:
        (await this.memoryManager.getUserSummary(session.userId)).progress
          .totalInterviews + 1,
    });
  }

  /**
   * Get session by ID
   */
  getSession(sessionId: string): InterviewSession | null {
    return this.activeSessions.get(sessionId) || null;
  }

  /**
   * Pause a session
   */
  pauseSession(sessionId: string): void {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.status = 'paused';
    }
  }

  /**
   * Resume a session
   */
  resumeSession(sessionId: string): void {
    const session = this.activeSessions.get(sessionId);
    if (session) {
      session.status = 'active';
    }
  }

  /**
   * Generate questions for a session
   */
  private async generateQuestions(
    type: string,
    difficulty: string,
    focusAreas?: string[],
    duration?: number,
  ): Promise<InterviewQuestion[]> {
    // Calculate number of questions based on duration
    // Minimum 1 question, maximum 20 questions
    let questionCount: number;

    if (duration) {
      if (duration < 15) {
        questionCount = 1; // Very short sessions get 1 question
      } else if (duration < 30) {
        questionCount = 2; // 15-29 min gets 2 questions
      } else {
        questionCount = Math.min(Math.floor(duration / 15), 20); // 15 min per question, max 20
      }
    } else {
      questionCount = 5; // Default
    }

    console.log(
      `Generating ${questionCount} questions for ${duration} minute session`,
    );

    const questions: InterviewQuestion[] = [];

    for (let i = 0; i < questionCount; i++) {
      try {
        const question = await this.generateSingleQuestion(
          type,
          difficulty,
          focusAreas,
        );
        questions.push(question);
        console.log(
          `Generated question ${i + 1}/${questionCount}: ${question.question.substring(0, 50)}...`,
        );
      } catch (error) {
        console.error(`Failed to generate question ${i + 1}:`, error);
        // Continue generating other questions even if one fails
      }
    }

    // Ensure we have at least one question
    if (questions.length === 0) {
      throw new Error('Failed to generate any interview questions');
    }

    return questions;
  }

  /**
   * Generate a single question
   */
  private async generateSingleQuestion(
    type: string,
    difficulty: string,
    focusAreas?: string[],
  ): Promise<InterviewQuestion> {
    const focusContext = focusAreas
      ? `Focus on these areas: ${focusAreas.join(', ')}`
      : '';

    const prompt = `Generate a ${difficulty} level ${type} interview question.
${focusContext}

Include:
1. Clear question statement
2. Any necessary context
3. Expected complexity/depth
4. 2-3 hints (progressive)

Return as JSON.`;

    const schema = {
      question: 'string',
      category: 'string',
      hints: 'array of strings',
    };

    const generated = await this.llmProvider.generateStructuredOutput<{
      question: string;
      category: string;
      hints: string[];
    }>(
      {
        messages: [
          {
            role: 'system',
            content: 'You are an expert interview question generator.',
          },
          { role: 'user', content: prompt },
        ],
        temperature: 0.8,
        maxTokens: 1000,
      },
      schema,
    );

    return {
      id: uuidv4(),
      question: generated.question,
      difficulty: difficulty as 'easy' | 'medium' | 'hard',
      category: generated.category,
      hints: generated.hints,
      hintsUsed: 0,
    };
  }

  /**
   * Evaluate an answer - FIXED VERSION
   * Now properly detects and evaluates complete code implementations
   */
  private async evaluateAnswer(
    question: InterviewQuestion,
    answer: string,
    sessionType: string,
  ): Promise<{ score: number; feedback: string }> {
    // Check if this is a code submission
    const isCodeSubmission = this.isCodeSubmission(answer);

    if (isCodeSubmission) {
      // For code submissions, check if it has actual implementation
      const implementationCheck = this.hasActualImplementation(answer);

      console.log('Code Implementation Check:', implementationCheck); // Debug log

      if (!implementationCheck.hasImplementation) {
        return {
          score: 0,
          feedback: `‚ùå **No Implementation Detected**

Your submission appears to be just a function signature without implementation.

**What's missing:**
${implementationCheck.missing.join('\n')}

Please provide a complete solution with:
- Actual logic and control flow (loops, conditionals)
- Return statements with computed values
- Variable assignments and operations

Submit your complete working code to receive a proper evaluation.`,
        };
      }
    }

    // FIXED: Improved evaluation prompt
    const evaluationPrompt = `You are evaluating an interview answer. ${
      isCodeSubmission
        ? 'This submission CONTAINS ACTUAL CODE IMPLEMENTATION with logic, loops, and return statements. It is a COMPLETE working solution.'
        : ''
    }

Question: ${question.question}
Category: ${question.category}
Type: ${sessionType}
Difficulty: ${question.difficulty}

Answer:
${answer}

${
  isCodeSubmission
    ? `**CRITICAL INSTRUCTIONS FOR CODE EVALUATION:**
- This code HAS actual implementation (verified programmatically)
- This is NOT just a function signature - it has loops, logic, and return statements
- Do NOT say it's incomplete or just a signature
- Evaluate it as a COMPLETE, WORKING solution
- Assess correctness, efficiency, and code quality
- Provide scores between 70-100 for correct working solutions
- Give 50-69 for solutions with minor issues
- Only score below 50 if there are serious correctness problems

**Your task:** Evaluate this COMPLETE implementation fairly and accurately.`
    : ''
}

Provide a comprehensive evaluation with:

1. **Score (0-100)**
   ${
     isCodeSubmission
       ? `- 85-100: Optimal solution, handles all cases well
   - 70-84: Correct solution, minor optimization possible
   - 50-69: Works but has issues (edge cases, efficiency)
   - Below 50: Major correctness problems`
       : '- Based on completeness, accuracy, and clarity'
   }

2. **Detailed Feedback**
   - Start by acknowledging what was done correctly
   ${isCodeSubmission ? '- Recognize that implementation is complete (do NOT claim otherwise)' : ''}
   - What could be improved
   - Specific suggestions for enhancement
   ${isCodeSubmission ? '- Time/space complexity analysis\n   - Edge cases handled/missing' : ''}

Return as JSON with:
{
  "score": number,
  "feedback": "detailed feedback string"
}

Remember: If this is code, it has been verified to have implementation. Score it fairly as a complete solution.`;

    const schema = {
      score: 'number (0-100)',
      feedback: 'string',
    };

    return await this.llmProvider.generateStructuredOutput<{
      score: number;
      feedback: string;
    }>(
      {
        messages: [
          {
            role: 'system',
            content:
              'You are an expert interviewer who provides fair, accurate evaluations. You recognize complete code implementations and score them appropriately between 70-100 when they work correctly. You NEVER claim working code is incomplete.',
          },
          { role: 'user', content: evaluationPrompt },
        ],
        temperature: 0.3,
        maxTokens: 1500,
      },
      schema,
    );
  }

  /**
   * Check if answer is a code submission
   */
  private isCodeSubmission(answer: string): boolean {
    const codePatterns = [
      /function\s+\w+/,
      /const\s+\w+\s*=/,
      /let\s+\w+\s*=/,
      /def\s+\w+/,
      /class\s+\w+/,
      /public\s+\w+/,
    ];

    return codePatterns.some((pattern) => pattern.test(answer));
  }

  /**
   * Check if code has actual implementation (not just signature)
   * FULLY FIXED VERSION - Now properly detects your code!
   */
  private hasActualImplementation(code: string): {
    hasImplementation: boolean;
    missing: string[];
  } {
    // Super simple checks - does the code have basic programming elements?
    const hasReturn = code.includes('return');
    const hasFor = code.includes('for');
    const hasWhile = code.includes('while');
    const hasIf = code.includes('if');
    const hasLet = code.includes('let');
    const hasConst = code.includes('const');
    const hasVar = code.includes('var');

    const hasLoop = hasFor || hasWhile;
    const hasConditional = hasIf;
    const hasAssignment = hasLet || hasConst || hasVar;

    // Count actual lines of code (not empty, not just braces)
    const codeLines = code
      .split('\n')
      .map((line) => line.trim())
      .filter(
        (line) =>
          line.length > 0 &&
          line !== '{' &&
          line !== '}' &&
          !line.startsWith('//'),
      );

    const hasEnoughCode = codeLines.length >= 3;

    // Build missing list
    const missing: string[] = [];
    if (!hasReturn) missing.push('- Return statement');
    if (!hasLoop && !hasConditional) missing.push('- Loop or conditional');
    if (!hasAssignment) missing.push('- Variable declaration');
    if (!hasEnoughCode) missing.push('- Sufficient code (need 3+ lines)');

    // Simple logic: needs return AND (loop OR conditional) AND variable declaration
    const hasImplementation =
      hasReturn &&
      (hasLoop || hasConditional) &&
      hasAssignment &&
      hasEnoughCode;

    // Debug logging
    console.log('=== Code Implementation Check ===');
    console.log('Has return:', hasReturn);
    console.log('Has loop:', hasLoop);
    console.log('Has conditional:', hasConditional);
    console.log('Has assignment:', hasAssignment);
    console.log('Code lines:', codeLines.length);
    console.log('Has implementation:', hasImplementation);
    console.log('Missing:', missing.length === 0 ? 'Nothing!' : missing);
    console.log('=================================');

    return {
      hasImplementation,
      missing,
    };
  }

  /**
   * Generate overall session feedback
   */
  private async generateSessionFeedback(
    session: InterviewSession,
  ): Promise<string> {
    const questionSummary = session.questions
      .map(
        (q, i) =>
          `Q${i + 1}: ${q.question.substring(0, 100)}... Score: ${q.score || 0}/100`,
      )
      .join('\n');

    const prompt = `Generate overall feedback for this interview session:

Type: ${session.type}
Average Score: ${session.score}/100

Questions and Scores:
${questionSummary}

Provide:
1. Overall performance summary
2. Key strengths
3. Areas for improvement
4. Next steps for preparation`;

    const response = await this.llmProvider.generateCompletion({
      messages: [
        {
          role: 'system',
          content: 'You provide comprehensive interview feedback.',
        },
        { role: 'user', content: prompt },
      ],
      temperature: 0.7,
      maxTokens: 1000,
    });

    return response.content;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\learning-path.service.ts
==============================

// src/services/learning-path.service.ts
import prisma from '../config/database';
import { DeveloperRole, QuestionCategory, SkillLevel } from '@prisma/client';

interface LearningPathConfig {
  userId: string;
  targetRole: DeveloperRole;
  currentLevel: SkillLevel;
  targetDate?: Date;
  weeklyHours?: number;
}

export class LearningPathService {
  /**
   * Generate personalized learning path
   */
  async generateLearningPath(config: LearningPathConfig) {
    const {
      userId,
      targetRole,
      currentLevel,
      targetDate,
      weeklyHours = 10,
    } = config;

    // Calculate estimated weeks
    const estimatedWeeks = this.calculateEstimatedWeeks(
      currentLevel,
      targetRole,
      weeklyHours,
    );

    // Delete existing learning path
    await prisma.learningPath.deleteMany({ where: { userId } });

    // Create new learning path
    const learningPath = await prisma.learningPath.create({
      data: {
        userId,
        targetRole,
        totalPhases: this.getPhaseCount(targetRole),
        targetDate,
        estimatedWeeks,
      },
    });

    // Generate phases based on role
    const phases = this.generatePhases(targetRole, currentLevel);

    // Create phases with topics
    for (const phaseData of phases) {
      const phase = await prisma.learningPhase.create({
        data: {
          pathId: learningPath.id,
          phaseNumber: phaseData.phaseNumber,
          title: phaseData.title,
          description: phaseData.description,
          estimatedDays: phaseData.estimatedDays,
        },
      });

      // Create topics for this phase
      for (const topicData of phaseData.topics) {
        await prisma.learningTopic.create({
          data: {
            phaseId: phase.id,
            category: topicData.category,
            title: topicData.title,
            description: topicData.description,
            orderIndex: topicData.orderIndex,
            questionsToSolve: topicData.questionsToSolve,
            prerequisites: topicData.prerequisites || [],
          },
        });
      }
    }

    return this.getLearningPath(userId);
  }

  /**
   * Get user's learning path with progress
   */
  async getLearningPath(userId: string) {
    return prisma.learningPath.findUnique({
      where: { userId },
      include: {
        phases: {
          include: {
            topics: {
              include: {
                resources: true,
              },
              orderBy: { orderIndex: 'asc' },
            },
          },
          orderBy: { phaseNumber: 'asc' },
        },
      },
    });
  }

  /**
   * Mark topic as completed
   */
  async completeTopic(topicId: string) {
    const topic = await prisma.learningTopic.update({
      where: { id: topicId },
      data: {
        isCompleted: true,
        completedAt: new Date(),
      },
      include: { phase: true },
    });

    // Check if all topics in phase are completed
    const allTopics = await prisma.learningTopic.findMany({
      where: { phaseId: topic.phaseId },
    });

    const allCompleted = allTopics.every((t) => t.isCompleted);

    if (allCompleted) {
      await prisma.learningPhase.update({
        where: { id: topic.phaseId },
        data: {
          isCompleted: true,
          completedAt: new Date(),
        },
      });

      // Move to next phase
      await prisma.learningPath.update({
        where: { id: topic.phase.pathId },
        data: {
          currentPhase: { increment: 1 },
        },
      });
    }

    return topic;
  }

  /**
   * Update topic progress
   */
  async updateTopicProgress(
    topicId: string,
    questionsSolved: number,
    averageScore: number,
  ) {
    return prisma.learningTopic.update({
      where: { id: topicId },
      data: {
        questionsSolved,
        averageScore,
      },
    });
  }

  /**
   * Generate phases for role
   */
  private generatePhases(role: DeveloperRole, currentLevel: SkillLevel) {
    const commonPhases = [
      {
        phaseNumber: 1,
        title: 'Foundation',
        description: 'Build strong fundamentals',
        estimatedDays: 14,
        topics: [
          {
            category: 'ARRAYS' as QuestionCategory,
            title: 'Array Fundamentals',
            description: 'Master array operations and patterns',
            orderIndex: 1,
            questionsToSolve: 15,
            prerequisites: [],
          },
          {
            category: 'STRINGS' as QuestionCategory,
            title: 'String Manipulation',
            description: 'String algorithms and techniques',
            orderIndex: 2,
            questionsToSolve: 15,
            prerequisites: [],
          },
        ],
      },
    ];

    if (role === 'FRONTEND_DEVELOPER') {
      return [
        ...commonPhases,
        {
          phaseNumber: 2,
          title: 'Frontend Essentials',
          description: 'Core frontend technologies',
          estimatedDays: 21,
          topics: [
            {
              category: 'HTML_CSS' as QuestionCategory,
              title: 'HTML & CSS Mastery',
              description: 'Semantic HTML, modern CSS',
              orderIndex: 1,
              questionsToSolve: 20,
              prerequisites: [],
            },
            {
              category: 'JAVASCRIPT_ES6' as QuestionCategory,
              title: 'JavaScript ES6+',
              description: 'Modern JavaScript features',
              orderIndex: 2,
              questionsToSolve: 25,
              prerequisites: [],
            },
          ],
        },
        {
          phaseNumber: 3,
          title: 'React & State Management',
          description: 'Modern frontend frameworks',
          estimatedDays: 28,
          topics: [
            {
              category: 'REACT' as QuestionCategory,
              title: 'React Fundamentals',
              description: 'Components, hooks, lifecycle',
              orderIndex: 1,
              questionsToSolve: 30,
              prerequisites: ['JAVASCRIPT_ES6'],
            },
            {
              category: 'STATE_MANAGEMENT' as QuestionCategory,
              title: 'State Management',
              description: 'Redux, Context, Zustand',
              orderIndex: 2,
              questionsToSolve: 20,
              prerequisites: ['REACT'],
            },
          ],
        },
      ];
    } else if (role === 'BACKEND_DEVELOPER') {
      return [
        ...commonPhases,
        {
          phaseNumber: 2,
          title: 'Backend Fundamentals',
          description: 'Server-side development',
          estimatedDays: 21,
          topics: [
            {
              category: 'REST_API_DESIGN' as QuestionCategory,
              title: 'RESTful API Design',
              description: 'API best practices',
              orderIndex: 1,
              questionsToSolve: 20,
              prerequisites: [],
            },
            {
              category: 'DATABASE_DESIGN' as QuestionCategory,
              title: 'Database Design',
              description: 'Schema design, normalization',
              orderIndex: 2,
              questionsToSolve: 20,
              prerequisites: [],
            },
          ],
        },
        {
          phaseNumber: 3,
          title: 'Advanced Backend',
          description: 'Scalability and architecture',
          estimatedDays: 28,
          topics: [
            {
              category: 'MICROSERVICES' as QuestionCategory,
              title: 'Microservices Architecture',
              description: 'Distributed systems',
              orderIndex: 1,
              questionsToSolve: 15,
              prerequisites: ['REST_API_DESIGN'],
            },
            {
              category: 'CACHING' as QuestionCategory,
              title: 'Caching Strategies',
              description: 'Redis, CDN, cache patterns',
              orderIndex: 2,
              questionsToSolve: 15,
              prerequisites: ['DATABASE_DESIGN'],
            },
          ],
        },
      ];
    }

    return commonPhases;
  }

  /**
   * Calculate estimated weeks
   */
  private calculateEstimatedWeeks(
    currentLevel: SkillLevel,
    targetRole: DeveloperRole,
    weeklyHours: number,
  ): number {
    const levelMultipliers = {
      BEGINNER: 1.5,
      INTERMEDIATE: 1.0,
      ADVANCED: 0.7,
      EXPERT: 0.5,
    };

    const roleComplexity = {
      DSA_SPECIALIST: 12,
      FRONTEND_DEVELOPER: 10,
      BACKEND_DEVELOPER: 10,
      FULLSTACK_DEVELOPER: 14,
      MOBILE_DEVELOPER: 12,
      DEVOPS_ENGINEER: 10,
    };

    const baseWeeks = roleComplexity[targetRole];
    const multiplier = levelMultipliers[currentLevel];
    const hoursAdjustment = 10 / weeklyHours;

    return Math.ceil(baseWeeks * multiplier * hoursAdjustment);
  }

  /**
   * Get phase count for role
   */
  private getPhaseCount(role: DeveloperRole): number {
    const phaseCounts = {
      DSA_SPECIALIST: 4,
      FRONTEND_DEVELOPER: 4,
      BACKEND_DEVELOPER: 4,
      FULLSTACK_DEVELOPER: 5,
      MOBILE_DEVELOPER: 4,
      DEVOPS_ENGINEER: 4,
    };

    return phaseCounts[role];
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\llm\anthropic-provider.ts
==============================

/**
 * Anthropic Claude LLM Provider Implementation
 */

import Anthropic from '@anthropic-ai/sdk';
import { BaseLLMProvider } from './base-provider';
import { LLMRequest, LLMResponse, LLMMessage } from '../../types';

export class AnthropicProvider extends BaseLLMProvider {
  readonly name = 'Anthropic';
  private client: Anthropic;

  constructor(apiKey: string, defaultModel: string = 'claude-3-5-sonnet-20241022') {
    super(apiKey, defaultModel);
    this.client = new Anthropic({ apiKey });
  }

  async generateCompletion(request: LLMRequest): Promise<LLMResponse> {
    try {
      // Anthropic requires system message separate from messages array
      const systemMessage = request.messages.find((m) => m.role === 'system');
      const conversationMessages = request.messages.filter(
        (m) => m.role !== 'system'
      );

      const response = await this.client.messages.create({
        model: request.model || this.defaultModel,
        max_tokens: request.maxTokens ?? 2000,
        temperature: request.temperature ?? 0.7,
        system: systemMessage?.content,
        messages: conversationMessages.map((m) => ({
          role: m.role as 'user' | 'assistant',
          content: m.content,
        })),
      });

      const textContent = response.content.find((c) => c.type === 'text');
      if (!textContent || textContent.type !== 'text') {
        throw new Error('No text content in Anthropic response');
      }

      return {
        content: textContent.text,
        usage: {
          promptTokens: response.usage.input_tokens,
          completionTokens: response.usage.output_tokens,
          totalTokens: response.usage.input_tokens + response.usage.output_tokens,
        },
        model: response.model,
      };
    } catch (error) {
      console.error('Anthropic completion error:', error);
      throw new Error(
        `Anthropic provider error: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async generateStructuredOutput<T>(
    request: LLMRequest,
    schema: Record<string, unknown>
  ): Promise<T> {
    // Enhance the system message to request JSON output
    const enhancedMessages = [...request.messages];
    const systemMessageIndex = enhancedMessages.findIndex((m) => m.role === 'system');

    const jsonInstruction = `\n\nYou must respond with valid JSON matching this schema: ${JSON.stringify(schema)}\nDo not include any text before or after the JSON object.`;

    if (systemMessageIndex !== -1) {
      enhancedMessages[systemMessageIndex].content += jsonInstruction;
    } else {
      enhancedMessages.unshift({
        role: 'system',
        content: `Respond with valid JSON matching this schema: ${JSON.stringify(schema)}`,
      });
    }

    const response = await this.generateCompletion({
      ...request,
      messages: enhancedMessages,
      temperature: request.temperature ?? 0.3, // Lower temp for structured output
    });

    try {
      const cleanedContent = this.extractJSON(response.content);
      return JSON.parse(cleanedContent) as T;
    } catch (error) {
      console.error('Failed to parse JSON response:', response.content);
      throw new Error('Failed to parse structured output from Anthropic');
    }
  }

  async isAvailable(): Promise<boolean> {
    try {
      // Simple check - try to make a minimal request
      await this.client.messages.create({
        model: this.defaultModel,
        max_tokens: 10,
        messages: [{ role: 'user', content: 'test' }],
      });
      return true;
    } catch {
      return false;
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\llm\base-provider.ts
==============================

/**
 * Abstract LLM Provider Interface
 * This abstraction allows swapping between OpenAI, Anthropic, or other providers
 */

import { LLMRequest, LLMResponse, LLMMessage } from '../../types';

/**
 * Base interface all LLM providers must implement
 */
export interface ILLMProvider {
  /**
   * Provider name
   */
  readonly name: string;

  /**
   * Generate completion from messages
   */
  generateCompletion(request: LLMRequest): Promise<LLMResponse>;

  /**
   * Generate structured JSON output
   */
  generateStructuredOutput<T>(
    request: LLMRequest,
    schema: Record<string, unknown>
  ): Promise<T>;

  /**
   * Check if provider is available/configured
   */
  isAvailable(): Promise<boolean>;
}

/**
 * Base abstract class with common functionality
 */
export abstract class BaseLLMProvider implements ILLMProvider {
  abstract readonly name: string;
  protected apiKey: string;
  protected defaultModel: string;

  constructor(apiKey: string, defaultModel: string) {
    this.apiKey = apiKey;
    this.defaultModel = defaultModel;
  }

  abstract generateCompletion(request: LLMRequest): Promise<LLMResponse>;

  abstract generateStructuredOutput<T>(
    request: LLMRequest,
    schema: Record<string, unknown>
  ): Promise<T>;

  async isAvailable(): Promise<boolean> {
    return !!this.apiKey;
  }

  /**
   * Helper to build messages with system prompt
   */
  protected buildMessages(
    systemPrompt: string,
    userMessage: string,
    conversationHistory?: LLMMessage[]
  ): LLMMessage[] {
    const messages: LLMMessage[] = [
      { role: 'system', content: systemPrompt },
    ];

    if (conversationHistory && conversationHistory.length > 0) {
      messages.push(...conversationHistory);
    }

    messages.push({ role: 'user', content: userMessage });

    return messages;
  }

  /**
   * Helper to extract JSON from markdown code blocks
   */
  protected extractJSON(content: string): string {
    // Remove markdown code blocks if present
    const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (jsonMatch) {
      return jsonMatch[1].trim();
    }
    return content.trim();
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\llm\groq-provider.ts
==============================

/**
 * Groq LLM Provider Implementation
 */

import Groq from 'groq-sdk';
import { BaseLLMProvider } from './base-provider';
import { LLMRequest, LLMResponse } from '../../types';

export class GroqProvider extends BaseLLMProvider {
  readonly name = 'Groq';
  private client: Groq;

  constructor(
    apiKey: string,
    defaultModel: string = 'llama-3.3-70b-versatile',
  ) {
    super(apiKey, defaultModel);
    this.client = new Groq({ apiKey });
  }

  async generateCompletion(request: LLMRequest): Promise<LLMResponse> {
    try {
      const completion = await this.client.chat.completions.create({
        model: request.model || this.defaultModel,
        messages: request.messages.map((m) => ({
          role: m.role,
          content: m.content,
        })),
        temperature: request.temperature ?? 0.7,
        max_tokens: request.maxTokens ?? 2000,
        stream: false,
      });

      const choice = completion.choices[0];
      if (!choice || !choice.message) {
        throw new Error('No response from Groq');
      }

      return {
        content: choice.message.content || '',
        usage: completion.usage
          ? {
              promptTokens: completion.usage.prompt_tokens,
              completionTokens: completion.usage.completion_tokens,
              totalTokens: completion.usage.total_tokens,
            }
          : undefined,
        model: completion.model,
      };
    } catch (error) {
      console.error('Groq completion error:', error);
      throw new Error(
        `Groq provider error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async generateStructuredOutput<T>(
    request: LLMRequest,
    schema: Record<string, unknown>,
  ): Promise<T> {
    // Enhance the system message to request JSON output
    const enhancedMessages = [...request.messages];
    const systemMessageIndex = enhancedMessages.findIndex(
      (m) => m.role === 'system',
    );

    const jsonInstruction = `\n\nYou must respond with valid JSON matching this schema: ${JSON.stringify(schema)}\nDo not include any text before or after the JSON object. Do not use markdown code blocks.`;

    if (systemMessageIndex !== -1) {
      enhancedMessages[systemMessageIndex].content += jsonInstruction;
    } else {
      enhancedMessages.unshift({
        role: 'system',
        content: `Respond with valid JSON matching this schema: ${JSON.stringify(schema)}`,
      });
    }

    const response = await this.generateCompletion({
      ...request,
      messages: enhancedMessages,
      temperature: request.temperature ?? 0.3, // Lower temp for structured output
    });

    try {
      const cleanedContent = this.extractJSON(response.content);
      return JSON.parse(cleanedContent) as T;
    } catch (error) {
      console.error('Failed to parse JSON response:', response.content);
      throw new Error('Failed to parse structured output from Groq');
    }
  }

  async isAvailable(): Promise<boolean> {
    try {
      // Simple check - try to make a minimal request
      await this.client.chat.completions.create({
        model: this.defaultModel,
        messages: [{ role: 'user', content: 'test' }],
        max_tokens: 10,
      });
      return true;
    } catch {
      return false;
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\llm\openai-provider.ts
==============================

/**
 * OpenAI LLM Provider Implementation
 */

import OpenAI from 'openai';
import { BaseLLMProvider } from './base-provider';
import { LLMRequest, LLMResponse } from '../../types';

export class OpenAIProvider extends BaseLLMProvider {
  readonly name = 'OpenAI';
  private client: OpenAI;

  constructor(apiKey: string, defaultModel: string = 'gpt-4-turbo-preview') {
    super(apiKey, defaultModel);
    this.client = new OpenAI({ apiKey });
  }

  async generateCompletion(request: LLMRequest): Promise<LLMResponse> {
    try {
      const completion = await this.client.chat.completions.create({
        model: request.model || this.defaultModel,
        messages: request.messages,
        temperature: request.temperature ?? 0.7,
        max_tokens: request.maxTokens ?? 2000,
        stream: false,
      });

      const choice = completion.choices[0];
      if (!choice || !choice.message) {
        throw new Error('No response from OpenAI');
      }

      return {
        content: choice.message.content || '',
        usage: completion.usage
          ? {
              promptTokens: completion.usage.prompt_tokens,
              completionTokens: completion.usage.completion_tokens,
              totalTokens: completion.usage.total_tokens,
            }
          : undefined,
        model: completion.model,
      };
    } catch (error) {
      console.error('OpenAI completion error:', error);
      throw new Error(
        `OpenAI provider error: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async generateStructuredOutput<T>(
    request: LLMRequest,
    schema: Record<string, unknown>
  ): Promise<T> {
    // Enhance the system message to request JSON output
    const enhancedMessages = [...request.messages];
    const systemMessage = enhancedMessages.find((m) => m.role === 'system');

    if (systemMessage) {
      systemMessage.content += `\n\nYou must respond with valid JSON matching this schema: ${JSON.stringify(schema)}`;
    } else {
      enhancedMessages.unshift({
        role: 'system',
        content: `Respond with valid JSON matching this schema: ${JSON.stringify(schema)}`,
      });
    }

    const response = await this.generateCompletion({
      ...request,
      messages: enhancedMessages,
      temperature: request.temperature ?? 0.3, // Lower temp for structured output
    });

    try {
      const cleanedContent = this.extractJSON(response.content);
      return JSON.parse(cleanedContent) as T;
    } catch (error) {
      console.error('Failed to parse JSON response:', response.content);
      throw new Error('Failed to parse structured output from OpenAI');
    }
  }

  async isAvailable(): Promise<boolean> {
    try {
      await this.client.models.list();
      return true;
    } catch {
      return false;
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\llm\provider-factory.ts
==============================

/**
 * LLM Provider Factory
 * Central factory for creating LLM provider instances
 * Updated to include Groq support
 */

import { ILLMProvider } from './base-provider';
import { OpenAIProvider } from './openai-provider';
import { AnthropicProvider } from './anthropic-provider';
import { GroqProvider } from './groq-provider';
import { LLMProvider } from '../../types';

export class LLMProviderFactory {
  private static instance: LLMProviderFactory;
  private currentProvider: ILLMProvider | null = null;

  private constructor() {}

  static getInstance(): LLMProviderFactory {
    if (!LLMProviderFactory.instance) {
      LLMProviderFactory.instance = new LLMProviderFactory();
    }
    return LLMProviderFactory.instance;
  }

  /**
   * Create and configure an LLM provider
   */
  createProvider(
    providerType: LLMProvider,
    apiKey: string,
    defaultModel?: string,
  ): ILLMProvider {
    switch (providerType) {
      case LLMProvider.OPENAI:
        this.currentProvider = new OpenAIProvider(apiKey, defaultModel);
        break;
      case LLMProvider.ANTHROPIC:
        this.currentProvider = new AnthropicProvider(apiKey, defaultModel);
        break;
      case LLMProvider.GROQ:
        this.currentProvider = new GroqProvider(apiKey, defaultModel);
        break;
      default:
        throw new Error(`Unsupported LLM provider: ${providerType}`);
    }

    return this.currentProvider;
  }

  /**
   * Get the current provider instance
   */
  getCurrentProvider(): ILLMProvider {
    if (!this.currentProvider) {
      throw new Error(
        'No LLM provider initialized. Call createProvider first.',
      );
    }
    return this.currentProvider;
  }

  /**
   * Initialize from environment variables
   */
  static initializeFromEnv(): ILLMProvider {
    const factory = LLMProviderFactory.getInstance();

    const providerType = (process.env.LLM_PROVIDER?.toLowerCase() ||
      'openai') as LLMProvider;
    const defaultModel = process.env.DEFAULT_MODEL;

    let apiKey: string;

    switch (providerType) {
      case LLMProvider.OPENAI:
        apiKey = process.env.OPENAI_API_KEY || '';
        break;
      case LLMProvider.ANTHROPIC:
        apiKey = process.env.ANTHROPIC_API_KEY || '';
        break;
      case LLMProvider.GROQ:
        apiKey = process.env.GROQ_API_KEY || '';
        break;
      default:
        throw new Error(`Unsupported LLM provider in env: ${providerType}`);
    }

    if (!apiKey) {
      throw new Error(`API key not found for provider: ${providerType}`);
    }

    return factory.createProvider(providerType, apiKey, defaultModel);
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\question-rating.service.ts
==============================

// src/services/question-rating.service.ts
import prisma from '../config/database';
import { Prisma } from '@prisma/client';

export class QuestionRatingService {
  /**
   * Rate question difficulty
   */
  async rateQuestion(
    questionId: string,
    userId: string,
    rating: number,
    comment?: string,
  ) {
    if (rating < 1 || rating > 5) {
      throw new Error('Rating must be between 1 and 5');
    }

    // Create or update rating
    const userRating = await prisma.questionDifficultyRating.upsert({
      where: {
        questionId_userId: {
          questionId,
          userId,
        },
      },
      update: {
        rating,
        comment,
      },
      create: {
        questionId,
        userId,
        rating,
        comment,
      },
    });

    // Recalculate community difficulty
    await this.updateCommunityDifficulty(questionId);

    return userRating;
  }

  /**
   * Update community difficulty average
   */
  private async updateCommunityDifficulty(questionId: string) {
    const ratings = await prisma.questionDifficultyRating.findMany({
      where: { questionId },
    });

    if (ratings.length === 0) return;

    const averageRating =
      ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length;

    await prisma.questionBank.update({
      where: { id: questionId },
      data: {
        communityDifficulty: averageRating,
        totalRatings: ratings.length,
      },
    });
  }

  /**
   * Get question ratings
   */
  async getQuestionRatings(questionId: string) {
    const question = await prisma.questionBank.findUnique({
      where: { id: questionId },
      include: {
        difficultyRatings: {
          take: 10,
          orderBy: { createdAt: 'desc' },
        },
      },
    });

    if (!question) {
      throw new Error('Question not found');
    }

    const ratingDistribution = await prisma.questionDifficultyRating.groupBy({
      by: ['rating'],
      where: { questionId },
      _count: { rating: true },
    });

    return {
      officialDifficulty: question.difficulty,
      communityDifficulty: question.communityDifficulty
        ? Number(question.communityDifficulty)
        : null,
      totalRatings: question.totalRatings,
      ratingDistribution: ratingDistribution.map((r) => ({
        rating: r.rating,
        count: r._count.rating,
      })),
      recentRatings: question.difficultyRatings,
    };
  }

  /**
   * Get user's rating for a question
   */
  async getUserRating(questionId: string, userId: string) {
    return prisma.questionDifficultyRating.findUnique({
      where: {
        questionId_userId: {
          questionId,
          userId,
        },
      },
    });
  }

  /**
   * Get rating statistics
   */
  async getRatingStats(questionId: string) {
    const ratings = await prisma.questionDifficultyRating.findMany({
      where: { questionId },
    });

    if (ratings.length === 0) {
      return {
        average: 0,
        total: 0,
        distribution: {},
      };
    }

    const distribution: Record<number, number> = {
      1: 0,
      2: 0,
      3: 0,
      4: 0,
      5: 0,
    };

    ratings.forEach((r) => {
      distribution[r.rating]++;
    });

    const average =
      ratings.reduce((sum, r) => sum + r.rating, 0) / ratings.length;

    return {
      average,
      total: ratings.length,
      distribution,
      interpretation: this.interpretRating(average),
    };
  }

  /**
   * Interpret average rating
   */
  private interpretRating(average: number): string {
    if (average <= 1.5) return 'Too Easy';
    if (average <= 2.5) return 'Easy';
    if (average <= 3.5) return 'Just Right';
    if (average <= 4.5) return 'Hard';
    return 'Too Hard';
  }

  /**
   * Get questions needing difficulty adjustment
   */
  async getQuestionsNeedingAdjustment() {
    const questions = await prisma.questionBank.findMany({
      where: {
        totalRatings: { gte: 10 }, // At least 10 ratings
        isActive: true,
      },
      include: {
        difficultyRatings: true,
      },
    });

    const needsAdjustment = questions.filter((q) => {
      if (!q.communityDifficulty) return false;

      const officialDifficultyMap = {
        EASY: 2,
        MEDIUM: 3,
        HARD: 4,
      };

      const officialValue = officialDifficultyMap[q.difficulty];
      const communityValue = Number(q.communityDifficulty);

      // If difference is more than 1 point
      return Math.abs(officialValue - communityValue) > 1;
    });

    return needsAdjustment.map((q) => ({
      id: q.id,
      question: q.question.substring(0, 100),
      officialDifficulty: q.difficulty,
      communityDifficulty: Number(q.communityDifficulty),
      totalRatings: q.totalRatings,
      suggestedDifficulty: this.suggestDifficulty(
        Number(q.communityDifficulty),
      ),
    }));
  }

  /**
   * Suggest difficulty based on community rating
   */
  private suggestDifficulty(average: number): 'EASY' | 'MEDIUM' | 'HARD' {
    if (average <= 2.5) return 'EASY';
    if (average <= 3.5) return 'MEDIUM';
    return 'HARD';
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\recommendation.service.ts
==============================

// src/services/recommendation.service.ts
import prisma from '../config/database';
import { QuestionCategory, SkillLevel } from '@prisma/client';

export class RecommendationService {
  /**
   * Generate personalized recommendations
   */
  async generateRecommendations(userId: string) {
    // Clear old recommendations
    await prisma.recommendation.updateMany({
      where: {
        userId,
        createdAt: { lt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
      },
      data: { isDismissed: true },
    });

    const [weakAreas, skillAssessments, userProgress] = await Promise.all([
      prisma.weakArea.findMany({
        where: { userId },
        orderBy: { failureCount: 'desc' },
        take: 5,
      }),
      prisma.skillAssessment.findMany({
        where: { userId },
        orderBy: { confidence: 'asc' },
        take: 5,
      }),
      prisma.userProgress.findUnique({
        where: { userId },
      }),
    ]);

    const recommendations = [];

    // Recommend weak areas practice
    for (const weak of weakAreas.slice(0, 2)) {
      const questions = await this.findRelevantQuestions(
        weak.category as QuestionCategory,
        5,
      );

      recommendations.push({
        userId,
        type: 'practice_weak_area',
        title: `Practice ${weak.topic}`,
        description: `You've struggled with ${weak.topic}. Solve ${questions.length} problems to improve.`,
        priority: 10,
        category: weak.category as QuestionCategory,
        questionIds: questions.map((q) => q.id),
      });
    }

    // Recommend low confidence topics
    for (const skill of skillAssessments.slice(0, 2)) {
      if (Number(skill.confidence) < 0.5) {
        const questions = await this.findRelevantQuestions(skill.category, 5);

        recommendations.push({
          userId,
          type: 'build_confidence',
          title: `Build confidence in ${skill.category}`,
          description: `Your confidence in ${skill.category} is low. Start with easy problems.`,
          priority: 8,
          category: skill.category,
          questionIds: questions.map((q) => q.id),
        });
      }
    }

    // Recommend next topic based on learning path
    const nextTopic = await this.getNextRecommendedTopic(userId);
    if (nextTopic) {
      const questions = await this.findRelevantQuestions(
        nextTopic.category,
        10,
      );

      recommendations.push({
        userId,
        type: 'next_topic',
        title: `Start learning ${nextTopic.title}`,
        description:
          nextTopic.description || `Begin with ${nextTopic.category}`,
        priority: 7,
        category: nextTopic.category,
        questionIds: questions.map((q) => q.id),
      });
    }

    // Recommend spaced repetition
    const dueReviews = await prisma.spacedRepetitionItem.count({
      where: {
        userId,
        nextReview: { lte: new Date() },
        isRetired: false,
      },
    });

    if (dueReviews > 0) {
      recommendations.push({
        userId,
        type: 'spaced_review',
        title: 'Review due questions',
        description: `You have ${dueReviews} questions due for review. Keep your knowledge fresh!`,
        priority: 9,
        questionIds: [],
      });
    }

    // Create recommendations in database
    for (const rec of recommendations) {
      await prisma.recommendation.create({
        data: {
          ...rec,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        },
      });
    }

    return this.getRecommendations(userId);
  }

  /**
   * Get active recommendations
   */
  async getRecommendations(userId: string) {
    return prisma.recommendation.findMany({
      where: {
        userId,
        isDismissed: false,
        isCompleted: false,
        OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],
      },
      orderBy: { priority: 'desc' },
    });
  }

  /**
   * Mark recommendation as completed
   */
  async completeRecommendation(recommendationId: string) {
    return prisma.recommendation.update({
      where: { id: recommendationId },
      data: { isCompleted: true },
    });
  }

  /**
   * Dismiss recommendation
   */
  async dismissRecommendation(recommendationId: string) {
    return prisma.recommendation.update({
      where: { id: recommendationId },
      data: { isDismissed: true },
    });
  }

  /**
   * Find relevant questions
   */
  private async findRelevantQuestions(
    category: QuestionCategory,
    limit: number,
  ) {
    return prisma.questionBank.findMany({
      where: {
        category,
        isActive: true,
      },
      orderBy: { frequency: 'desc' },
      take: limit,
    });
  }

  /**
   * Get next recommended topic from learning path
   */
  private async getNextRecommendedTopic(userId: string) {
    const learningPath = await prisma.learningPath.findUnique({
      where: { userId },
      include: {
        phases: {
          include: {
            topics: {
              where: { isCompleted: false },
              orderBy: { orderIndex: 'asc' },
              take: 1,
            },
          },
          where: { isCompleted: false },
          orderBy: { phaseNumber: 'asc' },
          take: 1,
        },
      },
    });

    return learningPath?.phases[0]?.topics[0] || null;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\spaced-repetition.service.ts
==============================

// src/services/spaced-repetition.service.ts
import prisma from '../config/database';
import { QuestionCategory } from '@prisma/client';

/**
 * SM-2 Algorithm for Spaced Repetition
 * Used for optimal learning retention
 */
export class SpacedRepetitionService {
  /**
   * Get questions due for review
   */
  async getDueReviews(userId: string, limit: number = 10) {
    const now = new Date();

    return prisma.spacedRepetitionItem.findMany({
      where: {
        userId,
        nextReview: { lte: now },
        isRetired: false,
      },
      orderBy: { nextReview: 'asc' },
      take: limit,
    });
  }

  /**
   * Record review and update schedule
   */
  async recordReview(
    itemId: string,
    quality: number, // 0-5 scale (0=complete blackout, 5=perfect)
  ) {
    const item = await prisma.spacedRepetitionItem.findUnique({
      where: { id: itemId },
    });

    if (!item) {
      throw new Error('Spaced repetition item not found');
    }

    // SM-2 Algorithm calculations
    let easeFactor = Number(item.easeFactor);
    let interval = item.interval;
    let repetitions = item.repetitions;

    // Update ease factor
    easeFactor =
      easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));

    // Ensure ease factor doesn't go below 1.3
    if (easeFactor < 1.3) easeFactor = 1.3;

    // Calculate new interval
    if (quality < 3) {
      // Failed recall - reset
      repetitions = 0;
      interval = 1;
    } else {
      repetitions += 1;
      if (repetitions === 1) {
        interval = 1;
      } else if (repetitions === 2) {
        interval = 6;
      } else {
        interval = Math.round(interval * easeFactor);
      }
    }

    // Calculate next review date
    const nextReview = new Date();
    nextReview.setDate(nextReview.getDate() + interval);

    // Check if item should be retired (mastered)
    const isRetired = repetitions >= 10 && easeFactor >= 2.5;

    // Update item
    return prisma.spacedRepetitionItem.update({
      where: { id: itemId },
      data: {
        easeFactor,
        interval,
        repetitions,
        lastReviewed: new Date(),
        nextReview,
        isRetired,
      },
    });
  }

  /**
   * Add question to spaced repetition
   */
  async addQuestion(
    userId: string,
    questionId: string,
    category: QuestionCategory,
  ) {
    return prisma.spacedRepetitionItem.upsert({
      where: {
        userId_questionId: {
          userId,
          questionId,
        },
      },
      update: {
        isRetired: false,
      },
      create: {
        userId,
        questionId,
        category,
        nextReview: new Date(),
      },
    });
  }

  /**
   * Get spaced repetition stats
   */
  async getStats(userId: string) {
    const now = new Date();

    const [total, due, mastered] = await Promise.all([
      prisma.spacedRepetitionItem.count({
        where: { userId, isRetired: false },
      }),
      prisma.spacedRepetitionItem.count({
        where: {
          userId,
          nextReview: { lte: now },
          isRetired: false,
        },
      }),
      prisma.spacedRepetitionItem.count({
        where: { userId, isRetired: true },
      }),
    ]);

    return {
      totalCards: total,
      dueForReview: due,
      mastered,
      learningRate: total > 0 ? (mastered / (total + mastered)) * 100 : 0,
    };
  }

  /**
   * Get review schedule for next 7 days
   */
  async getReviewSchedule(userId: string, days: number = 7) {
    const schedule = [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    for (let i = 0; i < days; i++) {
      const date = new Date(today);
      date.setDate(today.getDate() + i);

      const nextDay = new Date(date);
      nextDay.setDate(date.getDate() + 1);

      const count = await prisma.spacedRepetitionItem.count({
        where: {
          userId,
          nextReview: {
            gte: date,
            lt: nextDay,
          },
          isRetired: false,
        },
      });

      schedule.push({
        date,
        reviewCount: count,
      });
    }

    return schedule;
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\timer.service.ts
==============================

// src/services/timer.service.ts
import prisma from '../config/database';

export class TimerService {
  /**
   * Start timer for interview session
   */
  async startSessionTimer(sessionId: string): Promise<void> {
    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: {
        timerStartedAt: new Date(),
        timerPausedAt: null,
      },
    });
  }

  /**
   * Start timer for specific question
   */
  async startQuestionTimer(
    questionId: string,
    timeAllocated: number,
  ): Promise<void> {
    await prisma.interviewQuestion.update({
      where: { id: questionId },
      data: {
        timeStarted: new Date(),
        timeAllocated,
      },
    });
  }

  /**
   * Pause timer
   */
  async pauseTimer(sessionId: string): Promise<void> {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
    });

    if (!session || !session.timerStartedAt) {
      throw new Error('Timer not started');
    }

    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: {
        timerPausedAt: new Date(),
      },
    });
  }

  /**
   * Resume timer
   */
  async resumeTimer(sessionId: string): Promise<void> {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
    });

    if (!session || !session.timerPausedAt) {
      throw new Error('Timer not paused');
    }

    const pausedDuration = Math.floor(
      (new Date().getTime() - session.timerPausedAt.getTime()) / 1000,
    );

    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: {
        totalTimePaused: session.totalTimePaused + pausedDuration,
        timerPausedAt: null,
      },
    });
  }

  /**
   * Calculate time remaining
   */
  async getTimeRemaining(sessionId: string): Promise<number> {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
    });

    if (!session || !session.isTimed || !session.timeLimit) {
      return -1; // No time limit
    }

    if (!session.timerStartedAt) {
      return session.timeLimit * 60; // Return full time if not started
    }

    const now = session.timerPausedAt || new Date();
    const elapsedSeconds = Math.floor(
      (now.getTime() - session.timerStartedAt.getTime()) / 1000,
    );

    const effectiveElapsed = elapsedSeconds - session.totalTimePaused;
    const remainingSeconds = session.timeLimit * 60 - effectiveElapsed;

    return Math.max(0, remainingSeconds);
  }

  /**
   * Get question time spent
   */
  async getQuestionTimeSpent(questionId: string): Promise<number> {
    const question = await prisma.interviewQuestion.findUnique({
      where: { id: questionId },
    });

    if (!question || !question.timeStarted) {
      return 0;
    }

    const endTime = question.timeSubmitted || new Date();
    const timeSpent = Math.floor(
      (endTime.getTime() - question.timeStarted.getTime()) / 1000,
    );

    return timeSpent;
  }

  /**
   * Check if time expired
   */
  async isTimeExpired(sessionId: string): Promise<boolean> {
    const remaining = await this.getTimeRemaining(sessionId);
    return remaining === 0;
  }

  /**
   * Auto-submit on timeout
   */
  async handleTimeout(sessionId: string): Promise<void> {
    const session = await prisma.interviewSession.findUnique({
      where: { id: sessionId },
      include: { questions: true },
    });

    if (!session) return;

    const currentQuestion = session.questions[session.currentQuestionIndex];

    if (currentQuestion && !currentQuestion.answeredAt) {
      await prisma.interviewQuestion.update({
        where: { id: currentQuestion.id },
        data: {
          wasAutoSubmitted: true,
          timeSubmitted: new Date(),
          answeredAt: new Date(),
          userAnswer:
            currentQuestion.userAnswer ||
            '[Time Expired - No Answer Submitted]',
          score: 0,
        },
      });
    }

    await prisma.interviewSession.update({
      where: { id: sessionId },
      data: {
        status: 'COMPLETED',
        endTime: new Date(),
      },
    });
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\topic.service.ts
==============================

// src/services/topic.service.ts
import prisma from '../config/database';
import {
  QuestionCategory,
  Difficulty,
  MasteryLevel,
  Prisma,
} from '@prisma/client';

interface TopicData {
  name: string;
  slug: string;
  category: QuestionCategory;
  description?: string;
  parentTopicId?: string;
  difficulty?: Difficulty;
  estimatedHours?: number;
  prerequisites?: string[];
}

export class TopicService {
  /**
   * Create topic
   */
  async createTopic(data: TopicData) {
    return prisma.topic.create({
      data: {
        ...data,
        prerequisites: data.prerequisites || [],
      },
    });
  }

  /**
   * Get all topics
   */
  async getAllTopics(filters?: {
    category?: QuestionCategory;
    difficulty?: Difficulty;
    parentId?: string;
  }) {
    return prisma.topic.findMany({
      where: {
        isActive: true,
        ...(filters?.category && { category: filters.category }),
        ...(filters?.difficulty && { difficulty: filters.difficulty }),
        ...(filters?.parentId && { parentTopicId: filters.parentId }),
      },
      include: {
        subtopics: {
          where: { isActive: true },
          select: {
            id: true,
            name: true,
            slug: true,
            difficulty: true,
            totalQuestions: true,
          },
        },
        _count: {
          select: {
            questions: true,
            resources: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    });
  }

  /**
   * Get topic by slug
   */
  async getTopicBySlug(slug: string) {
    return prisma.topic.findUnique({
      where: { slug },
      include: {
        subtopics: {
          where: { isActive: true },
          include: {
            _count: {
              select: { questions: true },
            },
          },
        },
        questions: {
          include: {
            question: true,
          },
          take: 50,
        },
        resources: {
          orderBy: { isPrimary: 'desc' },
        },
        roadmaps: {
          where: { isActive: true },
        },
        parentTopic: {
          select: {
            id: true,
            name: true,
            slug: true,
          },
        },
      },
    });
  }

  /**
   * Get topic tree (hierarchy)
   */
  async getTopicTree(category?: QuestionCategory) {
    const rootTopics = await prisma.topic.findMany({
      where: {
        isActive: true,
        parentTopicId: null,
        ...(category && { category }),
      },
      include: {
        subtopics: {
          where: { isActive: true },
          include: {
            subtopics: {
              where: { isActive: true },
            },
          },
        },
      },
      orderBy: { name: 'asc' },
    });

    return rootTopics;
  }

  /**
   * Add question to topic
   */
  async addQuestionToTopic(
    topicId: string,
    questionId: string,
    importance: number = 5,
  ) {
    return prisma.topicQuestion.create({
      data: {
        topicId,
        questionId,
        importance,
      },
    });
  }

  /**
   * Get topic questions
   */
  async getTopicQuestions(
    topicId: string,
    filters?: {
      difficulty?: Difficulty;
      limit?: number;
      sortBy?: 'importance' | 'difficulty' | 'recent';
    },
  ) {
    const orderBy: any = {};

    if (filters?.sortBy === 'importance') {
      orderBy.importance = 'desc';
    } else if (filters?.sortBy === 'difficulty') {
      orderBy.question = { difficulty: 'asc' };
    }

    return prisma.topicQuestion.findMany({
      where: {
        topicId,
        ...(filters?.difficulty && {
          question: { difficulty: filters.difficulty },
        }),
      },
      include: {
        question: true,
      },
      orderBy: orderBy.importance ? orderBy : { importance: 'desc' },
      take: filters?.limit || 50,
    });
  }

  /**
   * Create topic roadmap
   */
  async createTopicRoadmap(
    topicId: string,
    roadmap: {
      name: string;
      description?: string;
      duration: number;
      difficulty: Difficulty;
      milestones: any[];
      estimatedHours: number;
      isPremium?: boolean;
    },
  ) {
    return prisma.topicRoadmap.create({
      data: {
        topicId,
        ...roadmap,
      },
    });
  }

  /**
   * Get user's topic progress
   */
  async getUserTopicProgress(userId: string, topicId: string) {
    let progress = await prisma.userTopicProgress.findUnique({
      where: {
        userId_topicId: {
          userId,
          topicId,
        },
      },
    });

    if (!progress) {
      progress = await prisma.userTopicProgress.create({
        data: {
          userId,
          topicId,
        },
      });
    }

    return progress;
  }

  /**
   * Update user's topic progress
   */
  async updateUserTopicProgress(
    userId: string,
    topicId: string,
    data: Partial<{
      questionsAttempted: number;
      questionsCompleted: number;
      averageScore: number;
      masteryLevel: MasteryLevel;
      totalTimeSpent: number;
      status: any;
    }>,
  ) {
    return prisma.userTopicProgress.upsert({
      where: {
        userId_topicId: {
          userId,
          topicId,
        },
      },
      update: {
        ...data,
        lastPracticed: new Date(),
        updatedAt: new Date(),
      },
      create: {
        userId,
        topicId,
        ...data,
      },
    });
  }

  /**
   * Calculate mastery level
   */
  calculateMasteryLevel(
    questionsAttempted: number,
    questionsCompleted: number,
    averageScore: number,
  ): MasteryLevel {
    if (questionsAttempted === 0) return 'BEGINNER';

    const completionRate = (questionsCompleted / questionsAttempted) * 100;

    if (completionRate < 30 || averageScore < 50) return 'LEARNING';
    if (completionRate < 60 || averageScore < 70) return 'PRACTICING';
    if (completionRate < 80 || averageScore < 85) return 'PROFICIENT';
    return 'EXPERT';
  }

  /**
   * Get user's mastery overview
   */
  async getUserMasteryOverview(userId: string) {
    const topicProgress = await prisma.userTopicProgress.findMany({
      where: { userId },
      include: {
        topic: {
          select: {
            id: true,
            name: true,
            slug: true,
            category: true,
            difficulty: true,
          },
        },
      },
    });

    // Group by mastery level
    const byMastery: Record<MasteryLevel, any[]> = {
      BEGINNER: [],
      LEARNING: [],
      PRACTICING: [],
      PROFICIENT: [],
      EXPERT: [],
    };

    topicProgress.forEach((p) => {
      byMastery[p.masteryLevel].push({
        topic: p.topic,
        averageScore: p.averageScore,
        questionsCompleted: p.questionsCompleted,
      });
    });

    return {
      total: topicProgress.length,
      byMastery,
      statistics: {
        beginner: byMastery.BEGINNER.length,
        learning: byMastery.LEARNING.length,
        practicing: byMastery.PRACTICING.length,
        proficient: byMastery.PROFICIENT.length,
        expert: byMastery.EXPERT.length,
      },
    };
  }

  /**
   * Get recommended topics for user
   */
  async getRecommendedTopics(userId: string) {
    // Get user's weak areas
    const weakAreas = await prisma.weakArea.findMany({
      where: { userId },
      orderBy: { failureCount: 'desc' },
      take: 5,
    });

    // Find topics matching weak areas
    const topics = await prisma.topic.findMany({
      where: {
        isActive: true,
        category: { in: weakAreas.map((w) => w.category as QuestionCategory) },
      },
      include: {
        _count: {
          select: { questions: true },
        },
      },
      take: 10,
    });

    return topics;
  }

  /**
   * Start topic-specific practice session
   */
  async startTopicPractice(
    userId: string,
    topicId: string,
    config: {
      questionCount: number;
      difficulty?: Difficulty;
      duration?: number;
    },
  ) {
    // Get topic questions
    const topicQuestions = await this.getTopicQuestions(topicId, {
      difficulty: config.difficulty,
      limit: config.questionCount,
      sortBy: 'importance',
    });

    // Create practice session
    const session = await prisma.practiceSession.create({
      data: {
        userId,
        type: 'TOPIC_SPECIFIC',
        topicId,
        questionCount: config.questionCount,
        difficulty: config.difficulty,
        duration: config.duration,
      },
    });

    // Add questions to session
    await Promise.all(
      topicQuestions.map((tq, index) =>
        prisma.practiceSessionQuestion.create({
          data: {
            sessionId: session.id,
            questionId: tq.questionId,
            questionIndex: index,
          },
        }),
      ),
    );

    return prisma.practiceSession.findUnique({
      where: { id: session.id },
      include: {
        questions: {
          include: {
            question: true,
          },
          orderBy: { questionIndex: 'asc' },
        },
      },
    });
  }

  /**
   * Get topic statistics
   */
  async getTopicStatistics(topicId: string) {
    const [totalQuestions, avgScore, completionRate, userCount] =
      await Promise.all([
        prisma.topicQuestion.count({ where: { topicId } }),

        prisma.userTopicProgress.aggregate({
          where: { topicId },
          _avg: { averageScore: true },
        }),

        prisma.userTopicProgress.aggregate({
          where: { topicId },
          _avg: {
            questionsCompleted: true,
            questionsAttempted: true,
          },
        }),

        prisma.userTopicProgress.count({ where: { topicId } }),
      ]);

    const completion = avgScore._avg.questionsAttempted
      ? (Number(avgScore._avg.questionsCompleted) /
          Number(avgScore._avg.questionsAttempted)) *
        100
      : 0;

    return {
      totalQuestions,
      averageScore: avgScore._avg.averageScore,
      completionRate: completion,
      totalUsers: userCount,
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\vector-db\base-vector-db.ts
==============================

/**
 * Abstract Vector Database Interface
 * This abstraction allows swapping between Chroma, Pinecone, Weaviate, etc.
 */

import { Document, RetrievalResult } from '../../types';

/**
 * Vector database configuration
 */
export interface VectorDBConfig {
  collectionName?: string;
  embeddingDimension?: number;
  similarityMetric?: 'cosine' | 'euclidean' | 'dot_product';
  // Pinecone-specific properties
  indexName?: string;
  namespace?: string;
  cloud?: string;
  region?: string;
}

/**
 * Base interface all vector database providers must implement
 */
export interface IVectorDatabase {
  /**
   * Provider name
   */
  readonly name: string;

  /**
   * Initialize the database connection
   */
  initialize(config: VectorDBConfig): Promise<void>;

  /**
   * Add documents to the vector store
   */
  addDocuments(documents: Document[]): Promise<void>;

  /**
   * Add a single document
   */
  addDocument(document: Document): Promise<void>;

  /**
   * Search for similar documents
   */
  search(
    query: string,
    topK?: number,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]>;

  /**
   * Search using a query embedding directly
   */
  searchByEmbedding(
    embedding: number[],
    topK?: number,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]>;

  /**
   * Delete documents by IDs
   */
  deleteDocuments(ids: string[]): Promise<void>;

  /**
   * Delete a single document
   */
  deleteDocument(id: string): Promise<void>;

  /**
   * Get document by ID
   */
  getDocument(id: string): Promise<Document | null>;

  /**
   * Update document
   */
  updateDocument(id: string, document: Partial<Document>): Promise<void>;

  /**
   * Clear all documents from collection
   */
  clear(): Promise<void>;

  /**
   * Check if database is ready
   */
  isReady(): Promise<boolean>;

  /**
   * Close connection
   */
  close(): Promise<void>;
}

/**
 * Abstract base class with common functionality
 */
export abstract class BaseVectorDatabase implements IVectorDatabase {
  abstract readonly name: string;
  protected config: VectorDBConfig;
  protected initialized: boolean = false;

  constructor(config: VectorDBConfig = {}) {
    this.config = {
      collectionName: config.collectionName || 'interview_coach',
      embeddingDimension: config.embeddingDimension || 1536, // OpenAI default
      similarityMetric: config.similarityMetric || 'cosine',
      // Include Pinecone-specific properties if provided
      indexName: config.indexName,
      namespace: config.namespace,
      cloud: config.cloud,
      region: config.region,
    };
  }

  abstract initialize(config: VectorDBConfig): Promise<void>;
  abstract addDocuments(documents: Document[]): Promise<void>;
  abstract search(
    query: string,
    topK?: number,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]>;
  abstract searchByEmbedding(
    embedding: number[],
    topK?: number,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]>;
  abstract deleteDocuments(ids: string[]): Promise<void>;
  abstract getDocument(id: string): Promise<Document | null>;
  abstract updateDocument(
    id: string,
    document: Partial<Document>,
  ): Promise<void>;
  abstract clear(): Promise<void>;
  abstract close(): Promise<void>;

  async addDocument(document: Document): Promise<void> {
    await this.addDocuments([document]);
  }

  async deleteDocument(id: string): Promise<void> {
    await this.deleteDocuments([id]);
  }

  async isReady(): Promise<boolean> {
    return this.initialized;
  }

  protected ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error(
        `${this.name} vector database not initialized. Call initialize() first.`,
      );
    }
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\vector-db\chroma-db.ts
==============================

/**
 * ChromaDB Vector Database Implementation
 */

import { ChromaClient, Collection } from 'chromadb';
import { BaseVectorDatabase, VectorDBConfig } from './base-vector-db';
import { Document, RetrievalResult } from '../../types';
import { EmbeddingService } from '../embedding/embedding-service';

export class ChromaVectorDatabase extends BaseVectorDatabase {
  readonly name = 'ChromaDB';
  private client: ChromaClient | null = null;
  private collection: Collection | null = null;
  private embeddingService: EmbeddingService;

  constructor(
    config: VectorDBConfig = {},
    private host: string = 'localhost',
    private port: number = 8000
  ) {
    super(config);
    this.embeddingService = new EmbeddingService();
  }

  async initialize(config: VectorDBConfig): Promise<void> {
    try {
      this.config = { ...this.config, ...config };
      
      // Initialize Chroma client
      this.client = new ChromaClient({
        path: `http://${this.host}:${this.port}`,
      });

      // Create or get collection
      this.collection = await this.client.getOrCreateCollection({
        name: this.config.collectionName!,
        metadata: {
          'hnsw:space': this.config.similarityMetric || 'cosine',
        },
      });

      this.initialized = true;
      console.log(`ChromaDB initialized with collection: ${this.config.collectionName}`);
    } catch (error) {
      console.error('Failed to initialize ChromaDB:', error);
      throw new Error(
        `ChromaDB initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async addDocuments(documents: Document[]): Promise<void> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    if (documents.length === 0) {
      return;
    }

    try {
      // Generate embeddings for documents that don't have them
      const documentsWithEmbeddings = await Promise.all(
        documents.map(async (doc) => {
          if (!doc.embedding) {
            const embedding = await this.embeddingService.generateEmbedding(doc.content);
            return { ...doc, embedding };
          }
          return doc;
        })
      );

      // Prepare data for Chroma
      const ids = documentsWithEmbeddings.map((doc) => doc.id);
      const embeddings = documentsWithEmbeddings.map((doc) => doc.embedding!);
      const metadatas = documentsWithEmbeddings.map((doc) => ({
        ...doc.metadata,
        content: doc.content, // Store content in metadata for retrieval
      }));
      const documents_text = documentsWithEmbeddings.map((doc) => doc.content);

      await this.collection.add({
        ids,
        embeddings,
        metadatas,
        documents: documents_text,
      });

      console.log(`Added ${documents.length} documents to ChromaDB`);
    } catch (error) {
      console.error('Failed to add documents to ChromaDB:', error);
      throw new Error(
        `Failed to add documents: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async search(
    query: string,
    topK: number = 5,
    filter?: Record<string, unknown>
  ): Promise<RetrievalResult[]> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    try {
      // Generate embedding for query
      const queryEmbedding = await this.embeddingService.generateEmbedding(query);
      
      return await this.searchByEmbedding(queryEmbedding, topK, filter);
    } catch (error) {
      console.error('Failed to search in ChromaDB:', error);
      throw new Error(
        `Search failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async searchByEmbedding(
    embedding: number[],
    topK: number = 5,
    filter?: Record<string, unknown>
  ): Promise<RetrievalResult[]> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    try {
      const results = await this.collection.query({
        queryEmbeddings: [embedding],
        nResults: topK,
        where: filter,
      });

      // Transform Chroma results to our format
      const retrievalResults: RetrievalResult[] = [];

      if (results.ids && results.ids[0]) {
        for (let i = 0; i < results.ids[0].length; i++) {
          const id = results.ids[0][i];
          const distance = results.distances?.[0]?.[i] ?? 0;
          const metadata = results.metadatas?.[0]?.[i];
          const documentText = results.documents?.[0]?.[i];

          if (metadata && documentText) {
            // Extract content from metadata
            const { content, ...cleanMetadata } = metadata as any;

            retrievalResults.push({
              document: {
                id,
                content: content || documentText,
                metadata: {
                  ...cleanMetadata,
                  dateAdded: cleanMetadata.dateAdded 
                    ? new Date(cleanMetadata.dateAdded) 
                    : new Date(),
                },
                embedding,
              },
              score: distance,
              relevance: 1 - distance, // Convert distance to relevance (0-1)
            });
          }
        }
      }

      return retrievalResults;
    } catch (error) {
      console.error('Failed to search by embedding in ChromaDB:', error);
      throw new Error(
        `Search by embedding failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async deleteDocuments(ids: string[]): Promise<void> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    try {
      await this.collection.delete({
        ids,
      });
      console.log(`Deleted ${ids.length} documents from ChromaDB`);
    } catch (error) {
      console.error('Failed to delete documents from ChromaDB:', error);
      throw new Error(
        `Failed to delete documents: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async getDocument(id: string): Promise<Document | null> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    try {
      const results = await this.collection.get({
        ids: [id],
      });

      if (results.ids.length === 0) {
        return null;
      }

      const metadata = results.metadatas?.[0];
      const documentText = results.documents?.[0];
      const embedding = results.embeddings?.[0];

      if (!metadata || !documentText) {
        return null;
      }

      const { content, ...cleanMetadata } = metadata as any;

      return {
        id,
        content: content || documentText,
        metadata: {
          ...cleanMetadata,
          dateAdded: cleanMetadata.dateAdded 
            ? new Date(cleanMetadata.dateAdded) 
            : new Date(),
        },
        embedding: embedding || undefined,
      };
    } catch (error) {
      console.error('Failed to get document from ChromaDB:', error);
      return null;
    }
  }

  async updateDocument(id: string, document: Partial<Document>): Promise<void> {
    this.ensureInitialized();
    if (!this.collection) {
      throw new Error('Collection not initialized');
    }

    try {
      // ChromaDB doesn't have direct update - need to delete and re-add
      const existing = await this.getDocument(id);
      if (!existing) {
        throw new Error(`Document with id ${id} not found`);
      }

      const updated: Document = {
        ...existing,
        ...document,
        id, // Ensure ID doesn't change
      };

      await this.deleteDocument(id);
      await this.addDocument(updated);

      console.log(`Updated document ${id} in ChromaDB`);
    } catch (error) {
      console.error('Failed to update document in ChromaDB:', error);
      throw new Error(
        `Failed to update document: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async clear(): Promise<void> {
    this.ensureInitialized();
    if (!this.client || !this.collection) {
      throw new Error('Client or collection not initialized');
    }

    try {
      // Delete collection and recreate
      await this.client.deleteCollection({
        name: this.config.collectionName!,
      });

      this.collection = await this.client.createCollection({
        name: this.config.collectionName!,
        metadata: {
          'hnsw:space': this.config.similarityMetric || 'cosine',
        },
      });

      console.log('Cleared ChromaDB collection');
    } catch (error) {
      console.error('Failed to clear ChromaDB:', error);
      throw new Error(
        `Failed to clear collection: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  async close(): Promise<void> {
    // ChromaDB client doesn't need explicit closing
    this.initialized = false;
    this.client = null;
    this.collection = null;
    console.log('ChromaDB connection closed');
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\services\vector-db\pinecone-db.ts
==============================

/**
 * Pinecone Vector Database Implementation
 */

import { Pinecone, Index, RecordMetadata } from '@pinecone-database/pinecone';
import { BaseVectorDatabase, VectorDBConfig } from './base-vector-db';
import { Document, RetrievalResult } from '../../types';
import { EmbeddingService } from '../embedding/embedding-service';

export class PineconeVectorDatabase extends BaseVectorDatabase {
  readonly name = 'Pinecone';
  private client: Pinecone | null = null;
  private index: Index | null = null;
  private embeddingService: EmbeddingService;
  private namespace: string;
  private indexName: string;

  constructor(
    config: VectorDBConfig = {},
    private apiKey?: string,
  ) {
    super(config);
    this.embeddingService = new EmbeddingService();
    this.namespace = config.namespace || 'default';
    this.indexName =
      config.indexName || config.collectionName || 'interview-coach';
  }

  async initialize(config: VectorDBConfig): Promise<void> {
    try {
      this.config = { ...this.config, ...config };

      if (config.indexName) {
        this.indexName = config.indexName;
      }
      if (config.namespace) {
        this.namespace = config.namespace;
      }

      // Initialize Pinecone client
      const apiKey = this.apiKey || process.env.PINECONE_API_KEY;
      if (!apiKey) {
        throw new Error('Pinecone API key is required');
      }

      this.client = new Pinecone({
        apiKey: apiKey,
      });

      // Get or create index
      try {
        // Try to describe the index (check if it exists)
        await this.client.describeIndex(this.indexName);
        console.log(`Using existing Pinecone index: ${this.indexName}`);
      } catch (error) {
        // Index doesn't exist, create it
        console.log(`Creating new Pinecone index: ${this.indexName}`);
        await this.client.createIndex({
          name: this.indexName,
          dimension: this.config.embeddingDimension || 1536,
          metric: this.config.similarityMetric || 'cosine',
          spec: {
            serverless: {
              cloud: (config.cloud as 'aws' | 'gcp' | 'azure') || 'aws',
              region: config.region || 'us-east-1',
            },
          },
        });

        // Wait for index to be ready
        await this.waitForIndexReady();
      }

      // Get index reference
      this.index = this.client.index(this.indexName);

      this.initialized = true;
      console.log(
        `Pinecone initialized with index: ${this.indexName}, namespace: ${this.namespace}`,
      );
    } catch (error) {
      console.error('Failed to initialize Pinecone:', error);
      throw new Error(
        `Pinecone initialization failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  private async waitForIndexReady(maxWaitTime: number = 60000): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWaitTime) {
      try {
        const indexDescription = await this.client!.describeIndex(
          this.indexName,
        );
        if (indexDescription.status?.ready) {
          return;
        }
      } catch (error) {
        // Index might not be ready yet
      }

      // Wait 2 seconds before checking again
      await new Promise((resolve) => setTimeout(resolve, 2000));
    }

    throw new Error('Index creation timeout');
  }

  async addDocuments(documents: Document[]): Promise<void> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    if (documents.length === 0) {
      return;
    }

    try {
      // Generate embeddings for documents that don't have them
      const documentsWithEmbeddings = await Promise.all(
        documents.map(async (doc) => {
          if (!doc.embedding) {
            const embedding = await this.embeddingService.generateEmbedding(
              doc.content,
            );
            return { ...doc, embedding };
          }
          return doc;
        }),
      );

      // Prepare records for Pinecone
      const records = documentsWithEmbeddings.map((doc) => ({
        id: doc.id,
        values: doc.embedding!,
        metadata: {
          content: doc.content,
          source: doc.metadata.source,
          category: doc.metadata.category,
          tags: JSON.stringify(doc.metadata.tags),
          difficulty: doc.metadata.difficulty || '',
          company: doc.metadata.company || '',
          dateAdded: doc.metadata.dateAdded.toISOString(),
        } as RecordMetadata,
      }));

      // Upsert in batches of 100 (Pinecone recommendation)
      const batchSize = 100;
      for (let i = 0; i < records.length; i += batchSize) {
        const batch = records.slice(i, i + batchSize);
        // Fix: Pinecone v7 expects an object with 'records' property
        await this.index.namespace(this.namespace).upsert({ records: batch });
      }

      console.log(`Added ${documents.length} documents to Pinecone`);
    } catch (error) {
      console.error('Failed to add documents to Pinecone:', error);
      throw new Error(
        `Failed to add documents: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async search(
    query: string,
    topK: number = 5,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Generate embedding for query
      const queryEmbedding =
        await this.embeddingService.generateEmbedding(query);

      return await this.searchByEmbedding(queryEmbedding, topK, filter);
    } catch (error) {
      console.error('Failed to search in Pinecone:', error);
      throw new Error(
        `Search failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async searchByEmbedding(
    embedding: number[],
    topK: number = 5,
    filter?: Record<string, unknown>,
  ): Promise<RetrievalResult[]> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Prepare filter in Pinecone format
      const pineconeFilter = filter
        ? this.convertToPineconeFilter(filter)
        : undefined;

      // Query Pinecone
      const queryResponse = await this.index.namespace(this.namespace).query({
        vector: embedding,
        topK: topK,
        includeMetadata: true,
        filter: pineconeFilter,
      });

      // Transform Pinecone results to our format
      const retrievalResults: RetrievalResult[] = queryResponse.matches.map(
        (match) => {
          const metadata = match.metadata as any;

          return {
            document: {
              id: match.id,
              content: metadata.content || '',
              metadata: {
                source: metadata.source || '',
                category: metadata.category || '',
                tags: metadata.tags ? JSON.parse(metadata.tags as string) : [],
                difficulty: metadata.difficulty || undefined,
                company: metadata.company || undefined,
                dateAdded: metadata.dateAdded
                  ? new Date(metadata.dateAdded as string)
                  : new Date(),
              },
              embedding: match.values,
            },
            score: match.score || 0,
            relevance: match.score || 0, // Pinecone score is already a similarity score (0-1)
          };
        },
      );

      return retrievalResults;
    } catch (error) {
      console.error('Failed to search by embedding in Pinecone:', error);
      throw new Error(
        `Search by embedding failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  private convertToPineconeFilter(
    filter: Record<string, unknown>,
  ): Record<string, any> {
    // Convert our filter format to Pinecone's filter format
    // Pinecone uses MongoDB-like filter syntax
    const pineconeFilter: Record<string, any> = {};

    for (const [key, value] of Object.entries(filter)) {
      if (key === 'category' && typeof value === 'string') {
        pineconeFilter.category = { $eq: value };
      } else if (key === 'difficulty' && typeof value === 'string') {
        pineconeFilter.difficulty = { $eq: value };
      } else if (key === 'tags' && Array.isArray(value)) {
        // For tags, we need to check if any tag matches
        // Since we store tags as JSON string, we'll use $in operator
        pineconeFilter.tags = { $in: value };
      } else {
        pineconeFilter[key] = value;
      }
    }

    return pineconeFilter;
  }

  async deleteDocuments(ids: string[]): Promise<void> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Fix: Pinecone v7 expects deleteMany with array of ids
      await this.index.namespace(this.namespace).deleteMany(ids);
      console.log(`Deleted ${ids.length} documents from Pinecone`);
    } catch (error) {
      console.error('Failed to delete documents from Pinecone:', error);
      throw new Error(
        `Failed to delete documents: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async getDocument(id: string): Promise<Document | null> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Fix: Pinecone v7 expects an object with 'ids' property
      const fetchResponse = await this.index
        .namespace(this.namespace)
        .fetch({ ids: [id] });
      const record = fetchResponse.records[id];

      if (!record || !record.metadata) {
        return null;
      }

      const metadata = record.metadata as any;

      return {
        id: record.id,
        content: metadata.content || '',
        metadata: {
          source: metadata.source || '',
          category: metadata.category || '',
          tags: metadata.tags ? JSON.parse(metadata.tags as string) : [],
          difficulty: metadata.difficulty || undefined,
          company: metadata.company || undefined,
          dateAdded: metadata.dateAdded
            ? new Date(metadata.dateAdded as string)
            : new Date(),
        },
        embedding: record.values,
      };
    } catch (error) {
      console.error('Failed to get document from Pinecone:', error);
      return null;
    }
  }

  async updateDocument(id: string, document: Partial<Document>): Promise<void> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Pinecone doesn't have direct update - need to fetch, merge, and upsert
      const existing = await this.getDocument(id);
      if (!existing) {
        throw new Error(`Document with id ${id} not found`);
      }

      const updated: Document = {
        ...existing,
        ...document,
        id, // Ensure ID doesn't change
        metadata: {
          ...existing.metadata,
          ...(document.metadata || {}),
        },
      };

      // Generate new embedding if content changed
      if (document.content && document.content !== existing.content) {
        updated.embedding = await this.embeddingService.generateEmbedding(
          updated.content,
        );
      }

      await this.addDocument(updated);

      console.log(`Updated document ${id} in Pinecone`);
    } catch (error) {
      console.error('Failed to update document in Pinecone:', error);
      throw new Error(
        `Failed to update document: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async clear(): Promise<void> {
    this.ensureInitialized();
    if (!this.index) {
      throw new Error('Index not initialized');
    }

    try {
      // Delete all vectors in the namespace
      await this.index.namespace(this.namespace).deleteAll();
      console.log('Cleared Pinecone namespace');
    } catch (error) {
      console.error('Failed to clear Pinecone:', error);
      throw new Error(
        `Failed to clear namespace: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  async close(): Promise<void> {
    // Pinecone client doesn't need explicit closing
    this.initialized = false;
    this.client = null;
    this.index = null;
    console.log('Pinecone connection closed');
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\types\auth.types.ts
==============================

// src/types/auth.types.ts
import { User as PrismaUser, UserRole } from '@prisma/client';

export interface RegisterDTO {
  email: string;
  password: string;
  name: string;
}

export interface LoginDTO {
  email: string;
  password: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

export interface JWTPayload {
  userId: string;
  email: string;
  role: UserRole;
  iat?: number;
  exp?: number;
}

export interface PasswordResetRequest {
  email: string;
}

export interface PasswordResetConfirm {
  token: string;
  newPassword: string;
}

export interface OAuthProfile {
  provider: 'google' | 'github';
  id: string;
  email: string;
  name: string;
  picture?: string;
}

export type SafeUser = Omit<
  PrismaUser,
  'passwordHash' | 'verificationToken' | 'resetToken'
>;


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\types\index.ts
==============================

/**
 * Core type definitions for AI Interview Coach
 * These types form the contract between all system components
 */

// ============================================================================
// Agent Types
// ============================================================================

/**
 * Supported agent types in the system
 */
export enum AgentType {
  RESUME_REVIEW = 'resume_review',
  DSA_INTERVIEW = 'dsa_interview',
  SYSTEM_DESIGN = 'system_design',
  HR_BEHAVIORAL = 'hr_behavioral',
  LEARNING_SUPPORT = 'learning_support',
}

/**
 * Base input structure for all agents
 */
export interface BaseAgentInput {
  query: string;
  userId: string;
  sessionId: string;
  context?: Record<string, unknown>;
}

/**
 * Base output structure for all agents
 */
export interface BaseAgentOutput {
  response: string;
  confidence: number; // 0-1 scale
  metadata?: Record<string, unknown>;
  suggestedFollowUps?: string[];
  requiresRAG?: boolean;
}

/**
 * Agent interface - all agents must implement this
 */
export interface IAgent {
  type: AgentType;
  name: string;
  description: string;
  
  /**
   * Process the input and generate a response
   */
  process(input: BaseAgentInput): Promise<BaseAgentOutput>;
  
  /**
   * Validate if this agent can handle the given input
   */
  canHandle(input: BaseAgentInput): Promise<boolean>;
}

// ============================================================================
// Router Types
// ============================================================================

/**
 * Routing decision made by the router
 */
export interface RoutingDecision {
  agentType: AgentType;
  confidence: number;
  reasoning: string;
  fallbackAgents?: AgentType[];
}

/**
 * Router strategy types
 */
export enum RouterStrategy {
  RULE_BASED = 'rule_based',
  LLM_BASED = 'llm_based',
  HYBRID = 'hybrid',
}

// ============================================================================
// Memory Types
// ============================================================================

/**
 * Short-term memory for a session
 */
export interface ShortTermMemory {
  sessionId: string;
  userId: string;
  conversationHistory: ConversationTurn[];
  currentTopic?: string;
  startTime: Date;
  lastActivity: Date;
}

/**
 * Long-term memory for a user
 */
export interface LongTermMemory {
  userId: string;
  weakAreas: WeakArea[];
  strengths: string[];
  interviewHistory: InterviewSession[];
  learningProgress: LearningProgress;
  preferences?: UserPreferences;
}

/**
 * A single conversation turn
 */
export interface ConversationTurn {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  agentType?: AgentType;
  metadata?: Record<string, unknown>;
}

/**
 * Weak area tracking
 */
export interface WeakArea {
  topic: string;
  category: string; // DSA, System Design, etc.
  failureCount: number;
  lastEncountered: Date;
  improvementSuggestions: string[];
}

/**
 * Learning progress tracking
 */
export interface LearningProgress {
  totalInterviews: number;
  topicsCompleted: string[];
  currentLevel: SkillLevel;
  goalLevel: SkillLevel;
  milestones: Milestone[];
}

/**
 * Skill level enum
 */
export enum SkillLevel {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  EXPERT = 'expert',
}

/**
 * Milestone tracking
 */
export interface Milestone {
  id: string;
  title: string;
  description: string;
  achieved: boolean;
  achievedDate?: Date;
}

/**
 * User preferences
 */
export interface UserPreferences {
  difficulty: 'easy' | 'medium' | 'hard';
  focusAreas: string[];
  interviewType: 'frontend' | 'backend' | 'fullstack';
  sessionDuration?: number; // in minutes
}

// ============================================================================
// RAG Types
// ============================================================================

/**
 * Document to be indexed
 */
export interface Document {
  id: string;
  content: string;
  metadata: DocumentMetadata;
  embedding?: number[];
}

/**
 * Document metadata
 */
export interface DocumentMetadata {
  source: string;
  category: string;
  tags: string[];
  difficulty?: string;
  company?: string;
  dateAdded: Date;
}

/**
 * Query result from vector search
 */
export interface RetrievalResult {
  document: Document;
  score: number;
  relevance: number;
}

/**
 * RAG context for agent processing
 */
export interface RAGContext {
  query: string;
  retrievedDocs: RetrievalResult[];
  totalResults: number;
  searchStrategy: 'semantic' | 'hybrid' | 'keyword';
}

// ============================================================================
// LLM Provider Types
// ============================================================================

/**
 * LLM provider types
 */
export enum LLMProvider {
  OPENAI = 'openai',
  ANTHROPIC = 'anthropic',
  GROQ = 'groq',
}

/**
 * Message structure for LLM
 */
export interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

/**
 * LLM request parameters
 */
export interface LLMRequest {
  messages: LLMMessage[];
  temperature?: number;
  maxTokens?: number;
  model?: string;
  stream?: boolean;
}

/**
 * LLM response
 */
export interface LLMResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
}

// ============================================================================
// Interview Session Types
// ============================================================================

/**
 * Interview session state
 */
export interface InterviewSession {
  id: string;
  userId: string;
  type: 'dsa' | 'system_design' | 'behavioral' | 'mixed';
  status: 'active' | 'paused' | 'completed';
  startTime: Date;
  endTime?: Date;
  questions: InterviewQuestion[];
  currentQuestionIndex: number;
  score?: number;
  feedback?: string;
}

/**
 * Interview question
 */
export interface InterviewQuestion {
  id: string;
  question: string;
  difficulty: 'easy' | 'medium' | 'hard';
  category: string;
  expectedAnswer?: string;
  userAnswer?: string;
  score?: number;
  feedback?: string;
  timeSpent?: number; // in seconds
  hints?: string[];
  hintsUsed?: number;
}

// ============================================================================
// API Types
// ============================================================================

/**
 * Standard API response wrapper
 */
export interface APIResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
  metadata?: {
    timestamp: Date;
    requestId?: string;
  };
}

/**
 * Query request
 */
export interface QueryRequest {
  query: string;
  userId: string;
  sessionId?: string;
  useRAG?: boolean;
  context?: Record<string, unknown>;
}

/**
 * Query response
 */
export interface QueryResponse {
  response: string;
  agentType: AgentType;
  confidence: number;
  suggestedFollowUps?: string[];
  retrievedContext?: RetrievalResult[];
}

/**
 * Start interview request
 */
export interface StartInterviewRequest {
  userId: string;
  type: 'dsa' | 'system_design' | 'behavioral' | 'mixed';
  difficulty?: 'easy' | 'medium' | 'hard';
  duration?: number;
  focusAreas?: string[];
}

/**
 * Answer interview question request
 */
export interface AnswerRequest {
  sessionId: string;
  userId: string;
  answer: string;
  timeSpent?: number;
}

/**
 * Resume review request
 */
export interface ResumeReviewRequest {
  userId: string;
  resumeText: string;
  targetRole?: string;
  targetCompanies?: string[];
}

// ============================================================================
// Validation & Verification Types (for CRAG/Self-RAG)
// ============================================================================

/**
 * Verification result for self-RAG
 */
export interface VerificationResult {
  verified: boolean;
  confidence: number;
  supportingDocs: Document[];
  contradictingDocs: Document[];
  needsRefinement: boolean;
  refinementSuggestion?: string;
}

/**
 * CRAG decision
 */
export enum CRAGDecision {
  CORRECT = 'correct',      // Retrieved docs support the answer
  INCORRECT = 'incorrect',  // Retrieved docs contradict the answer
  AMBIGUOUS = 'ambiguous',  // Unclear, need more context
}

/**
 * CRAG evaluation result
 */
export interface CRAGEvaluation {
  decision: CRAGDecision;
  confidence: number;
  reasoning: string;
  shouldRequery: boolean;
  alternativeQuery?: string;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\email.util.ts
==============================

// src/utils/email.util.ts
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransporter({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

export class EmailUtil {
  static async sendVerificationEmail(
    email: string,
    token: string,
    name: string,
  ): Promise<void> {
    const verificationUrl = `${process.env.FRONTEND_URL}/verify-email?token=${token}`;

    await transporter.sendMail({
      from: process.env.SMTP_FROM || 'noreply@interviewcoach.com',
      to: email,
      subject: 'Verify Your Email - AI Interview Coach',
      html: `
        <h1>Welcome to AI Interview Coach, ${name}!</h1>
        <p>Please verify your email address by clicking the link below:</p>
        <a href="${verificationUrl}">Verify Email</a>
        <p>This link will expire in 24 hours.</p>
        <p>If you didn't create an account, please ignore this email.</p>
      `,
    });
  }

  static async sendPasswordResetEmail(
    email: string,
    token: string,
    name: string,
  ): Promise<void> {
    const resetUrl = `${process.env.FRONTEND_URL}/reset-password?token=${token}`;

    await transporter.sendMail({
      from: process.env.SMTP_FROM || 'noreply@interviewcoach.com',
      to: email,
      subject: 'Password Reset Request - AI Interview Coach',
      html: `
        <h1>Password Reset Request</h1>
        <p>Hi ${name},</p>
        <p>You requested to reset your password. Click the link below to set a new password:</p>
        <a href="${resetUrl}">Reset Password</a>
        <p>This link will expire in 1 hour.</p>
        <p>If you didn't request this, please ignore this email.</p>
      `,
    });
  }

  static async sendWelcomeEmail(email: string, name: string): Promise<void> {
    await transporter.sendMail({
      from: process.env.SMTP_FROM || 'noreply@interviewcoach.com',
      to: email,
      subject: 'Welcome to AI Interview Coach!',
      html: `
        <h1>Welcome aboard, ${name}!</h1>
        <p>Your email has been verified successfully.</p>
        <p>You can now start practicing with our AI-powered interview coach.</p>
        <a href="${process.env.FRONTEND_URL}/dashboard">Go to Dashboard</a>
      `,
    });
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\helpers.ts
==============================

/**
 * Utility Helper Functions
 * Common helper functions used across controllers
 */

import { ParsedQs } from 'qs';

/**
 * Safely extract a string parameter from Express request params
 * Handles the case where params can be string | string[]
 */
export function getStringParam(
  param: string | string[] | undefined,
): string | undefined {
  if (!param) return undefined;
  return Array.isArray(param) ? param[0] : param;
}

/**
 * Safely extract a string from query parameters
 * Handles Express query type: string | ParsedQs | (string | ParsedQs)[] | undefined
 */
export function getStringQuery(
  param: string | ParsedQs | (string | ParsedQs)[] | undefined,
): string | undefined {
  if (!param) return undefined;

  if (typeof param === 'string') {
    return param;
  }

  if (Array.isArray(param) && param.length > 0) {
    const first = param[0];
    return typeof first === 'string' ? first : undefined;
  }

  return undefined;
}

/**
 * Safely extract a required string parameter from Express request params
 * Throws an error if the parameter is missing
 */
export function getRequiredStringParam(
  param: string | string[] | undefined,
  paramName: string,
): string {
  const value = getStringParam(param);
  if (!value) {
    throw new Error(`Missing required parameter: ${paramName}`);
  }
  return value;
}

/**
 * Parse integer from request params
 */
export function parseIntParam(
  param: string | string[] | undefined,
  defaultValue?: number,
): number | undefined {
  const strValue = getStringParam(param);
  if (!strValue) return defaultValue;

  const parsed = parseInt(strValue, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Parse integer from request query parameters
 * Handles Express query type: string | ParsedQs | (string | ParsedQs)[] | undefined
 */
export function parseIntQuery(
  param: string | ParsedQs | (string | ParsedQs)[] | undefined,
  defaultValue?: number,
): number | undefined {
  const strValue = getStringQuery(param);
  if (!strValue) return defaultValue;

  const parsed = parseInt(strValue, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\password.util.ts
==============================

// src/utils/password.util.ts
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;

export class PasswordUtil {
  static async hash(password: string): Promise<string> {
    return bcrypt.hash(password, SALT_ROUNDS);
  }

  static async compare(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  static validate(password: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (password.length < 8) {
      errors.push('Password must be at least 8 characters long');
    }
    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }
    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }
    if (!/[0-9]/.test(password)) {
      errors.push('Password must contain at least one number');
    }
    if (!/[!@#$%^&*]/.test(password)) {
      errors.push(
        'Password must contain at least one special character (!@#$%^&*)',
      );
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\seed-achievements.ts
==============================

// src/utils/seed-achievements.ts
import prisma from '../config/database';
import { MilestoneType } from '@prisma/client';

const achievements = [
  {
    code: 'first_interview',
    title: 'First Steps',
    description: 'Complete your first interview',
    icon: 'üéØ',
    type: 'INTERVIEW_COMPLETION' as MilestoneType,
    requirement: { totalInterviews: 1 },
    points: 10,
  },
  {
    code: 'interview_master',
    title: 'Interview Master',
    description: 'Complete 100 interviews',
    icon: 'üèÜ',
    type: 'INTERVIEW_COMPLETION' as MilestoneType,
    requirement: { totalInterviews: 100 },
    points: 500,
  },
  {
    code: 'perfect_score',
    title: 'Perfectionist',
    description: 'Get your first perfect score',
    icon: '‚≠ê',
    type: 'PERFECT_SCORE' as MilestoneType,
    requirement: { perfectScores: 1 },
    points: 50,
  },
  {
    code: 'perfect_10',
    title: 'Consistency King',
    description: 'Get 10 perfect scores',
    icon: 'üëë',
    type: 'PERFECT_SCORE' as MilestoneType,
    requirement: { perfectScores: 10 },
    points: 200,
  },
  {
    code: 'week_streak',
    title: 'Dedicated Learner',
    description: 'Maintain a 7-day streak',
    icon: 'üî•',
    type: 'STREAK' as MilestoneType,
    requirement: { currentStreak: 7 },
    points: 100,
  },
  {
    code: 'month_streak',
    title: 'Unstoppable',
    description: 'Maintain a 30-day streak',
    icon: 'üí™',
    type: 'STREAK' as MilestoneType,
    requirement: { currentStreak: 30 },
    points: 500,
  },
  {
    code: 'century_club',
    title: 'Century Club',
    description: 'Solve 100 problems',
    icon: 'üíØ',
    type: 'CUSTOM' as MilestoneType,
    requirement: { problemsSolved: 100 },
    points: 300,
  },
  {
    code: 'problem_crusher',
    title: 'Problem Crusher',
    description: 'Solve 500 problems',
    icon: '‚ö°',
    type: 'CUSTOM' as MilestoneType,
    requirement: { problemsSolved: 500 },
    points: 1000,
  },
  {
    code: 'early_bird',
    title: 'Early Bird',
    description: 'Study before 8 AM',
    icon: 'üåÖ',
    type: 'CUSTOM' as MilestoneType,
    requirement: { earlyMorningStudy: 1 },
    points: 25,
    isSecret: true,
  },
  {
    code: 'night_owl',
    title: 'Night Owl',
    description: 'Study after 10 PM',
    icon: 'ü¶â',
    type: 'CUSTOM' as MilestoneType,
    requirement: { lateNightStudy: 1 },
    points: 25,
    isSecret: true,
  },
];

export async function seedAchievements() {
  console.log('üèÜ Seeding achievements...\n');

  for (const achievement of achievements) {
    await prisma.achievement.upsert({
      where: { code: achievement.code },
      update: achievement,
      create: achievement,
    });
    console.log(`‚úì Added: ${achievement.title}`);
  }

  console.log(`\n‚úÖ Successfully seeded ${achievements.length} achievements!`);
}

if (require.main === module) {
  seedAchievements()
    .then(() => {
      console.log('\n‚úÖ Done!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Seeding failed:', error);
      process.exit(1);
    });
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\seed-companies-topics.ts
==============================

// src/utils/seed-companies-topics.ts
import prisma from '../config/database';
import {
  CompanyDifficulty,
  Difficulty,
  QuestionCategory,
} from '@prisma/client';

const companies = [
  {
    name: 'Google',
    slug: 'google',
    description: 'Known for algorithmic and system design challenges',
    industry: 'Technology',
    size: 'Large',
    locations: ['Mountain View, CA', 'New York, NY', 'Seattle, WA'],
    interviewDifficulty: 'VERY_HARD' as CompanyDifficulty,
    interviewProcess: {
      rounds: [
        {
          name: 'Phone Screen',
          duration: 45,
          focus: ['DSA', 'Problem Solving'],
        },
        { name: 'Technical Interview 1', duration: 45, focus: ['Algorithms'] },
        {
          name: 'Technical Interview 2',
          duration: 45,
          focus: ['System Design'],
        },
        { name: 'Technical Interview 3', duration: 45, focus: ['Coding'] },
        { name: 'Behavioral', duration: 30, focus: ['Googleyness'] },
      ],
      totalDuration: 210,
    },
    isPremium: false,
  },
  {
    name: 'Amazon',
    slug: 'amazon',
    description: 'Focus on leadership principles and scalability',
    industry: 'E-commerce/Technology',
    size: 'Large',
    locations: ['Seattle, WA', 'New York, NY', 'Austin, TX'],
    interviewDifficulty: 'HARD' as CompanyDifficulty,
    interviewProcess: {
      rounds: [
        { name: 'Phone Screen', duration: 60, focus: ['DSA'] },
        {
          name: 'Onsite Loop',
          duration: 240,
          focus: ['Coding', 'System Design', 'Behavioral'],
        },
      ],
      totalDuration: 300,
    },
    isPremium: false,
  },
  {
    name: 'Microsoft',
    slug: 'microsoft',
    description: 'Balanced approach with focus on problem-solving',
    industry: 'Technology',
    size: 'Large',
    locations: ['Redmond, WA', 'New York, NY', 'San Francisco, CA'],
    interviewDifficulty: 'HARD' as CompanyDifficulty,
    interviewProcess: {
      rounds: [
        { name: 'Phone Screen', duration: 45, focus: ['Coding'] },
        {
          name: 'Onsite Rounds',
          duration: 180,
          focus: ['DSA', 'System Design', 'Behavioral'],
        },
      ],
      totalDuration: 225,
    },
    isPremium: false,
  },
  {
    name: 'Meta (Facebook)',
    slug: 'meta',
    description: 'Fast-paced coding interviews with system design',
    industry: 'Social Media/Technology',
    size: 'Large',
    locations: ['Menlo Park, CA', 'New York, NY', 'Seattle, WA'],
    interviewDifficulty: 'VERY_HARD' as CompanyDifficulty,
    interviewProcess: {
      rounds: [
        { name: 'Phone Screen', duration: 45, focus: ['Coding'] },
        {
          name: 'Technical Interviews',
          duration: 180,
          focus: ['Algorithms', 'System Design'],
        },
        { name: 'Behavioral', duration: 30, focus: ['Culture Fit'] },
      ],
      totalDuration: 255,
    },
    isPremium: false,
  },
  {
    name: 'Apple',
    slug: 'apple',
    description: 'Product-focused with deep technical questions',
    industry: 'Technology/Consumer Electronics',
    size: 'Large',
    locations: ['Cupertino, CA', 'Austin, TX'],
    interviewDifficulty: 'HARD' as CompanyDifficulty,
    isPremium: false,
  },
  {
    name: 'Netflix',
    slug: 'netflix',
    description: 'Senior-level focus with system design emphasis',
    industry: 'Streaming/Entertainment',
    size: 'Medium',
    locations: ['Los Gatos, CA'],
    interviewDifficulty: 'VERY_HARD' as CompanyDifficulty,
    isPremium: true,
  },
  {
    name: 'Stripe',
    slug: 'stripe',
    description: 'Payment systems and API design focus',
    industry: 'Fintech',
    size: 'Medium',
    locations: ['San Francisco, CA', 'Seattle, WA'],
    interviewDifficulty: 'HARD' as CompanyDifficulty,
    isPremium: true,
  },
  {
    name: 'Airbnb',
    slug: 'airbnb',
    description: 'Product engineering with strong coding standards',
    industry: 'Hospitality/Technology',
    size: 'Medium',
    locations: ['San Francisco, CA'],
    interviewDifficulty: 'HARD' as CompanyDifficulty,
    isPremium: true,
  },
];

const topics = [
  // DSA Topics
  {
    name: 'Arrays & Strings',
    slug: 'arrays-strings',
    category: 'ARRAYS' as QuestionCategory,
    description: 'Fundamental data structures and manipulation techniques',
    difficulty: 'EASY' as Difficulty,
    estimatedHours: 20,
    prerequisites: [],
  },
  {
    name: 'Two Pointers',
    slug: 'two-pointers',
    category: 'ARRAYS' as QuestionCategory,
    description: 'Efficient array traversal technique',
    difficulty: 'EASY' as Difficulty,
    estimatedHours: 10,
    prerequisites: [],
  },
  {
    name: 'Sliding Window',
    slug: 'sliding-window',
    category: 'ARRAYS' as QuestionCategory,
    description: 'Optimize subarray/substring problems',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 15,
    prerequisites: ['two-pointers'],
  },
  {
    name: 'Binary Search',
    slug: 'binary-search',
    category: 'SEARCHING' as QuestionCategory,
    description: 'Efficient search in sorted data',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 12,
    prerequisites: [],
  },
  {
    name: 'Linked Lists',
    slug: 'linked-lists',
    category: 'LINKED_LISTS' as QuestionCategory,
    description: 'Pointer manipulation and list operations',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 15,
    prerequisites: [],
  },
  {
    name: 'Trees',
    slug: 'trees',
    category: 'TREES' as QuestionCategory,
    description: 'Binary trees, BST, and tree traversals',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 25,
    prerequisites: [],
  },
  {
    name: 'Graphs',
    slug: 'graphs',
    category: 'GRAPHS' as QuestionCategory,
    description: 'BFS, DFS, shortest paths, and connectivity',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 30,
    prerequisites: ['trees'],
  },
  {
    name: 'Dynamic Programming',
    slug: 'dynamic-programming',
    category: 'DYNAMIC_PROGRAMMING' as QuestionCategory,
    description: 'Optimization problems with overlapping subproblems',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 40,
    prerequisites: ['arrays-strings'],
  },
  {
    name: 'Backtracking',
    slug: 'backtracking',
    category: 'BACKTRACKING' as QuestionCategory,
    description: 'Exhaustive search with pruning',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 20,
    prerequisites: ['recursion'],
  },

  // Frontend Topics
  {
    name: 'JavaScript Fundamentals',
    slug: 'javascript-fundamentals',
    category: 'JAVASCRIPT_ES6' as QuestionCategory,
    description: 'Core JavaScript concepts and ES6+ features',
    difficulty: 'EASY' as Difficulty,
    estimatedHours: 30,
    prerequisites: [],
  },
  {
    name: 'React Hooks',
    slug: 'react-hooks',
    category: 'REACT' as QuestionCategory,
    description: 'useState, useEffect, custom hooks',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 25,
    prerequisites: ['javascript-fundamentals'],
  },
  {
    name: 'React State Management',
    slug: 'react-state-management',
    category: 'STATE_MANAGEMENT' as QuestionCategory,
    description: 'Redux, Context API, Zustand',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 20,
    prerequisites: ['react-hooks'],
  },
  {
    name: 'CSS Layouts',
    slug: 'css-layouts',
    category: 'HTML_CSS' as QuestionCategory,
    description: 'Flexbox, Grid, responsive design',
    difficulty: 'EASY' as Difficulty,
    estimatedHours: 15,
    prerequisites: [],
  },
  {
    name: 'Web Performance',
    slug: 'web-performance',
    category: 'WEB_PERFORMANCE' as QuestionCategory,
    description: 'Optimization, lazy loading, code splitting',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 20,
    prerequisites: ['react-hooks'],
  },

  // Backend Topics
  {
    name: 'REST API Design',
    slug: 'rest-api-design',
    category: 'REST_API_DESIGN' as QuestionCategory,
    description: 'RESTful principles and best practices',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 20,
    prerequisites: [],
  },
  {
    name: 'Database Design',
    slug: 'database-design',
    category: 'DATABASE_DESIGN' as QuestionCategory,
    description: 'Schema design, normalization, indexes',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 25,
    prerequisites: [],
  },
  {
    name: 'SQL Queries',
    slug: 'sql-queries',
    category: 'SQL' as QuestionCategory,
    description: 'Complex queries, joins, aggregations',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 20,
    prerequisites: ['database-design'],
  },
  {
    name: 'Authentication & Authorization',
    slug: 'auth',
    category: 'AUTHENTICATION' as QuestionCategory,
    description: 'JWT, OAuth, session management',
    difficulty: 'MEDIUM' as Difficulty,
    estimatedHours: 15,
    prerequisites: ['rest-api-design'],
  },
  {
    name: 'Caching Strategies',
    slug: 'caching',
    category: 'CACHING' as QuestionCategory,
    description: 'Redis, CDN, cache patterns',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 15,
    prerequisites: ['database-design'],
  },
  {
    name: 'Microservices',
    slug: 'microservices',
    category: 'MICROSERVICES' as QuestionCategory,
    description: 'Service architecture, communication patterns',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 30,
    prerequisites: ['rest-api-design'],
  },

  // System Design
  {
    name: 'System Design Fundamentals',
    slug: 'system-design-fundamentals',
    category: 'SCALABILITY' as QuestionCategory,
    description: 'Load balancing, caching, databases',
    difficulty: 'HARD' as Difficulty,
    estimatedHours: 40,
    prerequisites: ['database-design', 'caching'],
  },
];

export async function seedCompaniesAndTopics() {
  console.log('üè¢ Seeding companies and topics...\n');

  // Seed companies
  console.log('üì¶ Seeding companies...');
  for (const company of companies) {
    await prisma.company.upsert({
      where: { slug: company.slug },
      update: company,
      create: company,
    });
    console.log(`‚úì Added company: ${company.name}`);
  }

  // Seed topics
  console.log('\nüìö Seeding topics...');
  for (const topic of topics) {
    await prisma.topic.upsert({
      where: { slug: topic.slug },
      update: topic,
      create: topic,
    });
    console.log(`‚úì Added topic: ${topic.name}`);
  }

  console.log(
    `\n‚úÖ Successfully seeded ${companies.length} companies and ${topics.length} topics!`,
  );
}

if (require.main === module) {
  seedCompaniesAndTopics()
    .then(() => {
      console.log('\n‚úÖ Seed completed!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Seeding failed:', error);
      process.exit(1);
    });
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\seed-database.ts
==============================

/**
 * Sample Data Seeder
 * Seeds the vector database with sample interview questions and content
 */

import dotenv from 'dotenv';
import { v4 as uuidv4 } from 'uuid';
import { PineconeVectorDatabase } from '../services/vector-db/pinecone-db';
import { Document } from '../types';

dotenv.config();

/**
 * Sample DSA problems
 */
const dsaProblems: Partial<Document>[] = [
  {
    content: `Two Sum Problem: Given an array of integers and a target sum, find two numbers that add up to the target. 
    Solution: Use a hash map to store complements. Time: O(n), Space: O(n).
    Example: [2,7,11,15], target=9 ‚Üí [0,1]`,
    metadata: {
      source: 'LeetCode',
      category: 'dsa',
      tags: ['array', 'hash-map', 'easy'],
      difficulty: 'easy',
    },
  },
  {
    content: `Binary Tree Level Order Traversal: Return the level order traversal of a binary tree.
    Solution: Use BFS with a queue. Track level size to separate levels.
    Time: O(n), Space: O(n) for the queue.`,
    metadata: {
      source: 'LeetCode',
      category: 'dsa',
      tags: ['tree', 'bfs', 'medium'],
      difficulty: 'medium',
    },
  },
  {
    content: `Longest Palindromic Substring: Find the longest palindromic substring in a string.
    Solutions: (1) Expand around center O(n¬≤), (2) Manacher's algorithm O(n), (3) DP O(n¬≤).
    Example: "babad" ‚Üí "bab" or "aba"`,
    metadata: {
      source: 'LeetCode',
      category: 'dsa',
      tags: ['string', 'dynamic-programming', 'medium'],
      difficulty: 'medium',
    },
  },
  {
    content: `Merge K Sorted Lists: Merge k sorted linked lists into one sorted list.
    Solution: Use min-heap to track smallest elements. Time: O(N log k) where N is total nodes.
    Alternative: Divide and conquer approach merging pairs.`,
    metadata: {
      source: 'LeetCode',
      category: 'dsa',
      tags: ['linked-list', 'heap', 'hard'],
      difficulty: 'hard',
    },
  },
];

/**
 * Sample system design content
 */
const systemDesignContent: Partial<Document>[] = [
  {
    content: `URL Shortener Design:
    Requirements: Generate short URLs, redirect to original, track analytics.
    Components: (1) API Gateway, (2) Short URL Generator (Base62 encoding), (3) Database (KV store like Redis + SQL), (4) Cache (Redis).
    Scale: Hash-based partitioning, 100K writes/sec, 10M reads/sec.
    Storage: ~1TB for 1B URLs. TTL for expiration.`,
    metadata: {
      source: 'System Design Interview',
      category: 'system_design',
      tags: ['url-shortener', 'scalability', 'caching'],
    },
  },
  {
    content: `Rate Limiter Design:
    Algorithms: (1) Token Bucket, (2) Leaky Bucket, (3) Fixed Window, (4) Sliding Window.
    Best: Token Bucket for burst handling.
    Implementation: Redis with INCR + EXPIRE. Distributed: Use Redis cluster or sticky sessions.
    Considerations: User ID vs IP-based, per-API limits.`,
    metadata: {
      source: 'System Design Interview',
      category: 'system_design',
      tags: ['rate-limiting', 'distributed-systems'],
    },
  },
  {
    content: `News Feed Design (Facebook/Twitter):
    Pull model: User requests ‚Üí Fetch from friends ‚Üí Merge + sort. Slow for popular users.
    Push model: Pre-compute feeds ‚Üí Store in cache. Fast reads, expensive writes.
    Hybrid: Push for most users, pull for celebrities.
    Storage: User graph in graph DB, posts in NoSQL, feed cache in Redis.`,
    metadata: {
      source: 'System Design Interview',
      category: 'system_design',
      tags: ['news-feed', 'caching', 'scalability'],
    },
  },
];

/**
 * Sample behavioral questions
 */
const behavioralContent: Partial<Document>[] = [
  {
    content: `STAR Method Framework:
    Situation: Set the context (when, where, background)
    Task: Describe your responsibility/challenge
    Action: Explain what YOU did (be specific)
    Result: Share outcomes with metrics if possible
    
    Example: "Tell me about a time you handled a conflict"
    - Situation: Team disagreed on API design
    - Task: Needed consensus before deadline
    - Action: Organized technical review, gathered requirements, proposed compromise
    - Result: Shipped on time, both approaches validated`,
    metadata: {
      source: 'Interview Guide',
      category: 'behavioral',
      tags: ['star-method', 'framework'],
    },
  },
  {
    content: `Common Behavioral Questions:
    1. Tell me about a time you failed
    2. Describe a conflict with a teammate
    3. How do you handle tight deadlines?
    4. Tell me about your greatest achievement
    5. Why do you want to work here?
    
    Pro tips: Be honest, show growth, use specific examples, quantify results.`,
    metadata: {
      source: 'Interview Guide',
      category: 'behavioral',
      tags: ['common-questions', 'preparation'],
    },
  },
];

/**
 * Seed the database
 */
async function seedDatabase() {
  try {
    console.log('üå± Starting database seeding...\n');

    // Initialize Pinecone
    const pineconeApiKey = process.env.PINECONE_API_KEY;
    const indexName = process.env.PINECONE_INDEX_NAME || 'interview-coach';
    const namespace = process.env.PINECONE_NAMESPACE || 'default';
    const cloud = process.env.PINECONE_CLOUD || 'aws';
    const region = process.env.PINECONE_REGION || 'us-east-1';

    if (!pineconeApiKey) {
      throw new Error('PINECONE_API_KEY not found in environment variables');
    }

    const vectorDb = new PineconeVectorDatabase(
      {
        indexName,
        namespace,
        cloud,
        region,
        embeddingDimension: 1536,
      },
      pineconeApiKey,
    );

    console.log('Connecting to Pinecone...');
    await vectorDb.initialize({
      indexName,
      namespace,
      cloud,
      region,
    });
    console.log('‚úÖ Connected to Pinecone\n');

    // Clear existing data
    console.log('Clearing existing data...');
    await vectorDb.clear();
    console.log('‚úÖ Database cleared\n');

    // Prepare all documents
    const allDocuments: Document[] = [
      ...dsaProblems,
      ...systemDesignContent,
      ...behavioralContent,
    ].map((doc) => ({
      id: uuidv4(),
      content: doc.content!,
      metadata: {
        ...doc.metadata!,
        dateAdded: new Date(),
      },
    }));

    // Seed documents
    console.log(`Seeding ${allDocuments.length} documents...\n`);

    for (const doc of allDocuments) {
      console.log(`Adding: ${doc.content.substring(0, 60)}...`);
      await vectorDb.addDocument(doc);
    }

    console.log('\n‚úÖ Successfully seeded database!');
    console.log(`\nSummary:`);
    console.log(`  ‚Ä¢ DSA Problems: ${dsaProblems.length}`);
    console.log(`  ‚Ä¢ System Design: ${systemDesignContent.length}`);
    console.log(`  ‚Ä¢ Behavioral: ${behavioralContent.length}`);
    console.log(`  ‚Ä¢ Total: ${allDocuments.length}`);

    // Close connection
    await vectorDb.close();
    console.log('\n‚úÖ Done!');
  } catch (error) {
    console.error('‚ùå Seeding failed:');
    console.error(error);
    process.exit(1);
  }
}

// Run seeder
seedDatabase();


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\seed-question-templates.ts
==============================

// src/utils/seed-question-templates.ts
import prisma from '../config/database';
import { QuestionCategory, Difficulty } from '@prisma/client';

const questionTemplates = [
  {
    name: 'Array Two Pointer Pattern',
    category: 'ARRAYS' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Given a sorted array of {dataType}, find two {dataType}s that {operation} to a target value.

Constraints:
- Array length: {minLength} to {maxLength}
- Values: {valueRange}
- Must use O(1) space

Example:
Input: arr = {exampleInput}, target = {exampleTarget}
Output: {exampleOutput}`,
    variables: {
      dataType: ['integers', 'numbers', 'positive integers'],
      operation: ['sum', 'multiply', 'difference'],
      minLength: [2, 10, 100],
      maxLength: [1000, 10000, 100000],
      valueRange: ['-1000 to 1000', '0 to 10^9', 'any integer'],
      exampleInput: ['[1,2,3,4,5]', '[2,7,11,15]'],
      exampleTarget: [9, 18],
      exampleOutput: ['[0,4]', '[1,2]'],
    },
    exampleQuestion:
      'Given a sorted array of integers, find two numbers that sum to a target value.',
    constraints: {
      timeComplexity: 'O(n)',
      spaceComplexity: 'O(1)',
    },
  },
  {
    name: 'Tree Traversal Pattern',
    category: 'TREES' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Given a binary tree, {operation} the tree and return {returnValue}.

Constraints:
- Number of nodes: {minNodes} to {maxNodes}
- Node values: {valueRange}
- Tree may be {treeType}

Example:
Input: root = {exampleInput}
Output: {exampleOutput}`,
    variables: {
      operation: ['traverse', 'search', 'modify'],
      returnValue: [
        'all nodes in level order',
        'the maximum path sum',
        'the right side view',
      ],
      minNodes: [0, 1, 10],
      maxNodes: [100, 1000, 10000],
      valueRange: ['-100 to 100', '0 to 1000', 'any integer'],
      treeType: ['empty', 'balanced', 'skewed', 'complete'],
      exampleInput: ['[1,2,3,null,5]', '[3,9,20,null,null,15,7]'],
      exampleOutput: ['[[1],[2,3],[5]]', '42'],
    },
    exampleQuestion:
      'Given a binary tree, return the level order traversal of its nodes.',
  },
  {
    name: 'String Manipulation Pattern',
    category: 'STRINGS' as QuestionCategory,
    difficulty: 'EASY' as Difficulty,
    template: `Given a string s, {operation} and return {returnValue}.

Constraints:
- String length: {minLength} to {maxLength}
- Characters: {characterSet}
- {additionalConstraint}

Example:
Input: s = "{exampleInput}"
Output: {exampleOutput}`,
    variables: {
      operation: [
        'reverse',
        'check if palindrome',
        'find longest substring',
        'count characters',
      ],
      returnValue: [
        'the modified string',
        'true or false',
        'the length',
        'a character map',
      ],
      minLength: [0, 1, 10],
      maxLength: [100, 1000, 10000],
      characterSet: [
        'lowercase letters',
        'alphanumeric',
        'printable ASCII',
        'any unicode',
      ],
      additionalConstraint: [
        'Case sensitive',
        'Ignore spaces',
        'Consider only letters',
      ],
      exampleInput: ['hello', 'A man, a plan, a canal: Panama', 'abcabcbb'],
      exampleOutput: ['olleh', 'true', '3'],
    },
    exampleQuestion: 'Given a string, reverse it without using extra space.',
  },
  {
    name: 'Dynamic Programming Pattern',
    category: 'DYNAMIC_PROGRAMMING' as QuestionCategory,
    difficulty: 'HARD' as Difficulty,
    template: `You are given {input}. Find the {objective} way to {operation}.

Constraints:
- Input size: {minSize} to {maxSize}
- Values: {valueRange}
- {specialConstraint}

Example:
Input: {exampleInput}
Output: {exampleOutput}
Explanation: {exampleExplanation}`,
    variables: {
      input: ['an array of integers', 'a string', 'a matrix', 'two strings'],
      objective: ['minimum', 'maximum', 'number of'],
      operation: [
        'partition the array',
        'find subsequences',
        'transform string A to B',
        'climb stairs',
      ],
      minSize: [1, 2, 10],
      maxSize: [100, 1000, 10000],
      valueRange: ['1 to 100', '0 to 10^9', 'any positive integer'],
      specialConstraint: [
        'Must use O(n) space',
        'Cannot modify input',
        'Must be optimal',
      ],
      exampleInput: ['[1,5,11,5]', 's = "rabbbit", t = "rabbit"', 'n = 5'],
      exampleOutput: ['true', '3', '8'],
      exampleExplanation: [
        'Can partition into [1,5,5] and [11]',
        'Three ways to form t',
        '8 ways to climb 5 stairs',
      ],
    },
    exampleQuestion:
      'Find the minimum number of operations to transform string A to string B.',
  },
  {
    name: 'Graph Traversal Pattern',
    category: 'GRAPHS' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Given a graph with {graphType}, find {objective}.

Graph representation: {representation}

Constraints:
- Number of nodes: {minNodes} to {maxNodes}
- Number of edges: {minEdges} to {maxEdges}
- {graphProperty}

Example:
Input: {exampleInput}
Output: {exampleOutput}`,
    variables: {
      graphType: ['directed edges', 'undirected edges', 'weighted edges'],
      objective: [
        'the shortest path',
        'if a cycle exists',
        'all connected components',
        'minimum spanning tree',
      ],
      representation: ['adjacency list', 'adjacency matrix', 'edge list'],
      minNodes: [1, 2, 10],
      maxNodes: [100, 1000, 10000],
      minEdges: [0, 1, 10],
      maxEdges: [1000, 10000, 100000],
      graphProperty: [
        'Graph is connected',
        'No self-loops',
        'May contain cycles',
      ],
      exampleInput: [
        'n=5, edges=[[0,1],[1,2],[2,3],[3,4]]',
        'graph = [[1,2],[0,2],[0,1]]',
      ],
      exampleOutput: ['4', 'true'],
    },
    exampleQuestion:
      'Find the shortest path from node A to node B in a weighted graph.',
  },
  {
    name: 'React Component Pattern',
    category: 'REACT' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Create a React component that {functionality}.

Requirements:
- Use {hookType}
- Handle {edgeCase}
- Implement {feature}
- {performanceRequirement}

Example usage:
{exampleCode}`,
    variables: {
      functionality: [
        'displays a list with pagination',
        'implements a custom form',
        'creates a reusable modal',
      ],
      hookType: [
        'useState and useEffect',
        'useReducer',
        'custom hooks',
        'useContext',
      ],
      edgeCase: [
        'loading states',
        'error boundaries',
        'empty data',
        'API failures',
      ],
      feature: [
        'search functionality',
        'filtering',
        'sorting',
        'infinite scroll',
      ],
      performanceRequirement: [
        'Should memoize expensive calculations',
        'Must prevent unnecessary re-renders',
        'Should lazy load images',
      ],
      exampleCode: [
        '<UserList users={data} />',
        '<DataTable data={rows} columns={cols} />',
      ],
    },
    exampleQuestion:
      'Create a React component that displays a paginated list of users.',
  },
  {
    name: 'REST API Design Pattern',
    category: 'REST_API_DESIGN' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Design a RESTful API for {resource} that supports {operations}.

Requirements:
- Follow REST principles
- Include {authMethod}
- Handle {errorScenario}
- Implement {additionalFeature}
- Support {dataFormat}

Endpoints to design:
{exampleEndpoints}`,
    variables: {
      resource: [
        'a blog system',
        'an e-commerce platform',
        'a social media app',
        'a task manager',
      ],
      operations: [
        'CRUD operations',
        'pagination and filtering',
        'search',
        'bulk operations',
      ],
      authMethod: [
        'JWT authentication',
        'OAuth 2.0',
        'API keys',
        'session-based auth',
      ],
      errorScenario: [
        'validation errors',
        'authentication failures',
        'rate limiting',
        '404 not found',
      ],
      additionalFeature: [
        'versioning',
        'HATEOAS',
        'caching headers',
        'webhook support',
      ],
      dataFormat: ['JSON', 'JSON and XML', 'form data for uploads'],
      exampleEndpoints: [
        'GET /api/posts, POST /api/posts, PUT /api/posts/:id',
        'GET /api/users/:id/orders, POST /api/cart/checkout',
      ],
    },
    exampleQuestion:
      'Design a RESTful API for a blog system with posts, comments, and users.',
  },
  {
    name: 'SQL Query Pattern',
    category: 'SQL' as QuestionCategory,
    difficulty: 'MEDIUM' as Difficulty,
    template: `Write a SQL query to {objective} from {tableDescription}.

Tables:
{tableSchema}

Requirements:
- {requirement1}
- {requirement2}
- {performanceNote}

Example output:
{exampleOutput}`,
    variables: {
      objective: [
        'find all records',
        'calculate aggregates',
        'join multiple tables',
        'rank results',
      ],
      tableDescription: [
        'a users and orders database',
        'employee and department tables',
        'product inventory',
      ],
      tableSchema: [
        'Users(id, name, email), Orders(id, user_id, amount, date)',
        'Employees(id, name, dept_id, salary), Departments(id, name)',
      ],
      requirement1: [
        'Must use JOIN',
        'Use window functions',
        'Group by department',
        'Filter by date range',
      ],
      requirement2: [
        'Order results',
        'Include NULL values',
        'Use subqueries',
        'Handle duplicates',
      ],
      performanceNote: [
        'Consider indexing',
        'Optimize for large datasets',
        'Avoid N+1 queries',
      ],
      exampleOutput: [
        'name | total_orders | total_spent',
        'dept_name | avg_salary | employee_count',
      ],
    },
    exampleQuestion:
      'Write a SQL query to find the top 5 customers by total order amount.',
  },
];

export async function seedQuestionTemplates() {
  console.log('üé® Seeding question templates...\n');

  for (const template of questionTemplates) {
    await prisma.questionTemplate.upsert({
      where: { name: template.name },
      update: template,
      create: template,
    });
    console.log(`‚úì Added template: ${template.name}`);
  }

  console.log(
    `\n‚úÖ Successfully seeded ${questionTemplates.length} question templates!`,
  );
}

if (require.main === module) {
  seedQuestionTemplates()
    .then(() => {
      console.log('\n‚úÖ Template seeding completed!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Template seeding failed:', error);
      process.exit(1);
    });
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\token.util.ts
==============================

// src/utils/token.util.ts
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { JWTPayload } from '../types/auth.types';

const ACCESS_TOKEN_SECRET =
  process.env.JWT_ACCESS_SECRET || 'your-access-secret-key';
const REFRESH_TOKEN_SECRET =
  process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-key';
const ACCESS_TOKEN_EXPIRY = '15m';
const REFRESH_TOKEN_EXPIRY = '7d';

export class TokenUtil {
  static generateAccessToken(payload: Omit<JWTPayload, 'iat' | 'exp'>): string {
    return jwt.sign(payload, ACCESS_TOKEN_SECRET, {
      expiresIn: ACCESS_TOKEN_EXPIRY,
    });
  }

  static generateRefreshToken(
    payload: Omit<JWTPayload, 'iat' | 'exp'>,
  ): string {
    return jwt.sign(payload, REFRESH_TOKEN_SECRET, {
      expiresIn: REFRESH_TOKEN_EXPIRY,
    });
  }

  static verifyAccessToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, ACCESS_TOKEN_SECRET) as JWTPayload;
    } catch (error) {
      throw new Error('Invalid or expired access token');
    }
  }

  static verifyRefreshToken(token: string): JWTPayload {
    try {
      return jwt.verify(token, REFRESH_TOKEN_SECRET) as JWTPayload;
    } catch (error) {
      throw new Error('Invalid or expired refresh token');
    }
  }

  static generateVerificationToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  static generateResetToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  static getRefreshTokenExpiry(): Date {
    return new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days
  }
}


==============================
FILE: E:\My Projects\AI-Interview-Coach\aI-interview-coach-backend\src\utils\validation.ts
==============================

// src/utils/validation.ts
import { z } from 'zod';

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[0-9]/, 'Password must contain number')
    .regex(/[!@#$%^&*]/, 'Password must contain special character'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

export const passwordResetRequestSchema = z.object({
  email: z.string().email('Invalid email address'),
});

export const passwordResetConfirmSchema = z.object({
  token: z.string().min(1, 'Reset token is required'),
  newPassword: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[0-9]/, 'Password must contain number')
    .regex(/[!@#$%^&*]/, 'Password must contain special character'),
});
